/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <cinttypes>
#include <cstdint>

#include <app-common/zap-generated/af-structs.h>
#include <app-common/zap-generated/callback.h>
#include <app-common/zap-generated/cluster-objects.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app/CommandHandler.h>
#include <app/InteractionModelEngine.h>
#include <app/util/util.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/support/TypeTraits.h>

// Currently we need some work to keep compatible with ember lib.
#include <app/util/ember-compatibility-functions.h>

namespace chip {
namespace app {

namespace {
void MaybeDispatchServerError(CommandHandler * handler, const ConcreteCommandPath & path, CHIP_ERROR error)
{
    VerifyOrReturn(CHIP_NO_ERROR != error);

    if (error == CHIP_IM_GLOBAL_STATUS(UnsupportedCluster))
    {
        ChipLogError(Zcl, "Unknown cluster " ChipLogFormatMEI, ChipLogValueMEI(path.mClusterId));
    }
    else if (error == CHIP_IM_GLOBAL_STATUS(UnsupportedCommand))
    {
        // Unrecognized command ID, error status will apply.
        ChipLogError(Zcl, "Unknown command " ChipLogFormatMEI " for cluster " ChipLogFormatMEI, ChipLogValueMEI(path.mCommandId),
                     ChipLogValueMEI(path.mClusterId));
    }
    else
    {
        ChipLogProgress(Zcl, "Failed to dispatch command, Error=%" CHIP_ERROR_FORMAT, error.Format());
    }

    auto status = error.IsIMStatus() ? StatusIB(error).mStatus : Protocols::InteractionModel::Status::InvalidCommand;
    handler->AddStatus(path, status);
}
} // namespace

// Cluster specific command parsing

namespace Clusters {

namespace AdministratorCommissioning {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::OpenCommissioningWindow::Id: {
        Commands::OpenCommissioningWindow::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfAdministratorCommissioningClusterOpenCommissioningWindowCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::OpenBasicCommissioningWindow::Id: {
        Commands::OpenBasicCommissioningWindow::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfAdministratorCommissioningClusterOpenBasicCommissioningWindowCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RevokeCommissioning::Id: {
        Commands::RevokeCommissioning::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfAdministratorCommissioningClusterRevokeCommissioningCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace AdministratorCommissioning

namespace BarrierControl {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::BarrierControlGoToPercent::Id: {
        Commands::BarrierControlGoToPercent::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfBarrierControlClusterBarrierControlGoToPercentCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::BarrierControlStop::Id: {
        Commands::BarrierControlStop::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfBarrierControlClusterBarrierControlStopCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace BarrierControl

namespace ColorControl {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::MoveToHue::Id: {
        Commands::MoveToHue::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveToHueCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveHue::Id: {
        Commands::MoveHue::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveHueCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StepHue::Id: {
        Commands::StepHue::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterStepHueCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveToSaturation::Id: {
        Commands::MoveToSaturation::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveToSaturationCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveSaturation::Id: {
        Commands::MoveSaturation::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveSaturationCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StepSaturation::Id: {
        Commands::StepSaturation::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterStepSaturationCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveToHueAndSaturation::Id: {
        Commands::MoveToHueAndSaturation::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveToHueAndSaturationCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveToColor::Id: {
        Commands::MoveToColor::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveToColorCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveColor::Id: {
        Commands::MoveColor::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveColorCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StepColor::Id: {
        Commands::StepColor::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterStepColorCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveToColorTemperature::Id: {
        Commands::MoveToColorTemperature::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveToColorTemperatureCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::EnhancedMoveToHue::Id: {
        Commands::EnhancedMoveToHue::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterEnhancedMoveToHueCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::EnhancedMoveHue::Id: {
        Commands::EnhancedMoveHue::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterEnhancedMoveHueCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::EnhancedStepHue::Id: {
        Commands::EnhancedStepHue::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterEnhancedStepHueCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::EnhancedMoveToHueAndSaturation::Id: {
        Commands::EnhancedMoveToHueAndSaturation::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterEnhancedMoveToHueAndSaturationCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ColorLoopSet::Id: {
        Commands::ColorLoopSet::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterColorLoopSetCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StopMoveStep::Id: {
        Commands::StopMoveStep::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterStopMoveStepCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveColorTemperature::Id: {
        Commands::MoveColorTemperature::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterMoveColorTemperatureCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StepColorTemperature::Id: {
        Commands::StepColorTemperature::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfColorControlClusterStepColorTemperatureCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace ColorControl

namespace DiagnosticLogs {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::RetrieveLogsRequest::Id: {
        Commands::RetrieveLogsRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDiagnosticLogsClusterRetrieveLogsRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace DiagnosticLogs

namespace DoorLock {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::LockDoor::Id: {
        Commands::LockDoor::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterLockDoorCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::UnlockDoor::Id: {
        Commands::UnlockDoor::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterUnlockDoorCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::UnlockWithTimeout::Id: {
        Commands::UnlockWithTimeout::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterUnlockWithTimeoutCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::SetWeekDaySchedule::Id: {
        Commands::SetWeekDaySchedule::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterSetWeekDayScheduleCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GetWeekDaySchedule::Id: {
        Commands::GetWeekDaySchedule::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterGetWeekDayScheduleCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ClearWeekDaySchedule::Id: {
        Commands::ClearWeekDaySchedule::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterClearWeekDayScheduleCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::SetYearDaySchedule::Id: {
        Commands::SetYearDaySchedule::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterSetYearDayScheduleCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GetYearDaySchedule::Id: {
        Commands::GetYearDaySchedule::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterGetYearDayScheduleCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::SetUser::Id: {
        Commands::SetUser::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterSetUserCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GetUser::Id: {
        Commands::GetUser::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterGetUserCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ClearUser::Id: {
        Commands::ClearUser::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterClearUserCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::SetCredential::Id: {
        Commands::SetCredential::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterSetCredentialCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GetCredentialStatus::Id: {
        Commands::GetCredentialStatus::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterGetCredentialStatusCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ClearCredential::Id: {
        Commands::ClearCredential::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDoorLockClusterClearCredentialCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace DoorLock

namespace EthernetNetworkDiagnostics {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ResetCounts::Id: {
        Commands::ResetCounts::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfEthernetNetworkDiagnosticsClusterResetCountsCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace EthernetNetworkDiagnostics

namespace FaultInjection {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::FailAtFault::Id: {
        Commands::FailAtFault::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfFaultInjectionClusterFailAtFaultCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::FailRandomlyAtFault::Id: {
        Commands::FailRandomlyAtFault::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfFaultInjectionClusterFailRandomlyAtFaultCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace FaultInjection

namespace GeneralCommissioning {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ArmFailSafe::Id: {
        Commands::ArmFailSafe::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGeneralCommissioningClusterArmFailSafeCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::SetRegulatoryConfig::Id: {
        Commands::SetRegulatoryConfig::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGeneralCommissioningClusterSetRegulatoryConfigCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::CommissioningComplete::Id: {
        Commands::CommissioningComplete::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGeneralCommissioningClusterCommissioningCompleteCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace GeneralCommissioning

namespace GeneralDiagnostics {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::TestEventTrigger::Id: {
        Commands::TestEventTrigger::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGeneralDiagnosticsClusterTestEventTriggerCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace GeneralDiagnostics

namespace GroupKeyManagement {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::KeySetWrite::Id: {
        Commands::KeySetWrite::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupKeyManagementClusterKeySetWriteCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::KeySetRead::Id: {
        Commands::KeySetRead::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupKeyManagementClusterKeySetReadCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::KeySetRemove::Id: {
        Commands::KeySetRemove::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupKeyManagementClusterKeySetRemoveCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::KeySetReadAllIndices::Id: {
        Commands::KeySetReadAllIndices::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupKeyManagementClusterKeySetReadAllIndicesCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace GroupKeyManagement

namespace Groups {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::AddGroup::Id: {
        Commands::AddGroup::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupsClusterAddGroupCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ViewGroup::Id: {
        Commands::ViewGroup::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupsClusterViewGroupCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GetGroupMembership::Id: {
        Commands::GetGroupMembership::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupsClusterGetGroupMembershipCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RemoveGroup::Id: {
        Commands::RemoveGroup::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupsClusterRemoveGroupCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RemoveAllGroups::Id: {
        Commands::RemoveAllGroups::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupsClusterRemoveAllGroupsCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::AddGroupIfIdentifying::Id: {
        Commands::AddGroupIfIdentifying::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupsClusterAddGroupIfIdentifyingCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace Groups

namespace Identify {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::Identify::Id: {
        Commands::Identify::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfIdentifyClusterIdentifyCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TriggerEffect::Id: {
        Commands::TriggerEffect::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfIdentifyClusterTriggerEffectCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace Identify

namespace KeypadInput {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::SendKey::Id: {
        Commands::SendKey::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfKeypadInputClusterSendKeyCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace KeypadInput

namespace LevelControl {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::MoveToLevel::Id: {
        Commands::MoveToLevel::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLevelControlClusterMoveToLevelCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::Move::Id: {
        Commands::Move::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLevelControlClusterMoveCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::Step::Id: {
        Commands::Step::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLevelControlClusterStepCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::Stop::Id: {
        Commands::Stop::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLevelControlClusterStopCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveToLevelWithOnOff::Id: {
        Commands::MoveToLevelWithOnOff::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLevelControlClusterMoveToLevelWithOnOffCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::MoveWithOnOff::Id: {
        Commands::MoveWithOnOff::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLevelControlClusterMoveWithOnOffCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StepWithOnOff::Id: {
        Commands::StepWithOnOff::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLevelControlClusterStepWithOnOffCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StopWithOnOff::Id: {
        Commands::StopWithOnOff::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLevelControlClusterStopWithOnOffCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace LevelControl

namespace LowPower {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::Sleep::Id: {
        Commands::Sleep::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfLowPowerClusterSleepCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace LowPower

namespace MediaInput {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::SelectInput::Id: {
        Commands::SelectInput::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfMediaInputClusterSelectInputCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ShowInputStatus::Id: {
        Commands::ShowInputStatus::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfMediaInputClusterShowInputStatusCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::HideInputStatus::Id: {
        Commands::HideInputStatus::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfMediaInputClusterHideInputStatusCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RenameInput::Id: {
        Commands::RenameInput::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfMediaInputClusterRenameInputCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace MediaInput

namespace ModeSelect {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ChangeToMode::Id: {
        Commands::ChangeToMode::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfModeSelectClusterChangeToModeCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace ModeSelect

namespace NetworkCommissioning {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ScanNetworks::Id: {
        Commands::ScanNetworks::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterScanNetworksCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::AddOrUpdateWiFiNetwork::Id: {
        Commands::AddOrUpdateWiFiNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterAddOrUpdateWiFiNetworkCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::AddOrUpdateThreadNetwork::Id: {
        Commands::AddOrUpdateThreadNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterAddOrUpdateThreadNetworkCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RemoveNetwork::Id: {
        Commands::RemoveNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterRemoveNetworkCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ConnectNetwork::Id: {
        Commands::ConnectNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterConnectNetworkCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ReorderNetwork::Id: {
        Commands::ReorderNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterReorderNetworkCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace NetworkCommissioning

namespace OtaSoftwareUpdateRequestor {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::AnnounceOtaProvider::Id: {
        Commands::AnnounceOtaProvider::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOtaSoftwareUpdateRequestorClusterAnnounceOtaProviderCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace OtaSoftwareUpdateRequestor

namespace OnOff {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::Off::Id: {
        Commands::Off::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOnOffClusterOffCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::On::Id: {
        Commands::On::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOnOffClusterOnCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::Toggle::Id: {
        Commands::Toggle::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOnOffClusterToggleCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::OffWithEffect::Id: {
        Commands::OffWithEffect::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOnOffClusterOffWithEffectCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::OnWithRecallGlobalScene::Id: {
        Commands::OnWithRecallGlobalScene::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOnOffClusterOnWithRecallGlobalSceneCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::OnWithTimedOff::Id: {
        Commands::OnWithTimedOff::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOnOffClusterOnWithTimedOffCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace OnOff

namespace OperationalCredentials {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::AttestationRequest::Id: {
        Commands::AttestationRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterAttestationRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::CertificateChainRequest::Id: {
        Commands::CertificateChainRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterCertificateChainRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::CSRRequest::Id: {
        Commands::CSRRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterCSRRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::AddNOC::Id: {
        Commands::AddNOC::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterAddNOCCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::UpdateNOC::Id: {
        Commands::UpdateNOC::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterUpdateNOCCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::UpdateFabricLabel::Id: {
        Commands::UpdateFabricLabel::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterUpdateFabricLabelCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RemoveFabric::Id: {
        Commands::RemoveFabric::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterRemoveFabricCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::AddTrustedRootCertificate::Id: {
        Commands::AddTrustedRootCertificate::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterAddTrustedRootCertificateCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace OperationalCredentials

namespace Scenes {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::AddScene::Id: {
        Commands::AddScene::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfScenesClusterAddSceneCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ViewScene::Id: {
        Commands::ViewScene::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfScenesClusterViewSceneCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RemoveScene::Id: {
        Commands::RemoveScene::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfScenesClusterRemoveSceneCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RemoveAllScenes::Id: {
        Commands::RemoveAllScenes::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfScenesClusterRemoveAllScenesCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StoreScene::Id: {
        Commands::StoreScene::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfScenesClusterStoreSceneCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RecallScene::Id: {
        Commands::RecallScene::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfScenesClusterRecallSceneCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GetSceneMembership::Id: {
        Commands::GetSceneMembership::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfScenesClusterGetSceneMembershipCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace Scenes

namespace SoftwareDiagnostics {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ResetWatermarks::Id: {
        Commands::ResetWatermarks::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfSoftwareDiagnosticsClusterResetWatermarksCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace SoftwareDiagnostics

namespace TargetNavigator {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::NavigateTarget::Id: {
        Commands::NavigateTarget::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTargetNavigatorClusterNavigateTargetCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace TargetNavigator

namespace TestCluster {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::Test::Id: {
        Commands::Test::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestNotHandled::Id: {
        Commands::TestNotHandled::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestNotHandledCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestSpecific::Id: {
        Commands::TestSpecific::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestSpecificCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestAddArguments::Id: {
        Commands::TestAddArguments::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestAddArgumentsCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestStructArgumentRequest::Id: {
        Commands::TestStructArgumentRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestStructArgumentRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestNestedStructArgumentRequest::Id: {
        Commands::TestNestedStructArgumentRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestNestedStructArgumentRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestListStructArgumentRequest::Id: {
        Commands::TestListStructArgumentRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestListStructArgumentRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestListInt8UArgumentRequest::Id: {
        Commands::TestListInt8UArgumentRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestListInt8UArgumentRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestNestedStructListArgumentRequest::Id: {
        Commands::TestNestedStructListArgumentRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestNestedStructListArgumentRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestListNestedStructListArgumentRequest::Id: {
        Commands::TestListNestedStructListArgumentRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestListNestedStructListArgumentRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestListInt8UReverseRequest::Id: {
        Commands::TestListInt8UReverseRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestListInt8UReverseRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestEnumsRequest::Id: {
        Commands::TestEnumsRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestEnumsRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestNullableOptionalRequest::Id: {
        Commands::TestNullableOptionalRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestNullableOptionalRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::SimpleStructEchoRequest::Id: {
        Commands::SimpleStructEchoRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterSimpleStructEchoRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TimedInvokeRequest::Id: {
        Commands::TimedInvokeRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTimedInvokeRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestSimpleOptionalArgumentRequest::Id: {
        Commands::TestSimpleOptionalArgumentRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestSimpleOptionalArgumentRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestEmitTestEventRequest::Id: {
        Commands::TestEmitTestEventRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestEmitTestEventRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::TestEmitTestFabricScopedEventRequest::Id: {
        Commands::TestEmitTestFabricScopedEventRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfTestClusterClusterTestEmitTestFabricScopedEventRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace TestCluster

namespace Thermostat {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::SetpointRaiseLower::Id: {
        Commands::SetpointRaiseLower::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfThermostatClusterSetpointRaiseLowerCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace Thermostat

namespace ThreadNetworkDiagnostics {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ResetCounts::Id: {
        Commands::ResetCounts::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfThreadNetworkDiagnosticsClusterResetCountsCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace ThreadNetworkDiagnostics

namespace WiFiNetworkDiagnostics {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ResetCounts::Id: {
        Commands::ResetCounts::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfWiFiNetworkDiagnosticsClusterResetCountsCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace WiFiNetworkDiagnostics

namespace WindowCovering {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::UpOrOpen::Id: {
        Commands::UpOrOpen::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfWindowCoveringClusterUpOrOpenCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::DownOrClose::Id: {
        Commands::DownOrClose::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfWindowCoveringClusterDownOrCloseCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::StopMotion::Id: {
        Commands::StopMotion::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfWindowCoveringClusterStopMotionCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GoToLiftValue::Id: {
        Commands::GoToLiftValue::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfWindowCoveringClusterGoToLiftValueCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GoToLiftPercentage::Id: {
        Commands::GoToLiftPercentage::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfWindowCoveringClusterGoToLiftPercentageCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GoToTiltValue::Id: {
        Commands::GoToTiltValue::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfWindowCoveringClusterGoToTiltValueCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::GoToTiltPercentage::Id: {
        Commands::GoToTiltPercentage::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfWindowCoveringClusterGoToTiltPercentageCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace WindowCovering

} // namespace Clusters

void DispatchSingleClusterCommand(const ConcreteCommandPath & aCommandPath, TLV::TLVReader & aReader, CommandHandler * apCommandObj)
{
    Compatibility::SetupEmberAfCommandHandler(apCommandObj, aCommandPath);

    CHIP_ERROR err = CHIP_NO_ERROR;
    switch (aCommandPath.mClusterId)
    {
    case Clusters::AdministratorCommissioning::Id:
        err = Clusters::AdministratorCommissioning::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::BarrierControl::Id:
        err = Clusters::BarrierControl::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::ColorControl::Id:
        err = Clusters::ColorControl::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::DiagnosticLogs::Id:
        err = Clusters::DiagnosticLogs::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::DoorLock::Id:
        err = Clusters::DoorLock::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::EthernetNetworkDiagnostics::Id:
        err = Clusters::EthernetNetworkDiagnostics::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::FaultInjection::Id:
        err = Clusters::FaultInjection::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::GeneralCommissioning::Id:
        err = Clusters::GeneralCommissioning::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::GeneralDiagnostics::Id:
        err = Clusters::GeneralDiagnostics::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::GroupKeyManagement::Id:
        err = Clusters::GroupKeyManagement::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::Groups::Id:
        err = Clusters::Groups::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::Identify::Id:
        err = Clusters::Identify::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::KeypadInput::Id:
        err = Clusters::KeypadInput::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::LevelControl::Id:
        err = Clusters::LevelControl::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::LowPower::Id:
        err = Clusters::LowPower::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::MediaInput::Id:
        err = Clusters::MediaInput::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::ModeSelect::Id:
        err = Clusters::ModeSelect::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::NetworkCommissioning::Id:
        err = Clusters::NetworkCommissioning::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::OtaSoftwareUpdateRequestor::Id:
        err = Clusters::OtaSoftwareUpdateRequestor::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::OnOff::Id:
        err = Clusters::OnOff::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::OperationalCredentials::Id:
        err = Clusters::OperationalCredentials::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::Scenes::Id:
        err = Clusters::Scenes::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::SoftwareDiagnostics::Id:
        err = Clusters::SoftwareDiagnostics::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::TargetNavigator::Id:
        err = Clusters::TargetNavigator::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::TestCluster::Id:
        err = Clusters::TestCluster::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::Thermostat::Id:
        err = Clusters::Thermostat::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::ThreadNetworkDiagnostics::Id:
        err = Clusters::ThreadNetworkDiagnostics::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::WiFiNetworkDiagnostics::Id:
        err = Clusters::WiFiNetworkDiagnostics::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::WindowCovering::Id:
        err = Clusters::WindowCovering::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    default:
        err = CHIP_IM_GLOBAL_STATUS(UnsupportedCluster);
        break;
    }
    MaybeDispatchServerError(apCommandObj, aCommandPath, err);

    Compatibility::ResetEmberAfObjects();
}

} // namespace app
} // namespace chip
