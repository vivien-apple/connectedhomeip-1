/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <cinttypes>
#include <cstdint>

#include <app-common/zap-generated/af-structs.h>
#include <app-common/zap-generated/callback.h>
#include <app-common/zap-generated/cluster-objects.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app/CommandHandler.h>
#include <app/InteractionModelEngine.h>
#include <app/util/util.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/support/TypeTraits.h>

// Currently we need some work to keep compatible with ember lib.
#include <app/util/ember-compatibility-functions.h>

namespace chip {
namespace app {

namespace {
void MaybeDispatchServerError(CommandHandler * handler, const ConcreteCommandPath & path, CHIP_ERROR error)
{
    VerifyOrReturn(CHIP_NO_ERROR != error);

    if (error == CHIP_IM_GLOBAL_STATUS(UnsupportedCluster))
    {
        ChipLogError(Zcl, "Unknown cluster " ChipLogFormatMEI, ChipLogValueMEI(path.mClusterId));
    }
    else if (error == CHIP_IM_GLOBAL_STATUS(UnsupportedCommand))
    {
        // Unrecognized command ID, error status will apply.
        ChipLogError(Zcl, "Unknown command " ChipLogFormatMEI " for cluster " ChipLogFormatMEI, ChipLogValueMEI(path.mCommandId),
                     ChipLogValueMEI(path.mClusterId));
    }
    else
    {
        ChipLogProgress(Zcl, "Failed to dispatch command, Error=%" CHIP_ERROR_FORMAT, error.Format());
    }

    auto status = error.IsIMStatus() ? StatusIB(error).mStatus : Protocols::InteractionModel::Status::InvalidCommand;
    handler->AddStatus(path, status);
}
} // namespace

// Cluster specific command parsing

namespace Clusters {

namespace AdministratorCommissioning {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::OpenCommissioningWindow::Id: {
        Commands::OpenCommissioningWindow::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfAdministratorCommissioningClusterOpenCommissioningWindowCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::OpenBasicCommissioningWindow::Id: {
        Commands::OpenBasicCommissioningWindow::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfAdministratorCommissioningClusterOpenBasicCommissioningWindowCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RevokeCommissioning::Id: {
        Commands::RevokeCommissioning::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfAdministratorCommissioningClusterRevokeCommissioningCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace AdministratorCommissioning

namespace DiagnosticLogs {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::RetrieveLogsRequest::Id: {
        Commands::RetrieveLogsRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfDiagnosticLogsClusterRetrieveLogsRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace DiagnosticLogs

namespace EthernetNetworkDiagnostics {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ResetCounts::Id: {
        Commands::ResetCounts::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfEthernetNetworkDiagnosticsClusterResetCountsCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace EthernetNetworkDiagnostics

namespace GeneralCommissioning {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ArmFailSafe::Id: {
        Commands::ArmFailSafe::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGeneralCommissioningClusterArmFailSafeCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::SetRegulatoryConfig::Id: {
        Commands::SetRegulatoryConfig::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGeneralCommissioningClusterSetRegulatoryConfigCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::CommissioningComplete::Id: {
        Commands::CommissioningComplete::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGeneralCommissioningClusterCommissioningCompleteCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace GeneralCommissioning

namespace GeneralDiagnostics {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::TestEventTrigger::Id: {
        Commands::TestEventTrigger::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGeneralDiagnosticsClusterTestEventTriggerCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace GeneralDiagnostics

namespace GroupKeyManagement {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::KeySetWrite::Id: {
        Commands::KeySetWrite::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupKeyManagementClusterKeySetWriteCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::KeySetRead::Id: {
        Commands::KeySetRead::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupKeyManagementClusterKeySetReadCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::KeySetRemove::Id: {
        Commands::KeySetRemove::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupKeyManagementClusterKeySetRemoveCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::KeySetReadAllIndices::Id: {
        Commands::KeySetReadAllIndices::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfGroupKeyManagementClusterKeySetReadAllIndicesCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace GroupKeyManagement

namespace NetworkCommissioning {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::ScanNetworks::Id: {
        Commands::ScanNetworks::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterScanNetworksCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::AddOrUpdateWiFiNetwork::Id: {
        Commands::AddOrUpdateWiFiNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterAddOrUpdateWiFiNetworkCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RemoveNetwork::Id: {
        Commands::RemoveNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterRemoveNetworkCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ConnectNetwork::Id: {
        Commands::ConnectNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterConnectNetworkCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::ReorderNetwork::Id: {
        Commands::ReorderNetwork::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfNetworkCommissioningClusterReorderNetworkCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace NetworkCommissioning

namespace OperationalCredentials {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    switch (path.mCommandId)
    {
    case Commands::AttestationRequest::Id: {
        Commands::AttestationRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterAttestationRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::CertificateChainRequest::Id: {
        Commands::CertificateChainRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterCertificateChainRequestCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::CSRRequest::Id: {
        Commands::CSRRequest::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterCSRRequestCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::AddNOC::Id: {
        Commands::AddNOC::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterAddNOCCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::UpdateNOC::Id: {
        Commands::UpdateNOC::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterUpdateNOCCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::UpdateFabricLabel::Id: {
        Commands::UpdateFabricLabel::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterUpdateFabricLabelCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::RemoveFabric::Id: {
        Commands::RemoveFabric::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterRemoveFabricCallback(handler, path, data), CHIP_ERROR_INTERNAL);
        break;
    }
    case Commands::AddTrustedRootCertificate::Id: {
        Commands::AddTrustedRootCertificate::DecodableType data;
        ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
        VerifyOrReturnError(emberAfOperationalCredentialsClusterAddTrustedRootCertificateCallback(handler, path, data),
                            CHIP_ERROR_INTERNAL);
        break;
    }
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    return CHIP_NO_ERROR;
}

} // namespace OperationalCredentials

} // namespace Clusters

void DispatchSingleClusterCommand(const ConcreteCommandPath & aCommandPath, TLV::TLVReader & aReader, CommandHandler * apCommandObj)
{
    Compatibility::SetupEmberAfCommandHandler(apCommandObj, aCommandPath);

    CHIP_ERROR err = CHIP_NO_ERROR;
    switch (aCommandPath.mClusterId)
    {
    case Clusters::AdministratorCommissioning::Id:
        err = Clusters::AdministratorCommissioning::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::DiagnosticLogs::Id:
        err = Clusters::DiagnosticLogs::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::EthernetNetworkDiagnostics::Id:
        err = Clusters::EthernetNetworkDiagnostics::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::GeneralCommissioning::Id:
        err = Clusters::GeneralCommissioning::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::GeneralDiagnostics::Id:
        err = Clusters::GeneralDiagnostics::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::GroupKeyManagement::Id:
        err = Clusters::GroupKeyManagement::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::NetworkCommissioning::Id:
        err = Clusters::NetworkCommissioning::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    case Clusters::OperationalCredentials::Id:
        err = Clusters::OperationalCredentials::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    default:
        err = CHIP_IM_GLOBAL_STATUS(UnsupportedCluster);
        break;
    }
    MaybeDispatchServerError(apCommandObj, aCommandPath, err);

    Compatibility::ResetEmberAfObjects();
}

} // namespace app
} // namespace chip
