/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <commands/common/CommandInvoker.h>
#include <commands/tests/TestCommand.h>
#include <lib/core/Optional.h>
#include <lib/support/CHIPListUtils.h>
#include <system/SystemClock.h>

#include <math.h> // For INFINITY

class TestList : public Command
{
public:
    TestList() : Command("list"){};
    CHIP_ERROR Run() override
    {
        printf("Test_TC_BI_1_1\n");
        printf("Test_TC_BI_2_1\n");
        printf("Test_TC_BI_2_2\n");
        printf("Test_TC_BOOL_1_1\n");
        printf("Test_TC_BOOL_2_1\n");
        printf("Test_TC_BRAC_1_1\n");
        printf("Test_TC_CC_1_1\n");
        printf("Test_TC_CC_2_1\n");
        printf("Test_TC_CC_3_1\n");
        printf("Test_TC_CC_3_2\n");
        printf("Test_TC_CC_3_3\n");
        printf("Test_TC_CC_4_1\n");
        printf("Test_TC_CC_4_2\n");
        printf("Test_TC_CC_4_3\n");
        printf("Test_TC_CC_4_4\n");
        printf("Test_TC_CC_5_1\n");
        printf("Test_TC_CC_5_2\n");
        printf("Test_TC_CC_5_3\n");
        printf("Test_TC_CC_6_1\n");
        printf("Test_TC_CC_6_2\n");
        printf("Test_TC_CC_6_3\n");
        printf("Test_TC_CC_7_1\n");
        printf("Test_TC_CC_7_2\n");
        printf("Test_TC_CC_7_3\n");
        printf("Test_TC_CC_7_4\n");
        printf("Test_TC_CC_8_1\n");
        printf("Test_TC_CC_9_1\n");
        printf("Test_TC_CC_9_2\n");
        printf("Test_TC_CC_9_3\n");
        printf("Test_TC_DM_1_1\n");
        printf("Test_TC_DM_3_1\n");
        printf("Test_TC_DM_2_2\n");
        printf("Test_TC_EMR_1_1\n");
        printf("Test_TC_ETHDIAG_1_1\n");
        printf("Test_TC_ETHDIAG_2_1\n");
        printf("Test_TC_FLW_1_1\n");
        printf("Test_TC_FLW_2_1\n");
        printf("Test_TC_FLW_2_2\n");
        printf("Test_TC_ILL_1_1\n");
        printf("Test_TC_LVL_1_1\n");
        printf("Test_TC_LVL_2_1\n");
        printf("Test_TC_LVL_2_2\n");
        printf("Test_TC_LVL_3_1\n");
        printf("Test_TC_LVL_4_1\n");
        printf("Test_TC_LVL_5_1\n");
        printf("Test_TC_LVL_6_1\n");
        printf("Test_TC_MC_1_1\n");
        printf("Test_TC_MC_2_1\n");
        printf("Test_TC_MC_3_1\n");
        printf("Test_TC_MC_3_2\n");
        printf("Test_TC_MC_3_3\n");
        printf("Test_TC_MC_3_4\n");
        printf("Test_TC_MC_3_5\n");
        printf("Test_TC_MC_3_6\n");
        printf("Test_TC_MC_3_7\n");
        printf("Test_TC_MC_3_8\n");
        printf("Test_TC_MC_3_9\n");
        printf("Test_TC_MC_3_10\n");
        printf("Test_TC_MC_3_11\n");
        printf("Test_TC_MC_5_1\n");
        printf("Test_TC_MC_5_2\n");
        printf("Test_TC_MC_5_3\n");
        printf("Test_TC_MC_6_1\n");
        printf("Test_TC_MC_6_2\n");
        printf("Test_TC_MC_6_3\n");
        printf("Test_TC_MC_6_4\n");
        printf("Test_TC_MC_7_1\n");
        printf("Test_TC_MC_7_2\n");
        printf("Test_TC_MC_8_1\n");
        printf("Test_TC_MC_9_1\n");
        printf("Test_TC_OCC_1_1\n");
        printf("Test_TC_OCC_2_1\n");
        printf("Test_TC_OCC_2_2\n");
        printf("Test_TC_OO_1_1\n");
        printf("Test_TC_OO_2_1\n");
        printf("Test_TC_OO_2_2\n");
        printf("Test_TC_OO_2_3\n");
        printf("Test_TC_PS_1_1\n");
        printf("Test_TC_PRS_1_1\n");
        printf("Test_TC_PRS_2_1\n");
        printf("Test_TC_PCC_1_1\n");
        printf("Test_TC_PCC_2_1\n");
        printf("Test_TC_PCC_2_2\n");
        printf("Test_TC_PCC_2_3\n");
        printf("Test_TC_RH_1_1\n");
        printf("Test_TC_RH_2_1\n");
        printf("Test_TC_RH_2_2\n");
        printf("Test_TC_SWTCH_2_1\n");
        printf("Test_TC_SWTCH_2_2\n");
        printf("Test_TC_TM_1_1\n");
        printf("Test_TC_TM_2_1\n");
        printf("Test_TC_TM_2_2\n");
        printf("Test_TC_TSTAT_1_1\n");
        printf("Test_TC_TSTAT_2_1\n");
        printf("Test_TC_TSTAT_2_2\n");
        printf("Test_TC_TSUIC_1_1\n");
        printf("Test_TC_TSUIC_2_1\n");
        printf("Test_TC_TSUIC_2_2\n");
        printf("Test_TC_DIAG_TH_NW_1_1\n");
        printf("Test_TC_WIFIDIAG_1_1\n");
        printf("Test_TC_WIFIDIAG_3_1\n");
        printf("Test_TC_WNCV_1_1\n");
        printf("Test_TC_WNCV_2_1\n");
        printf("Test_TC_WNCV_2_2\n");
        printf("Test_TC_WNCV_2_4\n");
        printf("Test_TC_WNCV_2_5\n");
        printf("Test_TC_WNCV_3_1\n");
        printf("Test_TC_WNCV_3_2\n");
        printf("Test_TC_WNCV_3_3\n");
        printf("Test_TC_WNCV_3_4\n");
        printf("Test_TC_WNCV_3_5\n");
        printf("Test_TC_WNCV_4_3\n");
        printf("Test_TC_WNCV_4_4\n");
        printf("TV_TargetNavigatorCluster\n");
        printf("TV_AudioOutputCluster\n");
        printf("TV_ApplicationLauncherCluster\n");
        printf("TV_KeypadInputCluster\n");
        printf("TV_AccountLoginCluster\n");
        printf("TV_WakeOnLanCluster\n");
        printf("TV_ApplicationBasicCluster\n");
        printf("TV_MediaPlaybackCluster\n");
        printf("TV_ChannelCluster\n");
        printf("TV_LowPowerCluster\n");
        printf("TV_ContentLauncherCluster\n");
        printf("TV_MediaInputCluster\n");
        printf("TestCluster\n");
        printf("TestClusterComplexTypes\n");
        printf("TestConstraints\n");
        printf("TestDelayCommands\n");
        printf("TestLogCommands\n");
        printf("TestSaveAs\n");
        printf("TestConfigVariables\n");
        printf("TestDescriptorCluster\n");
        printf("TestBasicInformation\n");
        printf("TestIdentifyCluster\n");
        printf("TestOperationalCredentialsCluster\n");
        printf("TestModeSelectCluster\n");
        printf("TestSystemCommands\n");
        printf("Test_TC_SWDIAG_1_1\n");
        printf("Test_TC_SWDIAG_2_1\n");
        printf("Test_TC_SWDIAG_3_1\n");
        printf("TestSubscribe_OnOff\n");
        printf("DL_UsersAndCredentials\n");
        printf("DL_LockUnlock\n");
        printf("DL_Schedules\n");
        printf("TestGroupMessaging\n");
        printf("TestGroupsCluster\n");
        printf("TestGroupKeyManagementCluster\n");

        return CHIP_NO_ERROR;
    }
};

class ManualTestList : public Command
{
public:
    ManualTestList() : Command("list-manual"){};
    CHIP_ERROR Run() override
    {
        printf("TestDiscovery\n");
        printf("Test_TC_DD_1_5\n");
        printf("Test_TC_DD_1_6\n");
        printf("Test_TC_DD_1_7\n");
        printf("Test_TC_DD_1_8\n");
        printf("Test_TC_DD_1_9\n");
        printf("Test_TC_DD_1_10\n");
        printf("Test_TC_DD_2_1\n");
        printf("Test_TC_DD_2_2\n");
        printf("Test_TC_DD_3_1\n");
        printf("Test_TC_DD_3_2\n");
        printf("Test_TC_DD_3_5\n");
        printf("Test_TC_DD_3_6\n");
        printf("Test_TC_DD_3_9\n");
        printf("Test_TC_DD_3_10\n");
        printf("Test_TC_DD_4_1\n");
        printf("TestGroupDemoCommand\n");
        printf("TestGroupDemoConfig\n");
        printf("Test_TC_BDX_1_1\n");
        printf("Test_TC_BDX_1_2\n");
        printf("Test_TC_BDX_1_3\n");
        printf("Test_TC_BDX_1_5\n");
        printf("Test_TC_BDX_1_6\n");
        printf("Test_TC_BDX_2_1\n");
        printf("Test_TC_BDX_2_2\n");
        printf("Test_TC_BDX_2_3\n");
        printf("Test_TC_BDX_2_4\n");
        printf("Test_TC_BDX_2_5\n");
        printf("Test_TC_BR_1\n");
        printf("Test_TC_BR_2\n");
        printf("Test_TC_BR_3\n");
        printf("Test_TC_BRAC_2_1\n");
        printf("Test_TC_BRAC_2_2\n");
        printf("Test_TC_DM_1_2\n");
        printf("Test_TC_DM_2_3\n");
        printf("Test_TC_DM_3_2\n");
        printf("Test_TC_DIAG_LOG_1_1\n");
        printf("Test_TC_DIAG_LOG_1_2\n");
        printf("Test_TC_DIAG_LOG_1_3\n");
        printf("Test_TC_DESC_1_1\n");
        printf("Test_TC_ETHDIAG_1_2\n");
        printf("Test_TC_GC_1_1\n");
        printf("Test_TC_GC_1_2\n");
        printf("Test_TC_GC_1_3\n");
        printf("Test_TC_GENDIAG_1_1\n");
        printf("Test_TC_GENDIAG_1_2\n");
        printf("Test_TC_I_1_1\n");
        printf("Test_TC_I_2_1\n");
        printf("Test_TC_I_2_2\n");
        printf("Test_TC_I_2_3\n");
        printf("Test_TC_ILL_2_1\n");
        printf("Test_TC_IDM_1_1\n");
        printf("Test_TC_IDM_1_2\n");
        printf("Test_TC_IDM_2_1\n");
        printf("Test_TC_IDM_2_2\n");
        printf("Test_TC_IDM_3_1\n");
        printf("Test_TC_IDM_3_2\n");
        printf("Test_TC_IDM_4_1\n");
        printf("Test_TC_IDM_4_2\n");
        printf("Test_TC_IDM_5_1\n");
        printf("Test_TC_IDM_5_2\n");
        printf("Test_TC_IDM_6_1\n");
        printf("Test_TC_IDM_6_2\n");
        printf("Test_TC_MC_3_12\n");
        printf("Test_TC_MC_4_1\n");
        printf("Test_TC_MC_8_2\n");
        printf("Test_TC_MC_9_2\n");
        printf("Test_TC_MC_10_1\n");
        printf("Test_TC_MC_10_2\n");
        printf("Test_TC_MC_10_3\n");
        printf("Test_TC_MC_10_4\n");
        printf("Test_TC_MC_10_5\n");
        printf("Test_TC_MC_10_6\n");
        printf("Test_TC_MF_1_1\n");
        printf("Test_TC_MF_1_2\n");
        printf("Test_TC_MF_1_3\n");
        printf("Test_TC_MF_1_4\n");
        printf("Test_TC_MF_1_5\n");
        printf("Test_TC_MF_1_6\n");
        printf("Test_TC_MF_1_7\n");
        printf("Test_TC_MF_1_8\n");
        printf("Test_TC_MF_1_9\n");
        printf("Test_TC_MF_1_10\n");
        printf("Test_TC_MF_1_11\n");
        printf("Test_TC_MF_1_12\n");
        printf("Test_TC_MF_1_13\n");
        printf("Test_TC_MF_1_14\n");
        printf("Test_TC_MF_1_15\n");
        printf("Test_TC_MF_1_16\n");
        printf("Test_TC_MF_1_17\n");
        printf("Test_TC_MF_1_18\n");
        printf("Test_TC_MF_1_19\n");
        printf("Test_TC_MF_1_20\n");
        printf("Test_TC_MF_1_21\n");
        printf("Test_TC_MF_1_22\n");
        printf("Test_TC_MF_1_23\n");
        printf("Test_TC_MF_1_24\n");
        printf("Test_TC_MOD_1_1\n");
        printf("Test_TC_MOD_1_2\n");
        printf("Test_TC_MOD_2_1\n");
        printf("Test_TC_SU_1_1\n");
        printf("Test_TC_SU_2_1\n");
        printf("Test_TC_SU_2_2\n");
        printf("Test_TC_SU_2_3\n");
        printf("Test_TC_SU_2_4\n");
        printf("Test_TC_SU_2_5\n");
        printf("Test_TC_SU_2_6\n");
        printf("Test_TC_SU_2_7\n");
        printf("Test_TC_SU_3_1\n");
        printf("Test_TC_SU_3_2\n");
        printf("Test_TC_SU_3_3\n");
        printf("Test_TC_SU_3_4\n");
        printf("Test_TC_PSCFG_1_1\n");
        printf("Test_TC_PSCFG_2_1\n");
        printf("Test_TC_SC_4_5\n");
        printf("Test_TC_SC_4_6\n");
        printf("Test_TC_SC_4_7\n");
        printf("Test_TC_SC_4_8\n");
        printf("Test_TC_SC_4_9\n");
        printf("Test_TC_SWDIAG_1_2\n");
        printf("Test_TC_WIFIDIAG_1_2\n");
        printf("Test_TC_WIFIDIAG_2_1\n");
        printf("Test_TC_WNCV_2_3\n");

        return CHIP_NO_ERROR;
    }
};

class Test_TC_BI_1_1Suite : public TestCommand
{
public:
    Test_TC_BI_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BI_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BI_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::ClusterRevision::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                  BinaryInputBasic::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::ClusterRevision::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BI_2_1Suite : public TestCommand
{
public:
    Test_TC_BI_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BI_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BI_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute: OutOfService\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read mandatory non-global attribute constraints: OutOfService\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Write the default values to mandatory non-global attribute: OutOfService\n");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                  BinaryInputBasic::Attributes::OutOfService::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back the mandatory non-global attribute: OutOfService\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read mandatory non-global attribute constraints: PresentValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::PresentValue::Id);
        }
        case 6: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Write the default values to mandatory non-global attribute: PresentValue\n");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                  BinaryInputBasic::Attributes::PresentValue::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads back the mandatory non-global attribute: PresentValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::PresentValue::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read mandatory non-global attribute: StatusFlags\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read mandatory non-global attribute constraints: StatusFlags\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 10: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Write the default values to mandatory non-global attribute: StatusFlags\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                  BinaryInputBasic::Attributes::StatusFlags::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads back the mandatory non-global attribute: StatusFlags\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("outOfService", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("outOfService", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("presentValue", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 15));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BI_2_2Suite : public TestCommand
{
public:
    Test_TC_BI_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BI_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BI_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads PresentValue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_PRESENTVALUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::PresentValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads OutOfService attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OUTOFSERVICE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads StatusFlags attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_STATUSFLAGS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads PresentValue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_PRESENTVALUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::PresentValue::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads OutOfService attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OUTOFSERVICE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads StatusFlags attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_STATUSFLAGS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads StatusFlags attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_STATUSFLAGS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads StatusFlags attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_STATUSFLAGS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("presentValue", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("outOfService", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("presentValue", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("outOfService", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BOOL_1_1Suite : public TestCommand
{
public:
    Test_TC_BOOL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BOOL_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BOOL_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::ClusterRevision::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::ClusterRevision::Id,
                                  value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::ClusterRevision::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BOOL_2_1Suite : public TestCommand
{
public:
    Test_TC_BOOL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BOOL_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BOOL_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute: StateValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::StateValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read mandatory non-global attribute constraints: StateValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::StateValue::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Write the default value to mandatory non-global attribute: StateValue\n");
            bool value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::StateValue::Id,
                                  value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back the mandatory non-global attribute: StateValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::StateValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("stateValue", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("stateValue", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BRAC_1_1Suite : public TestCommand
{
public:
    Test_TC_BRAC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BRAC_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BRAC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BRAC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BRAC_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BridgedActions::Id,
                                 BridgedActions::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BridgedActions::Id,
                                 BridgedActions::Attributes::ClusterRevision::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_1_1Suite : public TestCommand
{
public:
    Test_TC_CC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints : ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 4U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ClusterRevision::Id,
                                  value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_2_1Suite : public TestCommand
{
public:
    Test_TC_CC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 154;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads mandatory attribute: CurrentHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Validate constraints of attribute: current hue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write the default value to mandatory attribute: CurrentHue\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id,
                                  value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back mandatory attribute: CurrentHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads mandatory attribute: CurrentSaturation\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Validate constraints of attribute: CurrentSaturation\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write the default value to mandatory attribute: CurrentSaturation\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id,
                                  value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads back mandatory attribute: CurrentSaturation\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read the mandatory attribute: CurrentX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentX::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Validate constraints of attribute: CurrentX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentX::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write the default value to mandatory attribute: CurrentX\n");
            uint16_t value;
            value = 24939U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentX::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads back mandatory attribute: CurrentX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentX::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read the mandatory attribute: CurrentY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentY::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Validate constraints of attribute: CurrentY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentY::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write the default values to mandatory attribute: CurrentY\n");
            uint16_t value;
            value = 24701U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentY::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads back mandatory attribute: CurrentY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentY::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Validate constraints of attribute: ColorTemperatureMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperature::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Validate constraints of attribute: ColorMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorMode::Id);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read the mandatory attribute: Options\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorControlOptions::Id);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Validate constraints of attribute: Options\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorControlOptions::Id);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write the default values to mandatory attribute: Options\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorControlOptions::Id, value);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads back mandatory attribute: Options\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorControlOptions::Id);
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read the mandatory attribute: EnhancedCurrentHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : Validate constraints of attribute: EnhancedCurrentHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 25: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : Write the default values to mandatory attribute: EnhancedCurrentHue\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::EnhancedCurrentHue::Id, value);
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads back mandatory attribute: EnhancedCurrentHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : Validate constraints of attribute: EnhancedColorMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedColorMode::Id);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read the mandatory attribute: ColorLoopActive\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : Validate constraints of attribute: ColorLoopActive\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : Write the default values to mandatory attribute: ColorLoopActive\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id,
                                  value);
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads back mandatory attribute: ColorLoopActive\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read the mandatory attribute: ColorLoopDirection\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : Validate constraints of attribute: ColorLoopDirection\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 34: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 34 : Write the default values to mandatory attribute: ColorLoopDirection\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorLoopDirection::Id, value);
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads back mandatory attribute: ColorLoopDirection\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read the mandatory attribute: ColorLoopTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : Validate constraints of attribute: ColorLoopTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : Write the default values to mandatory attribute: ColorLoopTime\n");
            uint16_t value;
            value = 25U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id,
                                  value);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads back mandatory attribute: ColorLoopTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read the mandatory attribute: ColorLoopStartEnhancedHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Validate constraints of attribute: ColorLoopStartEnhancedHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 42: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 42 : Write the default values to mandatory attribute: ColorLoopStartEnhancedHue\n");
            uint16_t value;
            value = 8960U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorLoopStartEnhancedHue::Id, value);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads back mandatory attribute: ColorLoopStartEnhancedHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read the mandatory attribute: ColorLoopStoredEnhancedHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : Validate constraints of attribute: ColorLoopStoredEnhancedHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 46: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 46 : Write the default values to mandatory attribute: ColorLoopStoredEnhancedHue\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id, value);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : Reads back mandatory attribute: ColorLoopStoredEnhancedHue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read the mandatory attribute: ColorCapabilities\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorCapabilities::Id);
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : Validate constraints of attribute: ColorCapabilities\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorCapabilities::Id);
        }
        case 50: {
            ChipLogProgress(chipTool, " ***** Test Step 50 : Write the default values to mandatory attribute: ColorCapabilities\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorCapabilities::Id,
                                  value);
        }
        case 51: {
            ChipLogProgress(chipTool, " ***** Test Step 51 : Reads back mandatory attribute: ColorCapabilities\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorCapabilities::Id);
        }
        case 52: {
            ChipLogProgress(chipTool, " ***** Test Step 52 : Read the mandatory attribute: ColorTempPhysicalMinMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMin::Id);
        }
        case 53: {
            ChipLogProgress(chipTool, " ***** Test Step 53 : Validate constraints of attribute: ColorTempPhysicalMinMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMin::Id);
        }
        case 54: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 54 : Write the default values to mandatory  attribute: ColorTempPhysicalMinMireds\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorTempPhysicalMin::Id, value);
        }
        case 55: {
            ChipLogProgress(chipTool, " ***** Test Step 55 : Reads back mandatory attribute: ColorTempPhysicalMinMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMin::Id);
        }
        case 56: {
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read the mandatory attribute: ColorTempPhysicalMaxMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMax::Id);
        }
        case 57: {
            ChipLogProgress(chipTool, " ***** Test Step 57 : Validate constraints of attribute: ColorTempPhysicalMaxMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMax::Id);
        }
        case 58: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 58 : Write the default values to mandatory attribute: ColorTempPhysicalMaxMireds\n");
            uint16_t value;
            value = 65279U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorTempPhysicalMax::Id, value);
        }
        case 59: {
            ChipLogProgress(chipTool, " ***** Test Step 59 : Reads back mandatory attribute: ColorTempPhysicalMaxMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMax::Id);
        }
        case 60: {
            ChipLogProgress(chipTool, " ***** Test Step 60 : Read the optional attribute: CoupleColorTempToLevelMinMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Id);
        }
        case 61: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 61 : Write the default values to optional attribute: CoupleColorTempToLevelMinMireds\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Id, value);
        }
        case 62: {
            ChipLogProgress(chipTool, " ***** Test Step 62 : Reads back optional attribute: CoupleColorTempToLevelMinMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Id);
        }
        case 63: {
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read the optional attribute: StartUpColorTemperatureMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::StartUpColorTemperatureMireds::Id);
        }
        case 64: {
            ChipLogProgress(
                chipTool, " ***** Test Step 64 : Write the default values to optional attribute: StartUpColorTemperatureMireds\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::StartUpColorTemperatureMireds::Id, value);
        }
        case 65: {
            ChipLogProgress(chipTool, " ***** Test Step 65 : Reads back optional attribute: StartUpColorTemperatureMireds\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::StartUpColorTemperatureMireds::Id);
        }
        case 66: {
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read the Optional attribute: RemainingTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::RemainingTime::Id);
        }
        case 67: {
            ChipLogProgress(chipTool, " ***** Test Step 67 : Validate constraints of attribute: RemainingTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::RemainingTime::Id);
        }
        case 68: {
            ChipLogProgress(chipTool, " ***** Test Step 68 : Write the default values to optional attribute: RemainingTime\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::RemainingTime::Id,
                                  value);
        }
        case 69: {
            ChipLogProgress(chipTool, " ***** Test Step 69 : Reads back optional attribute: RemainingTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::RemainingTime::Id);
        }
        case 70: {
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read the optional attribute: DriftCompensation\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::DriftCompensation::Id);
        }
        case 71: {
            ChipLogProgress(chipTool, " ***** Test Step 71 : Write the default values to optional attribute: DriftCompensation\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::DriftCompensation::Id,
                                  value);
        }
        case 72: {
            ChipLogProgress(chipTool, " ***** Test Step 72 : Reads back optional attribute: DriftCompensation\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::DriftCompensation::Id);
        }
        case 73: {
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read the optional attribute: CompensationText\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CompensationText::Id);
        }
        case 74: {
            ChipLogProgress(chipTool, " ***** Test Step 74 : Write the default values to optional attribute: CompensationText\n");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CompensationText::Id,
                                  value);
        }
        case 75: {
            ChipLogProgress(chipTool, " ***** Test Step 75 : Reads back optional attribute: CompensationText\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CompensationText::Id);
        }
        case 76: {
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read the mandatory attribute: NumberOfPrimaries\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::NumberOfPrimaries::Id);
        }
        case 77: {
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write the default mandatory attribute: NumberOfPrimaries\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::NumberOfPrimaries::Id,
                                  value);
        }
        case 78: {
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read back the mandatory attribute: NumberOfPrimaries\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::NumberOfPrimaries::Id);
        }
        case 79: {
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read the mandatory attribute: Primary1X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1X::Id);
        }
        case 80: {
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write the default mandatory attribute: Primary1X\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1X::Id, value);
        }
        case 81: {
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read back the mandatory attribute: Primary1X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1X::Id);
        }
        case 82: {
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read the mandatory attribute: Primary1Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1Y::Id);
        }
        case 83: {
            ChipLogProgress(chipTool, " ***** Test Step 83 : Write the default mandatory attribute: Primary1Y\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1Y::Id, value);
        }
        case 84: {
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read back the mandatory attribute: Primary1Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1Y::Id);
        }
        case 85: {
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read the mandatory attribute: Primary1Intensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1Intensity::Id);
        }
        case 86: {
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read the mandatory attribute: Primary2X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2X::Id);
        }
        case 87: {
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write the default mandatory attribute: Primary2X\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2X::Id, value);
        }
        case 88: {
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read back the mandatory attribute: Primary2X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2X::Id);
        }
        case 89: {
            ChipLogProgress(chipTool, " ***** Test Step 89 : Read the mandatory attribute: Primary2Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2Y::Id);
        }
        case 90: {
            ChipLogProgress(chipTool, " ***** Test Step 90 : Write the default mandatory attribute: Primary2Y\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2Y::Id, value);
        }
        case 91: {
            ChipLogProgress(chipTool, " ***** Test Step 91 : Read back the mandatory attribute: Primary2Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2Y::Id);
        }
        case 92: {
            ChipLogProgress(chipTool, " ***** Test Step 92 : Validate constraints of attribute: Primary2Intensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2Intensity::Id);
        }
        case 93: {
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read the mandatory attribute: Primary3X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3X::Id);
        }
        case 94: {
            ChipLogProgress(chipTool, " ***** Test Step 94 : Write the default mandatory attribute: Primary3X\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3X::Id, value);
        }
        case 95: {
            ChipLogProgress(chipTool, " ***** Test Step 95 : Read back the mandatory attribute: Primary3X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3X::Id);
        }
        case 96: {
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read the mandatory attribute: Primary3Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3Y::Id);
        }
        case 97: {
            ChipLogProgress(chipTool, " ***** Test Step 97 : Write the default mandatory attribute: Primary3Y\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3Y::Id, value);
        }
        case 98: {
            ChipLogProgress(chipTool, " ***** Test Step 98 : Read back the mandatory attribute: Primary3Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3Y::Id);
        }
        case 99: {
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read the mandatory attribute: Primary3Intensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3Intensity::Id);
        }
        case 100: {
            ChipLogProgress(chipTool, " ***** Test Step 100 : Read the mandatory attribute: Primary4X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4X::Id);
        }
        case 101: {
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write the default mandatory attribute: Primary4X\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4X::Id, value);
        }
        case 102: {
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read back the mandatory attribute: Primary4X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4X::Id);
        }
        case 103: {
            ChipLogProgress(chipTool, " ***** Test Step 103 : Read the mandatory attribute: Primary4Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4Y::Id);
        }
        case 104: {
            ChipLogProgress(chipTool, " ***** Test Step 104 : Write the default mandatory attribute: Primary4Y\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4Y::Id, value);
        }
        case 105: {
            ChipLogProgress(chipTool, " ***** Test Step 105 : Read back the mandatory attribute: Primary4Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4Y::Id);
        }
        case 106: {
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read the mandatory attribute: Primary4Intensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4Intensity::Id);
        }
        case 107: {
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read the mandatory attribute: Primary5X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5X::Id);
        }
        case 108: {
            ChipLogProgress(chipTool, " ***** Test Step 108 : Write the default mandatory attribute: Primary5X\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5X::Id, value);
        }
        case 109: {
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read back the mandatory attribute: Primary5X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5X::Id);
        }
        case 110: {
            ChipLogProgress(chipTool, " ***** Test Step 110 : Read the mandatory attribute: Primary5Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5Y::Id);
        }
        case 111: {
            ChipLogProgress(chipTool, " ***** Test Step 111 : Write the default mandatory attribute: Primary5Y\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5Y::Id, value);
        }
        case 112: {
            ChipLogProgress(chipTool, " ***** Test Step 112 : Read back the mandatory attribute: Primary5Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5Y::Id);
        }
        case 113: {
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read the mandatory attribute: Primary5Intensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5Intensity::Id);
        }
        case 114: {
            ChipLogProgress(chipTool, " ***** Test Step 114 : Read the mandatory attribute: Primary6X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6X::Id);
        }
        case 115: {
            ChipLogProgress(chipTool, " ***** Test Step 115 : Write the default mandatory attribute: Primary6X\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6X::Id, value);
        }
        case 116: {
            ChipLogProgress(chipTool, " ***** Test Step 116 : Read back the mandatory attribute: Primary6X\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6X::Id);
        }
        case 117: {
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read the mandatory attribute: Primary6Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6Y::Id);
        }
        case 118: {
            ChipLogProgress(chipTool, " ***** Test Step 118 : Write the default mandatory attribute: Primary6Y\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6Y::Id, value);
        }
        case 119: {
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read back the mandatory attribute: Primary6Y\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6Y::Id);
        }
        case 120: {
            ChipLogProgress(chipTool, " ***** Test Step 120 : Read the mandatory attribute: Primary6Intensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6Intensity::Id);
        }
        case 121: {
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read the optional attribute: WhitePointX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointX::Id);
        }
        case 122: {
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write the default optional attribute: WhitePointX\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointX::Id,
                                  value);
        }
        case 123: {
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read back the optional attribute: WhitePointX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointX::Id);
        }
        case 124: {
            ChipLogProgress(chipTool, " ***** Test Step 124 : Read the optional attribute: WhitePointY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointY::Id);
        }
        case 125: {
            ChipLogProgress(chipTool, " ***** Test Step 125 : Write the default optional attribute: WhitePointY\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointY::Id,
                                  value);
        }
        case 126: {
            ChipLogProgress(chipTool, " ***** Test Step 126 : Read back the optional attribute: WhitePointY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointY::Id);
        }
        case 127: {
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read the optional attribute: ColorPointRX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRX::Id);
        }
        case 128: {
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write the default optional attribute: ColorPointRX\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRX::Id,
                                  value);
        }
        case 129: {
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read back the optional attribute: ColorPointRX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRX::Id);
        }
        case 130: {
            ChipLogProgress(chipTool, " ***** Test Step 130 : Read the optional attribute: ColorPointRY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRY::Id);
        }
        case 131: {
            ChipLogProgress(chipTool, " ***** Test Step 131 : Write the default optional attribute: ColorPointRY\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRY::Id,
                                  value);
        }
        case 132: {
            ChipLogProgress(chipTool, " ***** Test Step 132 : Read back the optional attribute: ColorPointRY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRY::Id);
        }
        case 133: {
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read the optional attribute: ColorPointRIntensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointRIntensity::Id);
        }
        case 134: {
            ChipLogProgress(chipTool, " ***** Test Step 134 : Write the default optional attribute: ColorPointRIntensity\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorPointRIntensity::Id, value);
        }
        case 135: {
            ChipLogProgress(chipTool, " ***** Test Step 135 : Read back the optional attribute: ColorPointRIntensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointRIntensity::Id);
        }
        case 136: {
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read the optional attribute: ColorPointGX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGX::Id);
        }
        case 137: {
            ChipLogProgress(chipTool, " ***** Test Step 137 : Write the default optional attribute: ColorPointGX\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGX::Id,
                                  value);
        }
        case 138: {
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read back the optional attribute: ColorPointGX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGX::Id);
        }
        case 139: {
            ChipLogProgress(chipTool, " ***** Test Step 139 : Read the optional attribute: ColorPointGY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGY::Id);
        }
        case 140: {
            ChipLogProgress(chipTool, " ***** Test Step 140 : Write the default optional attribute: ColorPointGY\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGY::Id,
                                  value);
        }
        case 141: {
            ChipLogProgress(chipTool, " ***** Test Step 141 : Read back the optional attribute: ColorPointGY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGY::Id);
        }
        case 142: {
            ChipLogProgress(chipTool, " ***** Test Step 142 : Read the optional attribute: ColorPointGIntensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointGIntensity::Id);
        }
        case 143: {
            ChipLogProgress(chipTool, " ***** Test Step 143 : Write the default optional attribute: ColorPointGIntensity\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorPointGIntensity::Id, value);
        }
        case 144: {
            ChipLogProgress(chipTool, " ***** Test Step 144 : Read back the optional attribute: ColorPointGIntensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointGIntensity::Id);
        }
        case 145: {
            ChipLogProgress(chipTool, " ***** Test Step 145 : Read the optional attribute: ColorPointBX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBX::Id);
        }
        case 146: {
            ChipLogProgress(chipTool, " ***** Test Step 146 : Write the default optional attribute: ColorPointBX\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBX::Id,
                                  value);
        }
        case 147: {
            ChipLogProgress(chipTool, " ***** Test Step 147 : Read back the optional attribute: ColorPointBX\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBX::Id);
        }
        case 148: {
            ChipLogProgress(chipTool, " ***** Test Step 148 : Read the optional attribute: ColorPointBY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBY::Id);
        }
        case 149: {
            ChipLogProgress(chipTool, " ***** Test Step 149 : Write the default optional attribute: ColorPointBY\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBY::Id,
                                  value);
        }
        case 150: {
            ChipLogProgress(chipTool, " ***** Test Step 150 : Read back the optional attribute: ColorPointBY\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBY::Id);
        }
        case 151: {
            ChipLogProgress(chipTool, " ***** Test Step 151 : Read the optional attribute: ColorPointBIntensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointBIntensity::Id);
        }
        case 152: {
            ChipLogProgress(chipTool, " ***** Test Step 152 : Write the default optional attribute: ColorPointBIntensity\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorPointBIntensity::Id, value);
        }
        case 153: {
            ChipLogProgress(chipTool, " ***** Test Step 153 : Read back the optional attribute: ColorPointBIntensity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointBIntensity::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentHue", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 254));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentHue", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentSaturation", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 254));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentSaturation", value, 0));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentX", value, 24939U));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentX", value, 24939U));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentY", value, 24701U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentY", value, 24701U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 2));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorControlOptions", value, 0));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorControlOptions", value, 0));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, 0U));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, 0U));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 25U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 25U));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 8960U));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 8960U));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, 0U));
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, 0U));
            }
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorCapabilities", value, 0U));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorCapabilities", value, 0U));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorTempPhysicalMin", value, 0U));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorTempPhysicalMin", value, 0U));
            }
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorTempPhysicalMax", value, 65279U));
            }
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorTempPhysicalMax", value, 65279U));
            }
            break;
        case 60:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 62:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("coupleColorTempToLevelMinMireds", value, 0U));
            }
            break;
        case 63:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 64:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 65:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("startUpColorTemperatureMireds", value, 0U));
            }
            break;
        case 66:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("remainingTime", value, 0U));
            }
            break;
        case 67:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 254U));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 69:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("remainingTime", value, 0U));
            }
            break;
        case 70:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 4));
            }
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 72:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("driftCompensation", value, 0));
            }
            break;
        case 73:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 254));
            }
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 75:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("compensationText", value, chip::CharSpan("", 0)));
            }
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 6));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfPrimaries", value, 0));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary1X", value, 0U));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary1Y", value, 0U));
            }
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary2X", value, 0U));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary2Y", value, 0U));
            }
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary3X", value, 0U));
            }
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary3Y", value, 0U));
            }
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 102:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary4X", value, 0U));
            }
            break;
        case 103:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 104:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 105:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary4Y", value, 0U));
            }
            break;
        case 106:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 107:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 108:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 109:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary5X", value, 0U));
            }
            break;
        case 110:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 111:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 112:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary5Y", value, 0U));
            }
            break;
        case 113:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 114:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 115:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 116:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary6X", value, 0U));
            }
            break;
        case 117:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 118:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 119:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("primary6Y", value, 0U));
            }
            break;
        case 120:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 121:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 122:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 123:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("whitePointX", value, 0U));
            }
            break;
        case 124:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 125:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 126:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("whitePointY", value, 0U));
            }
            break;
        case 127:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 128:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 129:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointRX", value, 0U));
            }
            break;
        case 130:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 131:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 132:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointRY", value, 0U));
            }
            break;
        case 133:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 134:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 135:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointRIntensity", value, 0));
            }
            break;
        case 136:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 137:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 138:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointGX", value, 0U));
            }
            break;
        case 139:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 140:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 141:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointGY", value, 0U));
            }
            break;
        case 142:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 143:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 144:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointGIntensity", value, 0));
            }
            break;
        case 145:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 146:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 147:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointBX", value, 0U));
            }
            break;
        case 148:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 149:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 150:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointBY", value, 0U));
            }
            break;
        case 151:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 152:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 153:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointBIntensity", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_3_1Suite : public TestCommand
{
public:
    Test_TC_CC_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHue attribute from DUT.\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move to hue shortest distance command\n");
            chip::app::Clusters::ColorControl::Commands::MoveToHue::Type value;
            value.hue             = 150;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move to hue longest distance command\n");
            chip::app::Clusters::ColorControl::Commands::MoveToHue::Type value;
            value.hue             = 200;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move to hue up command\n");
            chip::app::Clusters::ColorControl::Commands::MoveToHue::Type value;
            value.hue             = 250;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Move to hue down command\n");
            chip::app::Clusters::ColorControl::Commands::MoveToHue::Type value;
            value.hue             = 225;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 254));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_3_2Suite : public TestCommand
{
public:
    Test_TC_CC_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_3_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move hue up command\n");
            chip::app::Clusters::ColorControl::Commands::MoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
            value.rate            = 50;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move hue stop command\n");
            chip::app::Clusters::ColorControl::Commands::MoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate            = 50;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move hue down command\n");
            chip::app::Clusters::ColorControl::Commands::MoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
            value.rate            = 50;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move hue stop command\n");
            chip::app::Clusters::ColorControl::Commands::MoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate            = 50;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_3_3Suite : public TestCommand
{
public:
    Test_TC_CC_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_3_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_3_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step hue up command\n");
            chip::app::Clusters::ColorControl::Commands::StepHue::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
            value.stepSize        = 5;
            value.transitionTime  = 25;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepHue::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step hue down command\n");
            chip::app::Clusters::ColorControl::Commands::StepHue::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
            value.stepSize        = 5;
            value.transitionTime  = 25;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepHue::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_4_1Suite : public TestCommand
{
public:
    Test_TC_CC_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_4_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to saturation command\n");
            chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type value;
            value.saturation      = 90;
            value.transitionTime  = 10U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToSaturation::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_4_2Suite : public TestCommand
{
public:
    Test_TC_CC_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_4_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_4_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 11;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move saturation up command\n");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move saturation down command\n");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move saturation up command\n");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move saturation stop command\n");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(0);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Move saturation down command\n");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Move saturation stop command\n");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(0);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_4_3Suite : public TestCommand
{
public:
    Test_TC_CC_4_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_4_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_4_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step saturation up command\n");
            chip::app::Clusters::ColorControl::Commands::StepSaturation::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(1);
            value.stepSize        = 15;
            value.transitionTime  = 10;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepSaturation::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step saturation down command\n");
            chip::app::Clusters::ColorControl::Commands::StepSaturation::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(3);
            value.stepSize        = 20;
            value.transitionTime  = 10;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepSaturation::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_4_4Suite : public TestCommand
{
public:
    Test_TC_CC_4_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_4_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_4_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move To current hue and saturation command\n");
            chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type value;
            value.hue             = 40;
            value.saturation      = 160;
            value.transitionTime  = 10U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHueAndSaturation::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_5_1Suite : public TestCommand
{
public:
    Test_TC_CC_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_5_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_5_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to Color command\n");
            chip::app::Clusters::ColorControl::Commands::MoveToColor::Type value;
            value.colorX          = 200U;
            value.colorY          = 300U;
            value.transitionTime  = 20U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToColor::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_5_2Suite : public TestCommand
{
public:
    Test_TC_CC_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_5_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_5_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move Color command\n");
            chip::app::Clusters::ColorControl::Commands::MoveColor::Type value;
            value.rateX           = 15;
            value.rateY           = 20;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColor::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Stop Move Step command\n");
            chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type value;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StopMoveStep::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_5_3Suite : public TestCommand
{
public:
    Test_TC_CC_5_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_5_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_5_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step Color command\n");
            chip::app::Clusters::ColorControl::Commands::StepColor::Type value;
            value.stepX           = 15;
            value.stepY           = 20;
            value.transitionTime  = 50U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepColor::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_6_1Suite : public TestCommand
{
public:
    Test_TC_CC_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_6_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_6_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move To Color Temperature command\n");
            chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type value;
            value.colorTemperature = 100U;
            value.transitionTime   = 10U;
            value.optionsMask      = 0;
            value.optionsOverride  = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToColorTemperature::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_6_2Suite : public TestCommand
{
public:
    Test_TC_CC_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_6_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_6_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read current color temprature\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperature::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move up color temperature command\n");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
            value.rate                    = 10U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move down color temperature command\n");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
            value.rate                    = 20U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move up color temperature command\n");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
            value.rate                    = 10U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Stop Color Temperature command\n");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate                    = 10U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Move down color temperature command\n");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
            value.rate                    = 20U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Stop Color Temperature command\n");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate                    = 10U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65279U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_6_3Suite : public TestCommand
{
public:
    Test_TC_CC_6_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_6_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_6_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step up color temperature command\n");
            chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type value;
            value.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
            value.stepSize                = 5U;
            value.transitionTime          = 50U;
            value.colorTemperatureMinimum = 5U;
            value.colorTemperatureMaximum = 100U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepColorTemperature::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step down color temperature command\n");
            chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type value;
            value.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
            value.stepSize                = 5U;
            value.transitionTime          = 50U;
            value.colorTemperatureMinimum = 5U;
            value.colorTemperatureMaximum = 100U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepColorTemperature::Id,
                               value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_7_1Suite : public TestCommand
{
public:
    Test_TC_CC_7_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_7_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_7_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Move To Hue command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1025U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
            value.transitionTime  = 1U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move To Hue command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1100U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move To Hue command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1150U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Enhanced Move To Hue command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1200U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Enhanced Move To Hue command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1300U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_7_2Suite : public TestCommand
{
public:
    Test_TC_CC_7_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_7_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_7_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check EnhancedCurrentHue attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move Hue Up command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
            value.rate            = 50U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id,
                               value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move Hue Stop command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate            = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id,
                               value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Enhanced Move Hue Down command \n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
            value.rate            = 5U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id,
                               value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Enhanced Move Hue Stop command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate            = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id,
                               value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_7_3Suite : public TestCommand
{
public:
    Test_TC_CC_7_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_7_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_7_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Step Hue Up command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(0);
            value.stepSize        = 50U;
            value.transitionTime  = 1U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedStepHue::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Step Hue Down command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
            value.stepSize        = 75U;
            value.transitionTime  = 1U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedStepHue::Id,
                               value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_7_4Suite : public TestCommand
{
public:
    Test_TC_CC_7_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_7_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_7_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced move to hue and saturation command\n");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type value;
            value.enhancedHue     = 1200U;
            value.saturation      = 90;
            value.transitionTime  = 10U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                               ColorControl::Commands::EnhancedMoveToHueAndSaturation::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_8_1Suite : public TestCommand
{
public:
    Test_TC_CC_8_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_8_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_8_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_8_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_8_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Color Loop Set Command - Set all Attributes\n");
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(14);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 100U;
            value.startHue        = 500U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check ColorLoopDirection Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check ColorLoopTime Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check ColorLoopStartEnhancedHue Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check ColorLoopActive Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Start Color Loop\n");
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check ColorLoopActive Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Color Loop Set Command - Set direction and time while running\n");
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(6);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 3500U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check ColorLoopDirection Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Check ColorLoopTime Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Color Loop Set Command - Set direction while running\n");
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Check ColorLoopDirection Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Turn off light that we turned on\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 100U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 500U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 3500U));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_9_1Suite : public TestCommand
{
public:
    Test_TC_CC_9_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_9_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_9_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 54;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t EnhancedCurrentHueValue1;
    uint16_t ColorLoopStoredEnhancedHueValue1;
    uint16_t EnhancedCurrentHueValue2;
    uint16_t ColorLoopStoredEnhancedHueValue2;
    uint16_t EnhancedCurrentHueValue3;
    uint16_t ColorLoopStoredEnhancedHueValue3;
    uint16_t EnhancedCurrentHueValue4;
    uint16_t ColorLoopStoredEnhancedHue4;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition : Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopDirection attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 30U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read ColorLoopTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(8);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 160U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read ColorLoopStartEnhancedHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read ColorLoopDirection attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : Enhanced Move To Hue command\n");
            VerifyOrdo(!ShouldSkip("CR_ENHANCEDMOVETOHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 40960U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
            value.transitionTime  = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : Wait 2000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read ColorLoopDirection attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read ColorLoopDirection attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 50: {
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 51: {
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read EnhancedCurrentHue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 52: {
            ChipLogProgress(chipTool, " ***** Test Step 52 : Turn Off light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 53: {
            ChipLogProgress(chipTool, " ***** Test Step 53 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 30U));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 160U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue1 = value;
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue1));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue1 = value;
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue1));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue2 = value;
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue2));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue2 = value;
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue2));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, 40960U));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue3 = value;
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue3));
            }
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue3 = value;
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue3));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue4 = value;
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue4));
            }
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHue4 = value;
            }
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHue4));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_9_2Suite : public TestCommand
{
public:
    Test_TC_CC_9_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_9_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_9_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t EnhancedCurrentHueValue;
    uint16_t ColorLoopStoredEnhancedHueValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 30U;
            value.startHue        = 160U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopTime attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopActive attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read EnhancedCurrentHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Start Color Loop\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopDirection attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Color Loop Set Command - Start Color Loop\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read EnhancedCurrentHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Turn off light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 30U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 160U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue = value;
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue = value;
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_CC_9_3Suite : public TestCommand
{
public:
    Test_TC_CC_9_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_9_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_9_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t EnhancedCurrentHueValue;
    uint16_t ColorLoopStoredEnhancedHueValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Turn on light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 30U;
            value.startHue        = 160U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopTime attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Set all Attributes\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopActive attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read EnhancedCurrentHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Start Color Loop\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 60U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopTime attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Color Loop Set Command - Start Color Loop\n");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read ColorLoopActive attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read EnhancedCurrentHue attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Turn off light for color control tests\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 30U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 160U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue = value;
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 60U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue = value;
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DM_1_1Suite : public TestCommand
{
public:
    Test_TC_DM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Data Model Revision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::DataModelRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Vendor Name\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::VendorName::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query VendorID\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::VendorID::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query Product Name\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ProductName::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Query ProductID\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ProductID::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Query Node Label\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Query User Location\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Query HardwareVersion\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::HardwareVersion::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Query HardwareVersionString\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::HardwareVersionString::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Query SoftwareVersion\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::SoftwareVersion::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Query SoftwareVersionString\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::SoftwareVersionString::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Query ManufacturingDate\n");
            VerifyOrdo(!ShouldSkip("MANF_DATE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ManufacturingDate::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Query PartNumber\n");
            VerifyOrdo(!ShouldSkip("PART_NUM"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::PartNumber::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Query ProductURL\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ProductURL::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Query ProductLabel\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ProductLabel::Id);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Query SerialNumber\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::SerialNumber::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Query LocalConfigDisabled\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::LocalConfigDisabled::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Query Reachable\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Reachable::Id);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Query UniqueID\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::UniqueID::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintFormat("value", "", "ISO 3166-1 alpha-2"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 2));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMinLength("value", value.size(), 1));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 64));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintFormat("value", "", "ASCII"));
                VerifyOrReturn(CheckConstraintMinLength("value", value.size(), 1));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 64));
            }
            break;
        case 12:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintFormat("value", "", "ISO 8601"));
                VerifyOrReturn(CheckConstraintMinLength("value", value.size(), 8));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 16));
            }
            break;
        case 13:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 14:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintFormat("value", "", "RFC3986"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 256));
            }
            break;
        case 15:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 64));
            }
            break;
        case 16:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 17:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "boolean"));
            }
            break;
        case 18:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "boolean"));
            }
            break;
        case 19:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DM_3_1Suite : public TestCommand
{
public:
    Test_TC_DM_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query MaxNetworks\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), NetworkCommissioning::Id,
                                 NetworkCommissioning::Attributes::MaxNetworks::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Networks\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), NetworkCommissioning::Id,
                                 NetworkCommissioning::Attributes::Networks::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 2:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DM_2_2Suite : public TestCommand
{
public:
    Test_TC_DM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query fabrics list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Supported Fabrics\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::SupportedFabrics::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query Commissioned Fabrics\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::CommissionedFabrics::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query User Trusted Root Certificates\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::TrustedRootCertificates::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("supportedFabrics", value, 16));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("commissionedFabrics", value, 1));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_EMR_1_1Suite : public TestCommand
{
public:
    Test_TC_EMR_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_EMR_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_EMR_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_EMR_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_EMR_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                 ElectricalMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                 ElectricalMeasurement::Attributes::ClusterRevision::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                  ElectricalMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                 ElectricalMeasurement::Attributes::ClusterRevision::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                 ElectricalMeasurement::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_ETHDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_ETHDIAG_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ETHDIAG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ETHDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ETHDIAG_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_ETHDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_ETHDIAG_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ETHDIAG_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ETHDIAG_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ETHDIAG_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_FLW_1_1Suite : public TestCommand
{
public:
    Test_TC_FLW_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_FLW_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_FLW_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 2U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                  FlowMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_FLW_2_1Suite : public TestCommand
{
public:
    Test_TC_FLW_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_FLW_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_FLW_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 14;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MinMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: MaxMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default value to optional attribute: MeasuredValue\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                  FlowMeasurement::Attributes::MeasuredValue::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : write the default value to optional attribute: MinMeasuredValue\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                  FlowMeasurement::Attributes::MinMeasuredValue::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : write the default value to optional attribute: MaxMeasuredValue\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                  FlowMeasurement::Attributes::MaxMeasuredValue::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MeasuredValue::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: MinMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: MaxMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the optional attribute: Tolerance\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id, FlowMeasurement::Attributes::Tolerance::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: Tolerance\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id, FlowMeasurement::Attributes::Tolerance::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : write the default value to optional attribute: Tolerance\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id, FlowMeasurement::Attributes::Tolerance::Id,
                                  value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: Tolerance\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id, FlowMeasurement::Attributes::Tolerance::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 10:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("tolerance", value, 0U));
            }
            break;
        case 11:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 2048U));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 13:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("tolerance", value, 0U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_FLW_2_2Suite : public TestCommand
{
public:
    Test_TC_FLW_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_FLW_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_FLW_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MeasuredValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_ILL_1_1Suite : public TestCommand
{
public:
    Test_TC_ILL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_ILL_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ILL_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ILL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ILL_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::ClusterRevision::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                  IlluminanceMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::ClusterRevision::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 2U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_LVL_1_1Suite : public TestCommand
{
public:
    Test_TC_LVL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::ClusterRevision::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 4U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::ClusterRevision::Id,
                                  value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::ClusterRevision::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::AttributeList::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read the optional global attribute : FeatureMap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::FeatureMap::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : write the default values to optional global attribute: FeatureMap\n");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::FeatureMap::Id,
                                  value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 5U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 5U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_LVL_2_1Suite : public TestCommand
{
public:
    Test_TC_LVL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reset level to 254\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the CurrentLevel attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the RemainingTime attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::RemainingTime::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads the MinLevel attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MinLevel::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the MaxLevel attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MaxLevel::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the CurrentFrequency attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentFrequency::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads the MinFrequency attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MinFrequency::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads the MaxFrequency attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MaxFrequency::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads the OnOffTransitionTime attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::OnOffTransitionTime::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads the OnLevel attribute \n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnLevel::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads the OnTransitionTime attribute \n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnTransitionTime::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads the OffTransitionTime attribute \n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OffTransitionTime::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads the DefaultMoveRate attribute \n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reads the Options attribute \n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::Options::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 254));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("remainingTime", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minLevel", value, 0));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentFrequency", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minFrequency", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxFrequency", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOffTransitionTime", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("options", value, 0));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_LVL_2_2Suite : public TestCommand
{
public:
    Test_TC_LVL_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the OnOffTransitionTime attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::OnOffTransitionTime::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : writes the OnOffTransitionTime attribute on the DUT\n");
            uint16_t value;
            value = 10U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                  LevelControl::Attributes::OnOffTransitionTime::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the OnOffTransitionTime attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::OnOffTransitionTime::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : writes default value of OnOffTransitionTime attribute\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                  LevelControl::Attributes::OnOffTransitionTime::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : writes the OnLevel attribute on the DUT\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnLevel::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the OnLevel attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnLevel::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes the OnTransitionTime attribute on the DUT\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 100U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnTransitionTime::Id,
                                  value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads the OnTransitionTime attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnTransitionTime::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Writes the OffTransitionTime attribute on the DUT\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 100U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OffTransitionTime::Id,
                                  value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads the OffTransitionTime attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OffTransitionTime::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads the DefaultMoveRate attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Writes the DefaultMoveRate attribute on the DUT\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 100;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id,
                                  value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads the DefaultMoveRate attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : writes the StartUpCurrentLevel attribute on the DUT\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                  LevelControl::Attributes::StartUpCurrentLevel::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : reads the StartUpCurrentLevel attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::StartUpCurrentLevel::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOffTransitionTime", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOffTransitionTime", value, 10U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("onLevel", value));
                VerifyOrReturn(CheckValue("onLevel.Value()", value.Value(), 254));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("onTransitionTime", value));
                VerifyOrReturn(CheckValue("onTransitionTime.Value()", value.Value(), 100U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("offTransitionTime", value));
                VerifyOrReturn(CheckValue("offTransitionTime.Value()", value.Value(), 100U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("defaultMoveRate", value));
                VerifyOrReturn(CheckValue("defaultMoveRate.Value()", value.Value(), 0));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("defaultMoveRate", value));
                VerifyOrReturn(CheckValue("defaultMoveRate.Value()", value.Value(), 100));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("startUpCurrentLevel", value));
                VerifyOrReturn(CheckValue("startUpCurrentLevel.Value()", value.Value(), 254));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_LVL_3_1Suite : public TestCommand
{
public:
    Test_TC_LVL_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the MinLevel attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MinLevel::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the MaxLevel attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MaxLevel::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : sends a Move to level command\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 64;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : sends a Move to level command\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 128;
            value.transitionTime = 1U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait a second\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads On Off Transition Time attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::OnOffTransitionTime::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : sends a Move to level command\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 65535U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 10ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reset level to 254\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 254));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minLevel", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxLevel", value, 254));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 64));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 128));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOffTransitionTime", value, 0U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 254));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_LVL_4_1Suite : public TestCommand
{
public:
    Test_TC_LVL_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_4_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_4_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads max level attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MaxLevel::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : sends a Move up command\n");
            chip::app::Clusters::LevelControl::Commands::Move::Type value;
            value.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
            value.rate           = 200;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Move::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Wait 3000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads min level attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MinLevel::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : sends a Move down command\n");
            chip::app::Clusters::LevelControl::Commands::Move::Type value;
            value.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
            value.rate           = 250;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Move::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait 3000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write default move rate attribute from DUT\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 20;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id,
                                  value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads default move rate attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : sends a Move up command at default move rate\n");
            chip::app::Clusters::LevelControl::Commands::Move::Type value;
            value.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
            value.rate           = 255;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Move::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reset level to 254\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 254));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxLevel", value, 254));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 254));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minLevel", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 1));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("defaultMoveRate", value));
                VerifyOrReturn(CheckValue("defaultMoveRate.Value()", value.Value(), 20));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 255));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_LVL_5_1Suite : public TestCommand
{
public:
    Test_TC_LVL_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_5_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_5_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_5_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 14;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sending on command\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: DUT level is set to 0x80\n");
            chip::app::Clusters::LevelControl::Commands::Step::Type value;
            value.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
            value.stepSize       = 126;
            value.transitionTime = 20U;
            value.optionMask     = 0;
            value.optionOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Step::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 4000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(4000);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads current level attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends step down command to DUT\n");
            chip::app::Clusters::LevelControl::Commands::Step::Type value;
            value.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
            value.stepSize       = 64;
            value.transitionTime = 20U;
            value.optionMask     = 0;
            value.optionOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Step::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 4000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(4000);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads current level attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Sends a Step up command\n");
            chip::app::Clusters::LevelControl::Commands::Step::Type value;
            value.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
            value.stepSize       = 64;
            value.transitionTime = 20U;
            value.optionMask     = 0;
            value.optionOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Step::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 4000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(4000);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads current level attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reset level to 254\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Sending off command\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 128));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 64));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 128));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_LVL_6_1Suite : public TestCommand
{
public:
    Test_TC_LVL_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_6_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_6_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_6_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sending on command\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: set DUT to lowest point\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 0;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends a move up command to DUT\n");
            chip::app::Clusters::LevelControl::Commands::Move::Type value;
            value.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
            value.rate           = 1;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Move::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 2000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends stop command to DUT\n");
            chip::app::Clusters::LevelControl::Commands::Stop::Type value;
            value.optionMask     = 0;
            value.optionOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Stop::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads CurrentLevel attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reset level to 254\n");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Sending off command\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 1));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 2));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 3));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_1_1Suite : public TestCommand
{
public:
    Test_TC_MC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::ClusterRevision::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::ClusterRevision::Id,
                                  value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::ClusterRevision::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_2_1Suite : public TestCommand
{
public:
    Test_TC_MC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Put the device into low power mode\n");
            chip::app::Clusters::LowPower::Commands::Sleep::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LowPower::Id, LowPower::Commands::Sleep::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_1Suite : public TestCommand
{
public:
    Test_TC_MC_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_2Suite : public TestCommand
{
public:
    Test_TC_MC_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_3Suite : public TestCommand
{
public:
    Test_TC_MC_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_4Suite : public TestCommand
{
public:
    Test_TC_MC_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_5Suite : public TestCommand
{
public:
    Test_TC_MC_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_6Suite : public TestCommand
{
public:
    Test_TC_MC_3_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_6", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_6\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_7Suite : public TestCommand
{
public:
    Test_TC_MC_3_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_7", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_7\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_8Suite : public TestCommand
{
public:
    Test_TC_MC_3_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_8", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_8Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_8\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_9Suite : public TestCommand
{
public:
    Test_TC_MC_3_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_9", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_9\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_10Suite : public TestCommand
{
public:
    Test_TC_MC_3_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_10", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_10Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_10\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_11Suite : public TestCommand
{
public:
    Test_TC_MC_3_11Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_11", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_11Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_11\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_11\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_5_1Suite : public TestCommand
{
public:
    Test_TC_MC_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_5_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_5_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the ChannelList attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::ChannelList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_5_2Suite : public TestCommand
{
public:
    Test_TC_MC_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_5_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_5_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("verify that the channel has changed on the device.");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_5_3Suite : public TestCommand
{
public:
    Test_TC_MC_5_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_5_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_5_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("verify that the channel has changed on the device");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_6_1Suite : public TestCommand
{
public:
    Test_TC_MC_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_6_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_6_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that media is paused");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is playing");
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the playback state attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is paused");
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is stoped");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_6_2Suite : public TestCommand
{
public:
    Test_TC_MC_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_6_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_6_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that media is paused");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is playing");
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the CurrentState attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is started over");
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the next media item in the queue has been loaded");
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the previous media item in the queue has been loaded");
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media has skipped forward 10 seconds");
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media has skipped backward 10 seconds");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_6_3Suite : public TestCommand
{
public:
    Test_TC_MC_6_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_6_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_6_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that media is paused");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media has moved to 10 seconds from the starting point.");
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("User prompt needed to enter the value beyond the furthest valid position");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_6_4Suite : public TestCommand
{
public:
    Test_TC_MC_6_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_6_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_6_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that media is paused");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the PlaybackSpeed attribute from the DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::PlaybackSpeed::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media is playing");
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the CurrentState attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media play speed has increased");
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media play has reversed direction");
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the CurrentState attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media play has reversed direction");
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : log a command\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media is has resumed playing forward at the default speed");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("playbackSpeed", value, 0.0f));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_7_1Suite : public TestCommand
{
public:
    Test_TC_MC_7_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_7_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_7_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_7_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_7_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_7_2Suite : public TestCommand
{
public:
    Test_TC_MC_7_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_7_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_7_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_7_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_7_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_8_1Suite : public TestCommand
{
public:
    Test_TC_MC_8_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_8_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_8_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_8_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_8_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the CurrentTarget attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id,
                                 TargetNavigator::Attributes::CurrentTarget::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the TargetList attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id, TargetNavigator::Attributes::TargetList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_9_1Suite : public TestCommand
{
public:
    Test_TC_MC_9_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_9_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_9_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_9_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_9_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition\n");
            SetIdentity(kIdentityAlpha);
            return Log("DUT has one or more Content Apps available");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the VendorName attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::VendorName::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the VendorID attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id, ApplicationBasic::Attributes::VendorID::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the ApplicationName attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ApplicationName::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads the ProductID attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id, ApplicationBasic::Attributes::ProductID::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the Status attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id, ApplicationBasic::Attributes::Status::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the ApplicationVersion attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ApplicationVersion::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorID", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "vendor-id"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 256));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_OCC_1_1Suite : public TestCommand
{
public:
    Test_TC_OCC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OCC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                  OccupancySensing::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_OCC_2_1Suite : public TestCommand
{
public:
    Test_TC_OCC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OCC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads mandatory attribute constrains: Occupancy\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Writes the respective default value to mandatory attribute: Occupancy\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id,
                                  value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: Occupancy\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads mandatory attribute constrains: OccupancySensorType\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::OccupancySensorType::Id);
        }
        case 5: {
            ChipLogProgress(
                chipTool, " ***** Test Step 5 : Writes the respective default value to mandatory attribute: OccupancySensorType\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                  OccupancySensing::Attributes::OccupancySensorType::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: OccupancySensorType\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::OccupancySensorType::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads mandatory attribute constrains: OccupancySensorTypeBitmap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id);
        }
        case 8: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : Writes the respective default value to mandatory attribute: OccupancySensorTypeBitmap\n");
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                  OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: OccupancySensorTypeBitmap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 1));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupancy", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 3));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupancySensorType", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 7));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupancySensorTypeBitmap", value, 1));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_OCC_2_2Suite : public TestCommand
{
public:
    Test_TC_OCC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OCC_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Occupancy attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPANCY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads Occupancy attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPANCY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_OO_1_1Suite : public TestCommand
{
public:
    Test_TC_OO_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OO_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::ClusterRevision::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::ClusterRevision::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::AttributeList::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the optional global attribute: FeatureMap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::FeatureMap::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read the optional global attribute : FeatureMap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::FeatureMap::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default values to optional global attribute: FeatureMap\n");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::FeatureMap::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads back optional global attribute: FeatureMap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 4U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 4U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("featureMap", value, 0UL));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("featureMap", value, 0UL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_OO_2_1Suite : public TestCommand
{
public:
    Test_TC_OO_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OO_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: OnOff\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : write the default value of mandatory attribute: OnOff\n");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : reads back mandatory attribute: OnOff\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : read LT attribute: GlobalSceneControl\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : read LT attribute: OnTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : read LT attribute: OffWaitTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : read LT attribute: StartUpOnOff\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default value to LT attribute: GlobalSceneControl\n");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : write the default value to LT attribute: OnTime\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : write the default value to LT attribute: OffWaitTime\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : write the default value to LT attribute: StartUpOnOff\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : reads back LT attribute: GlobalSceneControl\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : reads back LT attribute: OnTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : reads back LT attribute: OffWaitTime\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : reads back LT attribute: StartUpOnOff\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("globalSceneControl", value, 1));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("startUpOnOff", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("globalSceneControl", value, 1));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("startUpOnOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_OO_2_2Suite : public TestCommand
{
public:
    Test_TC_OO_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OO_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 15;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Off Command\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send On Command\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send Off Command\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Send Toggle Command\n");
            chip::app::Clusters::OnOff::Commands::Toggle::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Toggle::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is true after toggle command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send Toggle Command\n");
            chip::app::Clusters::OnOff::Commands::Toggle::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Toggle::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check on/off attribute value is false after toggle command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Send On Command\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Check on/off attribute value is true after on command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Send Off Command\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Check on/off attribute value is false after off command\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_OO_2_3Suite : public TestCommand
{
public:
    Test_TC_OO_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_2_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OO_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 47;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send On Command\n");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 1000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads GlobalSceneControl attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_GLOBALSCENECONTROL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send On Command\n");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 1000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads GlobalSceneControl attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_GLOBALSCENECONTROL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send On Command\n");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 1000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads GlobalSceneControl attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_GLOBALSCENECONTROL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads OffWaitTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Send On Command\n");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Reads OffWaitTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Send Off Command\n");
            VerifyOrdo(!ShouldSkip("CR_OFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : Reads OffWaitTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : Send On Command\n");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : Reads OffWaitTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : Send Off Command\n");
            VerifyOrdo(!ShouldSkip("CR_OFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : Send On Command\n");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : Reads OffWaitTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : Send Off Command\n");
            VerifyOrdo(!ShouldSkip("CR_OFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads OffWaitTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads OnOff attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : Reads OnTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : Reads OffWaitTime attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : Send Off Command\n");
            VerifyOrdo(!ShouldSkip("CR_OFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("globalSceneControl", value, 1));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("globalSceneControl", value, 1));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("globalSceneControl", value, 1));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PS_1_1Suite : public TestCommand
{
public:
    Test_TC_PS_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PS_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PS_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PS_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PS_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::ClusterRevision::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::ClusterRevision::Id,
                                  value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::ClusterRevision::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PRS_1_1Suite : public TestCommand
{
public:
    Test_TC_PRS_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PRS_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PRS_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                  PressureMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute constraints: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PRS_2_1Suite : public TestCommand
{
public:
    Test_TC_PRS_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PRS_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PRS_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the mandatory attribute constraints: MeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write the default values to mandatory attribute: MeasuredValue\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                  PressureMeasurement::Attributes::MeasuredValue::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: MeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MeasuredValue::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the mandatory attribute constraints: MinMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write the default values to mandatory attribute: MinMeasuredValue\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                  PressureMeasurement::Attributes::MinMeasuredValue::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: MinMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read the mandatory attribute constraints: MaxMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write the default values to mandatory attribute: MaxMeasuredValue\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                  PressureMeasurement::Attributes::MaxMeasuredValue::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: MaxMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("measuredValue", value));
                VerifyOrReturn(CheckValue("measuredValue.Value()", value.Value(), 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("minMeasuredValue", value));
                VerifyOrReturn(CheckValue("minMeasuredValue.Value()", value.Value(), 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("maxMeasuredValue", value));
                VerifyOrReturn(CheckValue("maxMeasuredValue.Value()", value.Value(), 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PCC_1_1Suite : public TestCommand
{
public:
    Test_TC_PCC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PCC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::AttributeList::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the optional global attribute: FeatureMap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PCC_2_1Suite : public TestCommand
{
public:
    Test_TC_PCC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PCC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 50;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MaxPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxPressure::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MaxSpeed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxSpeed::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: MaxFlow\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxFlow::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: EffectiveOperationMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: EffectiveControlMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: Capacity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Capacity::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MaxPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxPressure::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: MaxSpeed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxSpeed::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: MaxFlow\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxFlow::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the mandatory attribute: EffectiveOperationMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the mandatory attribute: EffectiveControlMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : read the mandatory attribute: Capacity\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Capacity::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: MinConstPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstPressure::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: MaxConstPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstPressure::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : read the optional attribute: MinCompPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinCompPressure::Id);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : read the optional attribute: MaxCompPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxCompPressure::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : read the optional attribute: MinConstSpeed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstSpeed::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : read the optional attribute: MaxConstSpeed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstSpeed::Id);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : read the optional attribute: MinConstFlow\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstFlow::Id);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : read the optional attribute: MaxConstFlow\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstFlow::Id);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : read the optional attribute: MinConstTemp\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstTemp::Id);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : read the optional attribute: MaxConstTemp\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstTemp::Id);
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : read the optional attribute: PumpStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::PumpStatus::Id);
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : read the optional attribute: PumpStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::PumpStatus::Id);
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : read the optional attribute: Speed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Speed::Id);
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : read the optional attribute: LifetimeRunningHours\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : read the optional attribute: LifetimeRunningHours\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : read the optional attribute: Power\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Power::Id);
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : read the optional attribute: LifetimeEnergyConsumed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : read the optional attribute: LifetimeEnergyConsumed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : write to the optional attribute: LifetimeEnergyConsumed\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id, value);
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : read the optional attribute: MinConstPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstPressure::Id);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : read the optional attribute: MaxConstPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstPressure::Id);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : read the optional attribute: MinCompPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinCompPressure::Id);
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : read the optional attribute: MaxCompPressure\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxCompPressure::Id);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : read the optional attribute: MinConstSpeed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstSpeed::Id);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : read the optional attribute: MaxConstSpeed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstSpeed::Id);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : read the optional attribute: MinConstFlow\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstFlow::Id);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : read the optional attribute: MaxConstFlow\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstFlow::Id);
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : read the optional attribute: MinConstTemp\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstTemp::Id);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : read the optional attribute: MaxConstTemp\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstTemp::Id);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : read the optional attribute: PumpStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::PumpStatus::Id);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : read the optional attribute: PumpStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::PumpStatus::Id);
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : read the optional attribute: Speed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Speed::Id);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : read the optional attribute: LifetimeRunningHours\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : read the optional attribute: LifetimeRunningHours\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : read the optional attribute: Power\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Power::Id);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : read the optional attribute: LifetimeEnergyConsumed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : read the optional attribute: LifetimeEnergyConsumed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 13:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 14:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 15:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 16:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 17:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 18:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 19:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 20:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 21:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, -27315));
            }
            break;
        case 22:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, -27315));
            }
            break;
        case 23:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("pumpStatus", value, 0U));
            }
            break;
        case 24:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
            }
            break;
        case 25:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 26:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", value));
                VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", value.Value(), 0UL));
            }
            break;
        case 27:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint24"));
            }
            break;
        case 28:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint24"));
            }
            break;
        case 29:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", value));
                VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", value.Value(), 0UL));
            }
            break;
        case 30:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 31:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 32:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 33:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 34:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 35:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 36:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 37:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 38:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 39:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 40:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, -27315));
            }
            break;
        case 41:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, -27315));
            }
            break;
        case 42:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("pumpStatus", value, 0U));
            }
            break;
        case 43:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
            }
            break;
        case 44:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", value));
                VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", value.Value(), 0UL));
            }
            break;
        case 46:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint24"));
            }
            break;
        case 47:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint24"));
            }
            break;
        case 48:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", value));
                VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", value.Value(), 0UL));
            }
            break;
        case 49:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PCC_2_2Suite : public TestCommand
{
public:
    Test_TC_PCC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PCC_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 1 to the OperationMode attribute to DUT: OperationMode\n");
            VerifyOrdo(!ShouldSkip("A_OPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::OperationMode::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write 2 to the OperationMode attribute to DUT: OperationMode\n");
            VerifyOrdo(!ShouldSkip("A_OPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::OperationMode::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write 3 to the OperationMode attribute to DUT: OperationMode\n");
            VerifyOrdo(!ShouldSkip("A_OPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 3;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::OperationMode::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PCC_2_3Suite : public TestCommand
{
public:
    Test_TC_PCC_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_2_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PCC_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 0 to the OperationMode attribute to DUT\n");
            VerifyOrdo(!ShouldSkip("A_OPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::OperationMode::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the attribute: EffectiveOperationMode\n");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVEOPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write 0 to the ControlMode attribute to DUT\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the attribute: EffectiveControlMode\n");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVECONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write 1 to the ControlMode attribute to DUT\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write 2 to the ControlMode attribute to DUT\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write 3 to the ControlMode attribute to DUT\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 3;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write 5 to the ControlMode attribute to DUT\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 5;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write 7 to the ControlMode attribute to DUT\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 7;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveOperationMode", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveControlMode", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_RH_1_1Suite : public TestCommand
{
public:
    Test_TC_RH_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_RH_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_RH_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                  RelativeHumidityMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_RH_2_1Suite : public TestCommand
{
public:
    Test_TC_RH_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_RH_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_RH_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads constraints of attribute: MeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads constraints of attribute: MinMeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the optional attribute: Tolerance\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::Tolerance::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads constraints of attribute: Tolerance\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::Tolerance::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 9999U));
            }
            break;
        case 3:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("tolerance", value, 0U));
            }
            break;
        case 4:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 2048U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_RH_2_2Suite : public TestCommand
{
public:
    Test_TC_RH_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_RH_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_RH_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads MeasuredValue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_RELATIVEHUMIDITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the mandatory attribute: MeasuredValue\n");
            VerifyOrdo(!ShouldSkip("A_RELATIVEHUMIDITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MeasuredValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SWTCH_2_1Suite : public TestCommand
{
public:
    Test_TC_SWTCH_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWTCH_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWTCH_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWTCH_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWTCH_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read NumberOfPositions attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::NumberOfPositions::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read NumberOfPositions attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::NumberOfPositions::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read CurrentPosition attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::CurrentPosition::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read CurrentPosition attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::CurrentPosition::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read MultiPressMax attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::MultiPressMax::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read MultiPressMax attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::MultiPressMax::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfPositions", value, 2));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 2));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentPosition", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("multiPressMax", value, 2));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 2));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SWTCH_2_2Suite : public TestCommand
{
public:
    Test_TC_SWTCH_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWTCH_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWTCH_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWTCH_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWTCH_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 38;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to SwitchLatched event");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator sets switch to first position");
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read CurrentPosition attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::CurrentPosition::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator sets switch to second position");
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to InitialPress event");
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch");
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read CurrentPosition attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::CurrentPosition::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator sets switch to second position");
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch (release switch)");
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to InitialPress and ShortRelease events");
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch");
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch (press briefly)");
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch for 5 seconds");
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Wait 3000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to InitialPress, LongPress, ShortRelease, LongRelease events");
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch");
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch (press briefly)");
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch for 5 seconds");
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Wait 3000ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to InitialPress, ShortRelease, MultiPressOngoing, MultiPressComplete events");
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch");
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch (press briefly)");
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch (press briefly)");
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch again (press briefly)");
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch again (press briefly)");
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch again (press briefly)");
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch again (press briefly)");
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : User interaction needed\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentPosition", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentPosition", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TM_1_1Suite : public TestCommand
{
public:
    Test_TC_TM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TM_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TM_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 4U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                  TemperatureMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TM_2_1Suite : public TestCommand
{
public:
    Test_TC_TM_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TM_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TM_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the optional attribute: Tolerance\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::Tolerance::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 2:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 2048U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TM_2_2Suite : public TestCommand
{
public:
    Test_TC_TM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TM_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TM_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads MeasuredValue attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the mandatory attribute: MeasuredValue\n");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MeasuredValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TSTAT_1_1Suite : public TestCommand
{
public:
    Test_TC_TSTAT_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSTAT_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSTAT_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 5U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::ClusterRevision::Id,
                                  value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::AttributeList::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the optional global attribute constraints: FeatureMap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TSTAT_2_1Suite : public TestCommand
{
public:
    Test_TC_TSTAT_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSTAT_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSTAT_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 61;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Reads constraints of mandatory attributes from DUT: LocalTemperature\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::LocalTemperature::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMinHeatSetpointLimit::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Reads constraints of mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMinHeatSetpointLimit::Id);
        }
        case 4: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMinHeatSetpointLimit\n");
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::AbsMinHeatSetpointLimit::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read back mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMinHeatSetpointLimit::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMaxHeatSetpointLimit::Id);
        }
        case 7: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : Reads constraints of mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMaxHeatSetpointLimit::Id);
        }
        case 8: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMaxHeatSetpointLimit\n");
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::AbsMaxHeatSetpointLimit::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read back mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMaxHeatSetpointLimit::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMinCoolSetpointLimit::Id);
        }
        case 11: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : Reads constraints of mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMinCoolSetpointLimit::Id);
        }
        case 12: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMinCoolSetpointLimit\n");
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::AbsMinCoolSetpointLimit::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read back mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMinCoolSetpointLimit::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMaxCoolSetpointLimit::Id);
        }
        case 15: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 15 : Reads constraints of mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMaxCoolSetpointLimit::Id);
        }
        case 16: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMaxCoolSetpointLimit\n");
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::AbsMaxCoolSetpointLimit::Id, value);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read back mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMaxCoolSetpointLimit::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Reads mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedCoolingSetpoint::Id);
        }
        case 19: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : Reads constraints of mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedCoolingSetpoint::Id);
        }
        case 20: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 20 : Writes the respective default value to mandatory attributes to DUT: "
                            "OccupiedCoolingSetpoint\n");
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read back mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedCoolingSetpoint::Id);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedHeatingSetpoint::Id);
        }
        case 23: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 23 : Reads constraints of mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedHeatingSetpoint::Id);
        }
        case 24: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : Writes the respective default value to mandatory attributes to DUT: "
                            "OccupiedHeatingSetpoint\n");
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read back mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedHeatingSetpoint::Id);
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads mandatory attributes from DUT: MinHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id);
        }
        case 27: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 27 : Reads constraints of mandatory attributes from DUT: MinHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id);
        }
        case 28: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 28 : Writes the respective default value to mandatory attributes to DUT: MinHeatSetpointLimit\n");
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read back mandatory attributes from DUT: MinHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id);
        }
        case 31: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 31 : Reads constraints of mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id);
        }
        case 32: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 32 : Writes the respective default value to mandatory attributes to DUT: MaxHeatSetpointLimit\n");
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read back mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads mandatory attributes from DUT: MinCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id);
        }
        case 35: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 35 : Reads constraints of mandatory attributes from DUT: MinCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id);
        }
        case 36: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 36 : Writes the respective default value to mandatory attributes to DUT: MinCoolSetpointLimit\n");
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read back mandatory attributes from DUT: MinCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id);
        }
        case 39: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 39 : Reads constraints of mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id);
        }
        case 40: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 40 : Writes the respective default value to mandatory attributes to DUT: MaxCoolSetpointLimit\n");
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read back mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads mandatory attributes from DUT: ControlSequenceOfOperation\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::ControlSequenceOfOperation::Id);
        }
        case 43: {
            ChipLogProgress(
                chipTool, " ***** Test Step 43 : Reads constraints of mandatory attributes from DUT: ControlSequenceOfOperation\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::ControlSequenceOfOperation::Id);
        }
        case 44: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 44 : Writes the respective default value to mandatory attributes to DUT: "
                            "ControlSequenceOfOperation\n");
            uint8_t value;
            value = 4;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::ControlSequenceOfOperation::Id, value);
        }
        case 45: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 45 : Read back mandatory attributes from DUT: ControlSequenceOfOperation\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::ControlSequenceOfOperation::Id);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reads mandatory attributes from DUT: SystemMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::SystemMode::Id);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : Reads constraints of mandatory attributes from DUT: SystemMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::SystemMode::Id);
        }
        case 48: {
            ChipLogProgress(
                chipTool, " ***** Test Step 48 : Writes the respective default value to mandatory attributes to DUT: SystemMode\n");
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::SystemMode::Id, value);
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read back mandatory attributes from DUT: SystemMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::SystemMode::Id);
        }
        case 50: {
            ChipLogProgress(chipTool, " ***** Test Step 50 : Reads optional attributes from DUT: MinSetpointDeadBand\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinSetpointDeadBand::Id);
        }
        case 51: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 51 : Reads constraints of optional attributes from DUT: MinSetpointDeadBand\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinSetpointDeadBand::Id);
        }
        case 52: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 52 : Writes the respective default value to optional attributes to DUT: MinSetpointDeadBand\n");
            int8_t value;
            value = 25;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinSetpointDeadBand::Id,
                                  value);
        }
        case 53: {
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read back optional attributes from DUT: MinSetpointDeadBand\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinSetpointDeadBand::Id);
        }
        case 54: {
            ChipLogProgress(chipTool, " ***** Test Step 54 : Reads constraints of optional attributes from DUT: StartOfWeek\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::StartOfWeek::Id);
        }
        case 55: {
            ChipLogProgress(
                chipTool, " ***** Test Step 55 : Writes the respective default value to optional attributes to DUT: StartOfWeek\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::StartOfWeek::Id, value);
        }
        case 56: {
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read back optional attributes from DUT: StartOfWeek\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::StartOfWeek::Id);
        }
        case 57: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 57 : Reads constraints of optional attributes from DUT: NumberOfWeeklyTransitions\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::NumberOfWeeklyTransitions::Id);
        }
        case 58: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 58 : Writes the respective default value to optional attributes to DUT: "
                            "NumberOfWeeklyTransitions\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::NumberOfWeeklyTransitions::Id, value);
        }
        case 59: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 59 : Reads constraints of optional attributes from DUT: NumberOfDailyTransitions\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::NumberOfDailyTransitions::Id);
        }
        case 60: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 60 : Writes the respective default value to optional attributes to DUT: "
                            "NumberOfDailyTransitions\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::NumberOfDailyTransitions::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("absMinHeatSetpointLimit", value, 700));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3000));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("absMinHeatSetpointLimit", value, 700));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("absMaxHeatSetpointLimit", value, 3000));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3000));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("absMaxHeatSetpointLimit", value, 3000));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("absMinCoolSetpointLimit", value, 1600));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3200));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("absMinCoolSetpointLimit", value, 1600));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("absMaxCoolSetpointLimit", value, 3200));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3200));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("absMaxCoolSetpointLimit", value, 3200));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", value, 2600));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 2600));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", value, 2600));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", value, 2000));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 2600));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", value, 2000));
            }
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minHeatSetpointLimit", value, 700));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3000));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minHeatSetpointLimit", value, 700));
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxHeatSetpointLimit", value, 3000));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3000));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxHeatSetpointLimit", value, 3000));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minCoolSetpointLimit", value, 1600));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3200));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minCoolSetpointLimit", value, 1600));
            }
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxCoolSetpointLimit", value, 3200));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3200));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxCoolSetpointLimit", value, 3200));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("controlSequenceOfOperation", value, 4));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 5));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("controlSequenceOfOperation", value, 4));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("systemMode", value, 1));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 9));
            }
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("systemMode", value, 1));
            }
            break;
        case 50:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minSetpointDeadBand", value, 25));
            }
            break;
        case 51:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int8"));
                VerifyOrReturn(CheckConstraintMinValue<int8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<int8_t>("value", value, 25));
            }
            break;
        case 52:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 53:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minSetpointDeadBand", value, 25));
            }
            break;
        case 54:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 6));
            }
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 56:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("startOfWeek", value, 0));
            }
            break;
        case 57:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 59:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TSTAT_2_2Suite : public TestCommand
{
public:
    Test_TC_TSTAT_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSTAT_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSTAT_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 50;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Reads OccupiedCoolingSetpoint attribute from Server DUT and verifies that the "
                            "value is within range\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedCoolingSetpoint::Id);
        }
        case 2: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 2 : Writes a value back that is different but valid for OccupiedCoolingSetpoint attribute\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 3: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 3 : Reads it back again to confirm the successful write of OccupiedCoolingSetpoint attribute\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedCoolingSetpoint::Id);
        }
        case 4: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Writes the limit of MinCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Writes the limit of MaxCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Reads OccupiedHeatingSetpoint attribute from Server DUT and verifies that the "
                            "value is within range\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedHeatingSetpoint::Id);
        }
        case 7: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 7 : Writes a value back that is different but valid for OccupiedHeatingSetpoint attribute\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2100;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 8: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : Reads it back again to confirm the successful write of OccupiedHeatingSetpoint attribute\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedHeatingSetpoint::Id);
        }
        case 9: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes the limit of MinHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 10: {
            ChipLogProgress(
                chipTool, " ***** Test Step 10 : Writes the limit of MaxHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : Reads MinHeatSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id);
        }
        case 12: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 12 : Writes a value back that is different but valid for MinHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 13: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 13 : Reads it back again to confirm the successful write of MinHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id);
        }
        case 14: {
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : Writes the limit of AbsMinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 15: {
            ChipLogProgress(
                chipTool, " ***** Test Step 15 : Writes the limit of AbsMaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 16: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : Reads MaxHeatSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id);
        }
        case 17: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : Writes a value back that is different but valid for MaxHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 18: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 18 : Reads it back again to confirm the successful write of MaxHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id);
        }
        case 19: {
            ChipLogProgress(
                chipTool, " ***** Test Step 19 : Writes the limit of AbsMinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 20: {
            ChipLogProgress(
                chipTool, " ***** Test Step 20 : Writes the limit of AbsMaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 21: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 21 : Reads MinCoolSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id);
        }
        case 22: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 22 : Writes a value back that is different but valid for MinCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 23: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 23 : Reads it back again to confirm the successful write of MinCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id);
        }
        case 24: {
            ChipLogProgress(
                chipTool, " ***** Test Step 24 : Writes the limit of AbsMinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 25: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : Writes the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 26: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 26 : Reads MaxCoolSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id);
        }
        case 27: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 27 : Writes a value back that is different but valid for MaxCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 28: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 28 : Reads it back again to confirm the successful write of MaxCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id);
        }
        case 29: {
            ChipLogProgress(
                chipTool, " ***** Test Step 29 : Writes the limit of AbsMinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 30: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 30 : Writes the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 31: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 31 : Writes (sets back) the limit of MinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 32: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 32 : Writes (sets back) the limit of MaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 33: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 33 : Writes (sets back) the limit of MinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 34: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 34 : Writes (sets back) the limit of MaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 35: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 35 : Writes (sets back) the limit of MinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 36: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 36 : Writes (sets back) the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 37: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 37 : Writes (sets back) the limit of MinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 38: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 38 : Writes (sets back) the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 39: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 39 : Reads ControlSequenceOfOperation from Server DUT and verifies that the value is valid\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::ControlSequenceOfOperation::Id);
        }
        case 40: {
            ChipLogProgress(
                chipTool, " ***** Test Step 40 : Write Attribute command for ControlSequenceOfOperation with a new valid value\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::ControlSequenceOfOperation::Id, value);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read it back again to confirm the successful write\n");
            VerifyOrdo(!ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::ControlSequenceOfOperation::Id);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : Sets OccupiedHeatingSetpoint to default value\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : Sets OccupiedHeatingSetpoint to default value\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : Sets OccupiedCoolingSetpoint to default value\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : Sets OccupiedCoolingSetpoint to default value\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : Sets OccupiedCoolingSetpoint to default value\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : Sets OccupiedHeatingSetpoint to default value\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : Sets OccupiedCoolingSetpoint to default value\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : Sets OccupiedHeatingSetpoint to default value\n");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", value, 2600));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 2600));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", value, 2000));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", value, 2000));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3000));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", value, 2100));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minHeatSetpointLimit", value, 700));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3000));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minHeatSetpointLimit", value, 2000));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxHeatSetpointLimit", value, 3000));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3000));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxHeatSetpointLimit", value, 2000));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minCoolSetpointLimit", value, 1600));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3200));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minCoolSetpointLimit", value, 2000));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxCoolSetpointLimit", value, 3200));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 3200));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxCoolSetpointLimit", value, 2000));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("controlSequenceOfOperation", value, 4));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 5));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("controlSequenceOfOperation", value, 2));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TSUIC_1_1Suite : public TestCommand
{
public:
    Test_TC_TSUIC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSUIC_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSUIC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 2U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TSUIC_2_1Suite : public TestCommand
{
public:
    Test_TC_TSUIC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSUIC_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSUIC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: TemperatureDisplayMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: TemperatureDisplayMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : write to the mandatory attribute: TemperatureDisplayMode\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: TemperatureDisplayMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: TemperatureDisplayMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: KeypadLockout\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: KeypadLockout\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : write to the mandatory attribute: KeypadLockout\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: KeypadLockout\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the mandatory attribute: KeypadLockout\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: ScheduleProgrammingVisibility\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : read the optional attribute: ScheduleProgrammingVisibility\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : write to the mandatory attribute: ScheduleProgrammingVisibility\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: ScheduleProgrammingVisibility\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : read the optional attribute: ScheduleProgrammingVisibility\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("temperatureDisplayMode", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("temperatureDisplayMode", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("keypadLockout", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("keypadLockout", value, 0));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("scheduleProgrammingVisibility", value, 0));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("scheduleProgrammingVisibility", value, 0));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_TSUIC_2_2Suite : public TestCommand
{
public:
    Test_TC_TSUIC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSUIC_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSUIC_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 11;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Writes a value of 0 to TemperatureDisplayMode attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE_DISPLAY_MODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Writes a value of 1 to TemperatureDisplayMode attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE_DISPLAY_MODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Writes a value of 0 to KeypadLockout attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Writes a value of 1 to KeypadLockout attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Writes a value of 2 to KeypadLockout attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Writes a value of 3 to KeypadLockout attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 3;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes a value of 4 to KeypadLockout attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 4;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Writes a value of 5 to KeypadLockout attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 5;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes a value of 0 to ScheduleProgrammingVisibility attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Writes a value of 1 to ScheduleProgrammingVisibility attribute of DUT\n");
            VerifyOrdo(!ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DIAG_TH_NW_1_1Suite : public TestCommand
{
public:
    Test_TC_DIAG_TH_NW_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_TH_NW_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DIAG_TH_NW_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_TH_NW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_TH_NW_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sends ResetCounts command\n");
            chip::app::Clusters::ThreadNetworkDiagnostics::Commands::ResetCounts::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                               ThreadNetworkDiagnostics::Commands::ResetCounts::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the Overruncount attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::OverrunCount::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("overrunCount", value, 0ULL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WIFIDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WIFIDIAG_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WIFIDIAG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads NetworkInterface structure attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralDiagnostics::Id,
                                 GeneralDiagnostics::Attributes::NetworkInterfaces::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WIFIDIAG_3_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WIFIDIAG_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WIFIDIAG_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_1_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2: read the global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::ClusterRevision::Id);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : 3a: write a value into the RO mandatory global attribute: ClusterRevision\n");
            uint16_t value;
            value = 201U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3b: reads back global attribute: ClusterRevision\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::ClusterRevision::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the global attribute: AttributeList\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::AttributeList::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : 2: read the global attribute: FeatureMap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::FeatureMap::Id);
        }
        case 6: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : 3a: write the default value to optional global attribute: FeatureMap\n");
            uint32_t value;
            value = 32769UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::FeatureMap::Id,
                                  value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : 3b: reads back global attribute: FeatureMap\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 5U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 200U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 201U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
                VerifyOrReturn(CheckConstraintMinValue<uint32_t>("value", value, 0UL));
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("value", value, 32768UL));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 32769UL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_2_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 55;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2: read the RO mandatory attribute default: Type\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: write a value into the RO mandatory attribute: Type\n");
            uint8_t value;
            value = 250;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3b: reads back the RO mandatory attribute: Type\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : 2: read the RO mandatory attribute default: ConfigStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : 3a: write a value into the RO mandatory attribute: ConfigStatus\n");
            uint8_t value;
            value = 128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id,
                                  value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : 3b: reads back the RO mandatory attribute: ConfigStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : 2: read the RO mandatory attribute default: OperationalStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 8: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : 3a: write a value into the RO mandatory attribute: OperationalStatus\n");
            uint8_t value;
            value = 128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::OperationalStatus::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : 3b: reads back the RO mandatory attribute: OperationalStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : 2: read the RO mandatory attribute default: EndProductType\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::EndProductType::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : 3a: write a value into the RO mandatory attribute: EndProductType\n");
            uint8_t value;
            value = 250;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::EndProductType::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : 3b: reads back the RO mandatory attribute: EndProductType\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::EndProductType::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : 2: read the RW mandatory attribute default: Mode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : 3a: write a value into the RW mandatory attribute:: Mode\n");
            uint8_t value;
            value = 8;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : 3b: reads back the RW mandatory attribute: Mode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id);
        }
        case 16: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : 2: read the RO optional attribute default: TargetPositionLiftPercent100ths\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 17: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : 3a: write a value into the RO optional attribute: TargetPositionLiftPercent100ths\n");
            chip::app::DataModel::Nullable<chip::Percent100ths> value;
            value.SetNonNull();
            value.Value() = 20000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id, value);
        }
        case 18: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 18 : 3b: reads back the RO optional attribute: TargetPositionLiftPercent100ths\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 19: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : 2: read the RO optional attribute default: TargetPositionTiltPercent100ths\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        case 20: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 20 : 3a: write a value into the RO optional attribute: TargetPositionTiltPercent100ths\n");
            chip::app::DataModel::Nullable<chip::Percent100ths> value;
            value.SetNonNull();
            value.Value() = 20000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id, value);
        }
        case 21: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 21 : 3b: reads back the RO optional attribute: TargetPositionTiltPercent100ths\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        case 22: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 22 : 2: read the RO optional attribute default: CurrentPositionLiftPercent100ths\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 23: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 23 : 3a: write a value into the RO optional attribute: CurrentPositionLiftPercent100ths\n");
            chip::app::DataModel::Nullable<chip::Percent100ths> value;
            value.SetNonNull();
            value.Value() = 20000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id, value);
        }
        case 24: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : 3b: reads back the RO optional attribute: CurrentPositionLiftPercent100ths\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 25: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : 2: read the RO optional attribute default: CurrentPositionTiltPercent100ths\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 26: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 26 : 3a: write a value into the RO optional attribute: CurrentPositionTiltPercent100ths\n");
            chip::app::DataModel::Nullable<chip::Percent100ths> value;
            value.SetNonNull();
            value.Value() = 20000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id, value);
        }
        case 27: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 27 : 3b: reads back the RO optional attribute: CurrentPositionTiltPercent100ths\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : 2: read the RO optional attribute default: InstalledOpenLimitLift\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledOpenLimitLift::Id);
        }
        case 29: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 29 : 3a: write a value into the RO optional attribute: InstalledOpenLimitLift\n");
            uint16_t value;
            value = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::InstalledOpenLimitLift::Id, value);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : 3b: reads back the RO optional attribute: InstalledOpenLimitLift\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledOpenLimitLift::Id);
        }
        case 31: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 31 : 2: read the RO optional attribute default: InstalledClosedLimitLift\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledClosedLimitLift::Id);
        }
        case 32: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 32 : 3a: write a value into the RO optional attribute: InstalledClosedLimitLift\n");
            uint16_t value;
            value = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::InstalledClosedLimitLift::Id, value);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : 3b: reads back the RO optional attribute: InstalledClosedLimitLift\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledClosedLimitLift::Id);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : 2: read the RO optional attribute default: InstalledOpenLimitTilt\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledOpenLimitTilt::Id);
        }
        case 35: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 35 : 3a: write a value into the RO optional attribute: InstalledOpenLimitTilt\n");
            uint16_t value;
            value = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::InstalledOpenLimitTilt::Id, value);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : 3b: reads back the RO optional attribute: InstalledOpenLimitTilt\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledOpenLimitTilt::Id);
        }
        case 37: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 37 : 2: read the RO optional attribute default: InstalledClosedLimitTilt\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledClosedLimitTilt::Id);
        }
        case 38: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 38 : 3a: write a value into the RO optional attribute: InstalledClosedLimitTilt\n");
            uint16_t value;
            value = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::InstalledClosedLimitTilt::Id, value);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : 3b: reads back the RO optional attribute: InstalledClosedLimitTilt\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledClosedLimitTilt::Id);
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : 4: read the RO mandatory attribute default: SafetyStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::SafetyStatus::Id);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : 5a: write a value into the RO mandatory attribute: SafetyStatus\n");
            uint16_t value;
            value = 4096U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::SafetyStatus::Id,
                                  value);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : 5b: reads back the RO mandatory attribute: SafetyStatus\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::SafetyStatus::Id);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : 4: read the RO optional attribute default: CurrentPositionLift\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLift::Id);
        }
        case 44: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 44 : 5a: write a value into the RO optional attribute: CurrentPositionLift\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionLift::Id, value);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : 5b: reads back the RO optional attribute: CurrentPositionLift\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLift::Id);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : 4: read the RO optional attribute default: CurrentPositionTilt\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTilt::Id);
        }
        case 47: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 47 : 5a: write a value into the RO optional attribute: CurrentPositionTilt\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionTilt::Id, value);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : 5b: reads back the RO optional attribute: CurrentPositionTilt\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTilt::Id);
        }
        case 49: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 49 : 4: read the RO optional attribute default: CurrentPositionLiftPercentage\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 50: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 50 : 5a: write a value into the RO optional attribute: CurrentPositionLiftPercentage\n");
            chip::app::DataModel::Nullable<chip::Percent> value;
            value.SetNonNull();
            value.Value() = 200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionLiftPercentage::Id, value);
        }
        case 51: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 51 : 5b: reads back the RO optional attribute: CurrentPositionLiftPercentage\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 52: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 52 : 4: read the RO optional attribute default: CurrentPositionTiltPercentage\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 53: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 53 : 5a: write a value into the RO optional attribute: CurrentPositionTiltPercentage\n");
            chip::app::DataModel::Nullable<chip::Percent> value;
            value.SetNonNull();
            value.Value() = 200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionTiltPercentage::Id, value);
        }
        case 54: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 54 : 5b: reads back the RO optional attribute: CurrentPositionTiltPercentage\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 9));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 250));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 63));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 128));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 63));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 128));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 23));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 250));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 15));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("mode", value, 8));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 20000U));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 20000U));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 20000U));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 20000U));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 2047U));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 4096U));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65535U));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 100));
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 200));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 100));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 200));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_2_2Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_2_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Type attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_TYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads Type attribute constraints\n");
            VerifyOrdo(!ShouldSkip("A_TYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("type", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 9));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_2_5Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads EndProductType attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENDPRODUCTTYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::EndProductType::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads EndProductType attribute constraints from DUT\n");
            VerifyOrdo(!ShouldSkip("A_ENDPRODUCTTYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::EndProductType::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("endProductType", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 23));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_3_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 24;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 1 : 1a: TH sends DownOrClose command to preposition the DUT in the opposite direction\n");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: TH Waits for 10 seconds movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(10000);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : 1c: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 4: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 4 : 1d: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 5: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 1e: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 6: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : 1f: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                      WindowCovering::Attributes::OperationalStatus::Id, 4, 5);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : 2a: TH sends UpOrOpen command to DUT\n");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : 2b: DUT updates its attributes\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 10: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : 2c: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : 2e: TH leave the device moving for 2 seconds\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 12: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : 3a1: Verify DUT reports OperationalStatus attribute to TH after a UpOrOpen\n");
            return WaitForReport();
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : 3a2: DUT updates its attributes\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 14: {
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 15: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 15 : 3c: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 16: {
            ChipLogProgress(
                chipTool, " ***** Test Step 16 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 17: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : 3e: If (PA & LF) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : 4a: TH sends a StopMotion command to DUT\n");
            chip::app::Clusters::WindowCovering::Commands::StopMotion::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id, value);
        }
        case 19: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : 4b: TH waits for 3 seconds the end of inertial movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 20: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 20 : 4c: Verify DUT update OperationalStatus attribute to TH after a StopMotion\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : 5a: TH waits for x seconds attributes update on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 22: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 22 : 5b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 23: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 23 : 5c: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 100));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 100));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("targetPositionLiftPercent100ths.Value()", value.Value(), 0U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 5));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 21));
            }
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 9999U));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 99));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 9999U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 99));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 9999U));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 9999U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_3_2Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 24;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(
                chipTool, " ***** Test Step 1 : 1a: TH sends UpOrOpen command to preposition the DUT in the opposite direction\n");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: TH Waits for 10 seconds movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(10000);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : 1c: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 4: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 4 : 1d: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 5: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 1e: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 6: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : 1f: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                      WindowCovering::Attributes::OperationalStatus::Id, 4, 5);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : 2a: TH sends DownOrClose command to DUT\n");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : 2b: DUT updates its attributes\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 10: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : 2c: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : 2e: TH leave the device moving for 2 seconds\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 12: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : 3a: Verify DUT reports OperationalStatus attribute to TH after a DownOrClose\n");
            return WaitForReport();
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : 3a2: DUT updates its attributes\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 14: {
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 15: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 15 : 3c: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 16: {
            ChipLogProgress(
                chipTool, " ***** Test Step 16 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 17: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : 3e: If (PA & LF) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : 4a: TH sends a StopMotion command to DUT\n");
            chip::app::Clusters::WindowCovering::Commands::StopMotion::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id, value);
        }
        case 19: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : 4b: TH waits for 3 seconds the end of inertial movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 20: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 20 : 4c: Verify DUT update OperationalStatus attribute to TH after a StopMotion\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : 5a: TH waits for x seconds attributes update on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 22: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 22 : 5b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 23: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 23 : 5c: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 9999U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 99));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 9999U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 99));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("targetPositionLiftPercent100ths.Value()", value.Value(), 10000U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 10));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 42));
            }
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 100));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 100));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_3_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_3_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 15;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionLift;
    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionTilt;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 1 : 1a: TH sends DownOrClose command to preposition the DUT in the opposite direction\n");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: TH Waits for 6-8 seconds movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(6000);
        }
        case 3: {
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : 1c: TH sends UpOrOpen command to preposition the DUT in the opposite direction\n");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : 1d: TH Waits for 2 seconds movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                      WindowCovering::Attributes::OperationalStatus::Id, 4, 5);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : 2a: TH sends a StopMotion command to DUT\n");
            chip::app::Clusters::WindowCovering::Commands::StopMotion::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : 2b: TH waits for 3 seconds the end of inertial movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 8: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : 2c: Verify DUT reports OperationalStatus attribute to TH after a StopMotion\n");
            return WaitForReport();
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : 2d: TH waits for 100ms - 3s attributes update on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : 2e: TH reads OperationalStatus attribute from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 11: {
            ChipLogProgress(
                chipTool, " ***** Test Step 11 : 3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 12: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : 3b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute 3c: it Must "
                            "be equal with CurrentPositionLiftPercent100ths from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 13: {
            ChipLogProgress(
                chipTool, " ***** Test Step 13 : 4a: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 14: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 14 : 4b: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute 4c: it Must "
                            "be equal with CurrentPositionTiltPercent100ths from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
                attrCurrentPositionLift = value;
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                if (attrCurrentPositionLift.IsNull())
                {
                    VerifyOrReturn(CheckValueNull("targetPositionLiftPercent100ths", value));
                }
                else
                {
                    VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", value));
                    VerifyOrReturn(
                        CheckValue("targetPositionLiftPercent100ths.Value()", value.Value(), attrCurrentPositionLift.Value()));
                }
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
                attrCurrentPositionTilt = value;
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                if (attrCurrentPositionTilt.IsNull())
                {
                    VerifyOrReturn(CheckValueNull("targetPositionTiltPercent100ths", value));
                }
                else
                {
                    VerifyOrReturn(CheckValueNonNull("targetPositionTiltPercent100ths", value));
                    VerifyOrReturn(
                        CheckValue("targetPositionTiltPercent100ths.Value()", value.Value(), attrCurrentPositionTilt.Value()));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_3_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fastMotionDuration", 0, UINT16_MAX, &mFastMotionDuration);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
    }

    ~Test_TC_WNCV_3_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFastMotionDuration;
    chip::Optional<uint16_t> mFullMotionDuration;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 1 : 1a: TH sends DownOrClose command to preposition the DUT in the opposite direction\n");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : 1b: TH Waits for fastMotionDuration seconds movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFastMotionDuration.HasValue() ? mFastMotionDuration.Value() : 3000U);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2a: TH sends UpOrOpen command to DUT\n");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : 2b: TH Waits for fullMotionDuration seconds movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 5: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 6: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 7: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : 3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 8: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("currentPositionLiftPercent100ths.Value()", value.Value(), 0U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercentage", value));
                VerifyOrReturn(CheckValue("currentPositionLiftPercentage.Value()", value.Value(), 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercent100ths", value));
                VerifyOrReturn(CheckValue("currentPositionTiltPercent100ths.Value()", value.Value(), 0U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercentage", value));
                VerifyOrReturn(CheckValue("currentPositionTiltPercentage.Value()", value.Value(), 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_3_5Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fastMotionDuration", 0, UINT16_MAX, &mFastMotionDuration);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
    }

    ~Test_TC_WNCV_3_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFastMotionDuration;
    chip::Optional<uint16_t> mFullMotionDuration;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(
                chipTool, " ***** Test Step 1 : 1a: TH sends UpOrOpen command to preposition the DUT in the opposite direction\n");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : 1b: TH Waits for fastMotionDuration seconds movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFastMotionDuration.HasValue() ? mFastMotionDuration.Value() : 3000U);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2a: TH sends DownOrClose command to DUT\n");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : 2b: TH Waits for fullMotionDuration seconds movement(s) on the device\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 5: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 6: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 7: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : 3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 8: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("currentPositionLiftPercent100ths.Value()", value.Value(), 10000U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercentage", value));
                VerifyOrReturn(CheckValue("currentPositionLiftPercentage.Value()", value.Value(), 100));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercent100ths", value));
                VerifyOrReturn(CheckValue("currentPositionTiltPercent100ths.Value()", value.Value(), 10000U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercentage", value));
                VerifyOrReturn(CheckValue("currentPositionTiltPercentage.Value()", value.Value(), 100));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_4_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_4_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_4_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_4_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_4_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionLiftPercent100ths;
    chip::app::DataModel::Nullable<chip::Percent> attrCurrentPositionLiftPercentage;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : 1a: If (PA_LF & LF) TH reads CurrentPositionLiftPercent100ths from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: If (PA_LF & LF) TH reads CurrentPositionLiftPercentage from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2b: TH sends GoToLiftPercentage command with BadParam to DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue    = 63;
            value.liftPercent100thsValue = 12288U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : 3a: TH sends GoToLiftPercentage command with 10001 to DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue    = 100;
            value.liftPercent100thsValue = 10001U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : 4a: TH sends GoToLiftPercentage command with 0xFFFF to DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue    = 255;
            value.liftPercent100thsValue = 65535U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
                attrCurrentPositionLiftPercent100ths = value;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 100));
                attrCurrentPositionLiftPercentage = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_4_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_4_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_4_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_4_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_4_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionTiltPercent100ths;
    chip::app::DataModel::Nullable<chip::Percent> attrCurrentPositionTiltPercentage;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : 1a: If (PA_TL & TL) TH reads CurrentPositionTiltPercent100ths from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: If (PA_TL & TL) TH reads CurrentPositionTiltPercentage from DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2b: TH sends GoToTiltPercentage command with BadParam to DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue    = 63;
            value.tiltPercent100thsValue = 12288U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : 3a: TH sends GoToTiltPercentage command with 10001 to DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue    = 100;
            value.tiltPercent100thsValue = 10001U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : 4a: TH sends GoToTiltPercentage command with 0xFFFF to DUT\n");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue    = 255;
            value.tiltPercent100thsValue = 65535U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("value", value, 10000U));
                attrCurrentPositionTiltPercent100ths = value;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("value", value, 100));
                attrCurrentPositionTiltPercentage = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_TargetNavigatorClusterSuite : public TestCommand
{
public:
    TV_TargetNavigatorClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_TargetNavigatorCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_TargetNavigatorClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TargetNavigatorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TargetNavigatorCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Target Navigator list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id, TargetNavigator::Attributes::TargetList::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute current navigator target\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id,
                                 TargetNavigator::Attributes::CurrentTarget::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Navigate Target Request Command\n");
            chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type value;
            value.target = 1;
            value.data.Emplace();
            value.data.Value() = chip::Span<const char>("1garbage: not in length on purpose", 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id, TargetNavigator::Commands::NavigateTarget::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("targetList", iter_0, 0));
                    VerifyOrReturn(CheckValue("targetList[0].identifier", iter_0.GetValue().identifier, 1));
                    VerifyOrReturn(
                        CheckValueAsString("targetList[0].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("targetList", iter_0, 1));
                    VerifyOrReturn(CheckValue("targetList[1].identifier", iter_0.GetValue().identifier, 2));
                    VerifyOrReturn(
                        CheckValueAsString("targetList[1].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("targetList", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentTarget", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_AudioOutputClusterSuite : public TestCommand
{
public:
    TV_AudioOutputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_AudioOutputCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_AudioOutputClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AudioOutputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AudioOutputCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Audio Output list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Attributes::OutputList::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute current audio output\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Attributes::CurrentOutput::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Select Output Command\n");
            chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type value;
            value.index = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Commands::SelectOutput::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Rename Output Command\n");
            chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type value;
            value.index = 1;
            value.name  = chip::Span<const char>("exampleNamegarbage: not in length on purpose", 11);
            return SendCommand(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Commands::RenameOutput::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 0));
                    VerifyOrReturn(CheckValue("outputList[0].index", iter_0.GetValue().index, 1));
                    VerifyOrReturn(CheckValue("outputList[0].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(
                        CheckValueAsString("outputList[0].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 1));
                    VerifyOrReturn(CheckValue("outputList[1].index", iter_0.GetValue().index, 2));
                    VerifyOrReturn(CheckValue("outputList[1].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(
                        CheckValueAsString("outputList[1].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 2));
                    VerifyOrReturn(CheckValue("outputList[2].index", iter_0.GetValue().index, 3));
                    VerifyOrReturn(CheckValue("outputList[2].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(
                        CheckValueAsString("outputList[2].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("outputList", iter_0, 3));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentOutput", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_ApplicationLauncherClusterSuite : public TestCommand
{
public:
    TV_ApplicationLauncherClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ApplicationLauncherCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_ApplicationLauncherClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationLauncherCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationLauncherCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Application Launcher list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id,
                                 ApplicationLauncher::Attributes::CatalogList::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Launch App Command\n");
            chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type value;

            value.application.catalogVendorId = 123U;
            value.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

            value.data.Emplace();
            value.data.Value() = chip::ByteSpan(chip::Uint8::from_const_char("datagarbage: not in length on purpose"), 4);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id,
                               ApplicationLauncher::Commands::LaunchApp::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Stop App Command\n");
            chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type value;

            value.application.catalogVendorId = 123U;
            value.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id, ApplicationLauncher::Commands::StopApp::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Hide App Command\n");
            chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type value;

            value.application.catalogVendorId = 123U;
            value.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id, ApplicationLauncher::Commands::HideApp::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("catalogList", iter_0, 0));
                    VerifyOrReturn(CheckValue("catalogList[0]", iter_0.GetValue(), 123U));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("catalogList", iter_0, 1));
                    VerifyOrReturn(CheckValue("catalogList[1]", iter_0.GetValue(), 456U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("catalogList", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueAsString("data", value.data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueAsString("data", value.data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueAsString("data", value.data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_KeypadInputClusterSuite : public TestCommand
{
public:
    TV_KeypadInputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_KeypadInputCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_KeypadInputClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_KeypadInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_KeypadInputCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Key Command\n");
            chip::app::Clusters::KeypadInput::Commands::SendKey::Type value;
            value.keyCode = static_cast<chip::app::Clusters::KeypadInput::CecKeyCode>(3);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), KeypadInput::Id, KeypadInput::Commands::SendKey::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_AccountLoginClusterSuite : public TestCommand
{
public:
    TV_AccountLoginClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_AccountLoginCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_AccountLoginClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AccountLoginCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AccountLoginCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Get Setup PIN Command\n");
            chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type value;
            value.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);
            return SendCommand(kIdentityAlpha, GetEndpoint(3), AccountLogin::Id, AccountLogin::Commands::GetSetupPIN::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Login Command\n");
            chip::app::Clusters::AccountLogin::Commands::Login::Type value;
            value.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);
            value.setupPIN              = chip::Span<const char>("tempPin123garbage: not in length on purpose", 10);
            return SendCommand(kIdentityAlpha, GetEndpoint(3), AccountLogin::Id, AccountLogin::Commands::Login::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Logout Command\n");
            chip::app::Clusters::AccountLogin::Commands::Logout::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), AccountLogin::Id, AccountLogin::Commands::Logout::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("setupPIN", value.setupPIN, chip::CharSpan("tempPin123", 10)));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_WakeOnLanClusterSuite : public TestCommand
{
public:
    TV_WakeOnLanClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TV_WakeOnLanCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_WakeOnLanClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_WakeOnLanCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_WakeOnLanCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mac address\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WakeOnLan::Id, WakeOnLan::Attributes::MACAddress::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("MACAddress", value, chip::CharSpan("00:00:00:00:00", 14)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_ApplicationBasicClusterSuite : public TestCommand
{
public:
    TV_ApplicationBasicClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ApplicationBasicCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_ApplicationBasicClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationBasicCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationBasicCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute vendor name\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::VendorName::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute vendor id\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id, ApplicationBasic::Attributes::VendorID::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute application name\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ApplicationName::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute product id\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id, ApplicationBasic::Attributes::ProductID::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read attribute application status\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id, ApplicationBasic::Attributes::Status::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute application version\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ApplicationVersion::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("vendorName", value, chip::CharSpan("exampleVendorName1", 18)));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorID", value, 1U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("applicationName", value, chip::CharSpan("exampleName1", 12)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("productID", value, 1U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("applicationVersion", value, chip::CharSpan("exampleVersion", 14)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_MediaPlaybackClusterSuite : public TestCommand
{
public:
    TV_MediaPlaybackClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_MediaPlaybackCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_MediaPlaybackClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaPlaybackCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaPlaybackCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 18;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute playback state\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute start time\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::StartTime::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute duration\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::Duration::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute playback speed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::PlaybackSpeed::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read attribute seek range end\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::SeekRangeEnd::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute seek range start\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::SeekRangeStart::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Media Playback Play Command\n");
            chip::app::Clusters::MediaPlayback::Commands::Play::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Play::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Media Playback Pause Command\n");
            chip::app::Clusters::MediaPlayback::Commands::Pause::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Pause::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Media Playback Stop Command\n");
            chip::app::Clusters::MediaPlayback::Commands::StopPlayback::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::StopPlayback::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Media Playback Start Over Command\n");
            chip::app::Clusters::MediaPlayback::Commands::StartOver::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::StartOver::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Media Playback Previous Command\n");
            chip::app::Clusters::MediaPlayback::Commands::Previous::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Previous::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Media Playback Next Command\n");
            chip::app::Clusters::MediaPlayback::Commands::Next::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Next::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Media Playback Rewind Command\n");
            chip::app::Clusters::MediaPlayback::Commands::Rewind::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Rewind::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Media Playback Fast Forward Command\n");
            chip::app::Clusters::MediaPlayback::Commands::FastForward::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::FastForward::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Media Playback Skip Forward Command\n");
            chip::app::Clusters::MediaPlayback::Commands::SkipForward::Type value;
            value.deltaPositionMilliseconds = 100ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::SkipForward::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Media Playback Skip Backward Command\n");
            chip::app::Clusters::MediaPlayback::Commands::SkipBackward::Type value;
            value.deltaPositionMilliseconds = 100ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::SkipBackward::Id, value);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Media Playback Seek Command\n");
            chip::app::Clusters::MediaPlayback::Commands::Seek::Type value;
            value.position = 100ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Seek::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("startTime", value));
                VerifyOrReturn(CheckValue("startTime.Value()", value.Value(), 0ULL));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("duration", value));
                VerifyOrReturn(CheckValue("duration.Value()", value.Value(), 0ULL));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("playbackSpeed", value, 0.0f));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("seekRangeEnd", value));
                VerifyOrReturn(CheckValue("seekRangeEnd.Value()", value.Value(), 0ULL));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("seekRangeStart", value));
                VerifyOrReturn(CheckValue("seekRangeStart.Value()", value.Value(), 0ULL));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_ChannelClusterSuite : public TestCommand
{
public:
    TV_ChannelClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TV_ChannelCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_ChannelClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ChannelCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ChannelCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Channel list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::ChannelList::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Change Channel Command\n");
            chip::app::Clusters::Channel::Commands::ChangeChannel::Type value;
            value.match = chip::Span<const char>("CNNgarbage: not in length on purpose", 3);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Commands::ChangeChannel::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Change Channel By Number Command\n");
            chip::app::Clusters::Channel::Commands::ChangeChannelByNumber::Type value;
            value.majorNumber = 1U;
            value.minorNumber = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Commands::ChangeChannelByNumber::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Skip Channel Command\n");
            chip::app::Clusters::Channel::Commands::SkipChannel::Type value;
            value.count = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Commands::SkipChannel::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("channelList", iter_0, 0));
                    VerifyOrReturn(CheckValue("channelList[0].majorNumber", iter_0.GetValue().majorNumber, 1U));
                    VerifyOrReturn(CheckValue("channelList[0].minorNumber", iter_0.GetValue().minorNumber, 2U));
                    VerifyOrReturn(CheckValuePresent("channelList[0].name", iter_0.GetValue().name));
                    VerifyOrReturn(CheckValueAsString("channelList[0].name.Value()", iter_0.GetValue().name.Value(),
                                                      chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckValuePresent("channelList[0].callSign", iter_0.GetValue().callSign));
                    VerifyOrReturn(CheckValueAsString("channelList[0].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                                      chip::CharSpan("exampleCSign", 12)));
                    VerifyOrReturn(CheckValuePresent("channelList[0].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
                    VerifyOrReturn(CheckValueAsString("channelList[0].affiliateCallSign.Value()",
                                                      iter_0.GetValue().affiliateCallSign.Value(),
                                                      chip::CharSpan("exampleASign", 12)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("channelList", iter_0, 1));
                    VerifyOrReturn(CheckValue("channelList[1].majorNumber", iter_0.GetValue().majorNumber, 2U));
                    VerifyOrReturn(CheckValue("channelList[1].minorNumber", iter_0.GetValue().minorNumber, 3U));
                    VerifyOrReturn(CheckValuePresent("channelList[1].name", iter_0.GetValue().name));
                    VerifyOrReturn(CheckValueAsString("channelList[1].name.Value()", iter_0.GetValue().name.Value(),
                                                      chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckValuePresent("channelList[1].callSign", iter_0.GetValue().callSign));
                    VerifyOrReturn(CheckValueAsString("channelList[1].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                                      chip::CharSpan("exampleCSign", 12)));
                    VerifyOrReturn(CheckValuePresent("channelList[1].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
                    VerifyOrReturn(CheckValueAsString("channelList[1].affiliateCallSign.Value()",
                                                      iter_0.GetValue().affiliateCallSign.Value(),
                                                      chip::CharSpan("exampleASign", 12)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("channelList", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Channel::Commands::ChangeChannelResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("channelMatch.majorNumber", value.channelMatch.majorNumber, 1U));
                VerifyOrReturn(CheckValue("channelMatch.minorNumber", value.channelMatch.minorNumber, 0U));
                VerifyOrReturn(CheckValuePresent("channelMatch.name", value.channelMatch.name));
                VerifyOrReturn(
                    CheckValueAsString("channelMatch.name.Value()", value.channelMatch.name.Value(), chip::CharSpan("name", 4)));
                VerifyOrReturn(CheckValuePresent("channelMatch.callSign", value.channelMatch.callSign));
                VerifyOrReturn(CheckValueAsString("channelMatch.callSign.Value()", value.channelMatch.callSign.Value(),
                                                  chip::CharSpan("callSign", 8)));
                VerifyOrReturn(CheckValuePresent("channelMatch.affiliateCallSign", value.channelMatch.affiliateCallSign));
                VerifyOrReturn(CheckValueAsString("channelMatch.affiliateCallSign.Value()",
                                                  value.channelMatch.affiliateCallSign.Value(),
                                                  chip::CharSpan("affiliateCallSign", 17)));
                VerifyOrReturn(CheckValue("errorType", value.errorType, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_LowPowerClusterSuite : public TestCommand
{
public:
    TV_LowPowerClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TV_LowPowerCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_LowPowerClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_LowPowerCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_LowPowerCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sleep Input Status Command\n");
            chip::app::Clusters::LowPower::Commands::Sleep::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LowPower::Id, LowPower::Commands::Sleep::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_ContentLauncherClusterSuite : public TestCommand
{
public:
    TV_ContentLauncherClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ContentLauncherCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_ContentLauncherClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ContentLauncherCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ContentLauncherCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute accept header list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::AcceptHeader::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute supported streaming protocols\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::SupportedStreamingProtocols::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Launch Content Command\n");
            ListFreer listFreer;
            chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type value;

            {
                auto * listHolder_1 = new ListHolder<chip::app::Clusters::ContentLauncher::Structs::Parameter::Type>(1);
                listFreer.add(listHolder_1);

                listHolder_1->mList[0].type  = static_cast<chip::app::Clusters::ContentLauncher::ParameterEnum>(1);
                listHolder_1->mList[0].value = chip::Span<const char>("exampleValuegarbage: not in length on purpose", 12);
                listHolder_1->mList[0].externalIDList.Emplace();

                {
                    auto * listHolder_4 = new ListHolder<chip::app::Clusters::ContentLauncher::Structs::AdditionalInfo::Type>(1);
                    listFreer.add(listHolder_4);

                    listHolder_4->mList[0].name  = chip::Span<const char>("namegarbage: not in length on purpose", 4);
                    listHolder_4->mList[0].value = chip::Span<const char>("valuegarbage: not in length on purpose", 5);

                    listHolder_1->mList[0].externalIDList.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::ContentLauncher::Structs::AdditionalInfo::Type>(
                            listHolder_4->mList, 1);
                }

                value.search.parameterList =
                    chip::app::DataModel::List<chip::app::Clusters::ContentLauncher::Structs::Parameter::Type>(listHolder_1->mList,
                                                                                                               1);
            }

            value.autoPlay = true;
            value.data.Emplace();
            value.data.Value() = chip::Span<const char>("exampleDatagarbage: not in length on purpose", 11);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id, ContentLauncher::Commands::LaunchContent::Id,
                               value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Launch URL Command\n");
            chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type value;
            value.contentURL = chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.displayString.Emplace();
            value.displayString.Value() = chip::Span<const char>("exampleDisplayStringgarbage: not in length on purpose", 20);
            value.brandingInformation.Emplace();

            value.brandingInformation.Value().providerName =
                chip::Span<const char>("exampleNamegarbage: not in length on purpose", 11);
            value.brandingInformation.Value().background.Emplace();

            value.brandingInformation.Value().background.Value().imageUrl.Emplace();
            value.brandingInformation.Value().background.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().background.Value().color.Emplace();
            value.brandingInformation.Value().background.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().background.Value().size.Emplace();

            value.brandingInformation.Value().background.Value().size.Value().width  = 0;
            value.brandingInformation.Value().background.Value().size.Value().height = 0;
            value.brandingInformation.Value().background.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            value.brandingInformation.Value().logo.Emplace();

            value.brandingInformation.Value().logo.Value().imageUrl.Emplace();
            value.brandingInformation.Value().logo.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().logo.Value().color.Emplace();
            value.brandingInformation.Value().logo.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().logo.Value().size.Emplace();

            value.brandingInformation.Value().logo.Value().size.Value().width  = 0;
            value.brandingInformation.Value().logo.Value().size.Value().height = 0;
            value.brandingInformation.Value().logo.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            value.brandingInformation.Value().progressBar.Emplace();

            value.brandingInformation.Value().progressBar.Value().imageUrl.Emplace();
            value.brandingInformation.Value().progressBar.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().progressBar.Value().color.Emplace();
            value.brandingInformation.Value().progressBar.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().progressBar.Value().size.Emplace();

            value.brandingInformation.Value().progressBar.Value().size.Value().width  = 0;
            value.brandingInformation.Value().progressBar.Value().size.Value().height = 0;
            value.brandingInformation.Value().progressBar.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            value.brandingInformation.Value().splash.Emplace();

            value.brandingInformation.Value().splash.Value().imageUrl.Emplace();
            value.brandingInformation.Value().splash.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().splash.Value().color.Emplace();
            value.brandingInformation.Value().splash.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().splash.Value().size.Emplace();

            value.brandingInformation.Value().splash.Value().size.Value().width  = 0;
            value.brandingInformation.Value().splash.Value().size.Value().height = 0;
            value.brandingInformation.Value().splash.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            value.brandingInformation.Value().waterMark.Emplace();

            value.brandingInformation.Value().waterMark.Value().imageUrl.Emplace();
            value.brandingInformation.Value().waterMark.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().waterMark.Value().color.Emplace();
            value.brandingInformation.Value().waterMark.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().waterMark.Value().size.Emplace();

            value.brandingInformation.Value().waterMark.Value().size.Value().width  = 0;
            value.brandingInformation.Value().waterMark.Value().size.Value().height = 0;
            value.brandingInformation.Value().waterMark.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id, ContentLauncher::Commands::LaunchURL::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptHeader", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("acceptHeader[0]", iter_0.GetValue(), chip::CharSpan("example", 7)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptHeader", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString("acceptHeader[1]", iter_0.GetValue(), chip::CharSpan("example", 7)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acceptHeader", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("supportedStreamingProtocols", value, 0UL));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ContentLauncher::Commands::LaunchResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("exampleData", 11)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ContentLauncher::Commands::LaunchResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("exampleData", 11)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TV_MediaInputClusterSuite : public TestCommand
{
public:
    TV_MediaInputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TV_MediaInputCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_MediaInputClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaInputCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute media input list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::InputList::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read current media input\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::CurrentInput::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Select Input Command\n");
            chip::app::Clusters::MediaInput::Commands::SelectInput::Type value;
            value.index = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Commands::SelectInput::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Hide Input Status Command\n");
            chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Commands::HideInputStatus::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Show Input Status Command\n");
            chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Commands::ShowInputStatus::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Rename Input Command\n");
            chip::app::Clusters::MediaInput::Commands::RenameInput::Type value;
            value.index = 1;
            value.name  = chip::Span<const char>("newNamegarbage: not in length on purpose", 7);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Commands::RenameInput::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("inputList", iter_0, 0));
                    VerifyOrReturn(CheckValue("inputList[0].index", iter_0.GetValue().index, 1));
                    VerifyOrReturn(CheckValue("inputList[0].inputType", iter_0.GetValue().inputType, 4));
                    VerifyOrReturn(
                        CheckValueAsString("inputList[0].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckValueAsString("inputList[0].description", iter_0.GetValue().description,
                                                      chip::CharSpan("exampleDescription", 18)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("inputList", iter_0, 1));
                    VerifyOrReturn(CheckValue("inputList[1].index", iter_0.GetValue().index, 2));
                    VerifyOrReturn(CheckValue("inputList[1].inputType", iter_0.GetValue().inputType, 4));
                    VerifyOrReturn(
                        CheckValueAsString("inputList[1].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckValueAsString("inputList[1].description", iter_0.GetValue().description,
                                                      chip::CharSpan("exampleDescription", 18)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("inputList", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentInput", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestClusterSuite : public TestCommand
{
public:
    TestClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 481;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command\n");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::Test::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Not Handled Command\n");
            chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestNotHandled::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Specific Command\n");
            chip::app::Clusters::TestCluster::Commands::TestSpecific::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestSpecific::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Test Add Arguments Command\n");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = 17;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send failing Test Add Arguments Command\n");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 250;
            value.arg2 = 6;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute BOOLEAN Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute BOOLEAN True\n");
            bool value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute BOOLEAN True\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write attribute BOOLEAN False\n");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute BOOLEAN False\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute BITMAP8 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute BITMAP8 Max Value\n");
            uint8_t value;
            value = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute BITMAP8 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Write attribute BITMAP8 Min Value\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute BITMAP8 Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute BITMAP16 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute BITMAP16 Max Value\n");
            uint16_t value;
            value = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id, value);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute BITMAP16 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Write attribute BITMAP16 Min Value\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id, value);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute BITMAP16 Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute BITMAP32 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Write attribute BITMAP32 Max Value\n");
            uint32_t value;
            value = 4294967295UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id, value);
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read attribute BITMAP32 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : Write attribute BITMAP32 Min Value\n");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id, value);
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read attribute BITMAP32 Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute BITMAP64 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute BITMAP64 Max Value\n");
            uint64_t value;
            value = 18446744073709551615ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id, value);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute BITMAP64 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : Write attribute BITMAP64 Min Value\n");
            uint64_t value;
            value = 0ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id, value);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read attribute BITMAP64 Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read attribute INT8U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : Write attribute INT8U Max Value\n");
            uint8_t value;
            value = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id, value);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read attribute INT8U Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : Write attribute INT8U Min Value\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id, value);
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read attribute INT8U Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute INT16U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute INT16U Max Value\n");
            uint16_t value;
            value = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id, value);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute INT16U Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : Write attribute INT16U Min Value\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id, value);
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read attribute INT16U Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read attribute INT32U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : Write attribute INT32U Max Value\n");
            uint32_t value;
            value = 4294967295UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read attribute INT32U Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : Write attribute INT32U Min Value\n");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read attribute INT32U Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute INT64U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute INT64U Max Value\n");
            uint64_t value;
            value = 18446744073709551615ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id, value);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute INT64U Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : Write attribute INT64U Min Value\n");
            uint64_t value;
            value = 0ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id, value);
        }
        case 50: {
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read attribute INT64U Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 51: {
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read attribute INT8S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 52: {
            ChipLogProgress(chipTool, " ***** Test Step 52 : Write attribute INT8S Max Value\n");
            int8_t value;
            value = 127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 53: {
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read attribute INT8S Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 54: {
            ChipLogProgress(chipTool, " ***** Test Step 54 : Write attribute INT8S Min Value\n");
            int8_t value;
            value = -128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 55: {
            ChipLogProgress(chipTool, " ***** Test Step 55 : Read attribute INT8S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 56: {
            ChipLogProgress(chipTool, " ***** Test Step 56 : Write attribute INT8S Default Value\n");
            int8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 57: {
            ChipLogProgress(chipTool, " ***** Test Step 57 : Read attribute INT8S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 58: {
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute INT16S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 59: {
            ChipLogProgress(chipTool, " ***** Test Step 59 : Write attribute INT16S Max Value\n");
            int16_t value;
            value = 32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 60: {
            ChipLogProgress(chipTool, " ***** Test Step 60 : Read attribute INT16S Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 61: {
            ChipLogProgress(chipTool, " ***** Test Step 61 : Write attribute INT16S Min Value\n");
            int16_t value;
            value = -32768;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 62: {
            ChipLogProgress(chipTool, " ***** Test Step 62 : Read attribute INT16S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 63: {
            ChipLogProgress(chipTool, " ***** Test Step 63 : Write attribute INT16S Default Value\n");
            int16_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 64: {
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT16S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 65: {
            ChipLogProgress(chipTool, " ***** Test Step 65 : Read attribute INT32S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 66: {
            ChipLogProgress(chipTool, " ***** Test Step 66 : Write attribute INT32S Max Value\n");
            int32_t value;
            value = 2147483647L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 67: {
            ChipLogProgress(chipTool, " ***** Test Step 67 : Read attribute INT32S Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 68: {
            ChipLogProgress(chipTool, " ***** Test Step 68 : Write attribute INT32S Min Value\n");
            int32_t value;
            value = -2147483648L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 69: {
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read attribute INT32S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 70: {
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write attribute INT32S Default Value\n");
            int32_t value;
            value = 0L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 71: {
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute INT32S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 72: {
            ChipLogProgress(chipTool, " ***** Test Step 72 : Read attribute INT64S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 73: {
            ChipLogProgress(chipTool, " ***** Test Step 73 : Write attribute INT64S Max Value\n");
            int64_t value;
            value = 9223372036854775807LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 74: {
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute INT64S Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 75: {
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute INT64S Min Value\n");
            int64_t value;
            value = -9223372036854775807LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 76: {
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute INT64S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 77: {
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute INT64S Default Value\n");
            int64_t value;
            value = 0LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 78: {
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute INT64S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 79: {
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read attribute SINGLE Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 80: {
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write attribute SINGLE medium Value\n");
            float value;
            value = 0.1f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id, value);
        }
        case 81: {
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read attribute SINGLE medium Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 82: {
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write attribute SINGLE large Value\n");
            float value;
            value = 17000000000.0f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id, value);
        }
        case 83: {
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute SINGLE large Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 84: {
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write attribute SINGLE small Value\n");
            float value;
            value = 1.7e-10f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id, value);
        }
        case 85: {
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read attribute SINGLE small Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 86: {
            ChipLogProgress(chipTool, " ***** Test Step 86 : Write attribute SINGLE Default Value\n");
            float value;
            value = 0.0f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id, value);
        }
        case 87: {
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read attribute SINGLE Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 88: {
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute DOUBLE Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 89: {
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write attribute DOUBLE medium Value\n");
            double value;
            value = 0.1234567890123;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id, value);
        }
        case 90: {
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read attribute DOUBLE medium Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 91: {
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write attribute DOUBLE large Value\n");
            double value;
            value = 1.7e+200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id, value);
        }
        case 92: {
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read attribute DOUBLE large Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 93: {
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write attribute DOUBLE small Value\n");
            double value;
            value = 1.7e-200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id, value);
        }
        case 94: {
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute DOUBLE small Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 95: {
            ChipLogProgress(chipTool, " ***** Test Step 95 : Write attribute DOUBLE Default Value\n");
            double value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id, value);
        }
        case 96: {
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read attribute DOUBLE Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 97: {
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read attribute ENUM8 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 98: {
            ChipLogProgress(chipTool, " ***** Test Step 98 : Write attribute ENUM8 Max Value\n");
            uint8_t value;
            value = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id, value);
        }
        case 99: {
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read attribute ENUM8 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 100: {
            ChipLogProgress(chipTool, " ***** Test Step 100 : Write attribute ENUM8 Min Value\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id, value);
        }
        case 101: {
            ChipLogProgress(chipTool, " ***** Test Step 101 : Read attribute ENUM8 Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 102: {
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute ENUM16 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 103: {
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write attribute ENUM16 Max Value\n");
            uint16_t value;
            value = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id, value);
        }
        case 104: {
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read attribute ENUM16 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 105: {
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write attribute ENUM16 Min Value\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id, value);
        }
        case 106: {
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read attribute ENUM16 Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 107: {
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read attribute OCTET_STRING Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 108: {
            ChipLogProgress(chipTool, " ***** Test Step 108 : Write attribute OCTET_STRING with embedded null\n");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("Tes\x00ti\x00nggarbage: not in length on purpose"), 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 109: {
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read attribute OCTET_STRING with embedded null\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 110: {
            ChipLogProgress(chipTool, " ***** Test Step 110 : Write attribute OCTET_STRING with weird chars\n");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("\x0d\x0a\xff\x22\xa0garbage: not in length on purpose"), 5);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 111: {
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read attribute OCTET_STRING with weird chars\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 112: {
            ChipLogProgress(chipTool, " ***** Test Step 112 : Write attribute OCTET_STRING\n");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 113: {
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read attribute OCTET_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 114: {
            ChipLogProgress(chipTool, " ***** Test Step 114 : Write attribute OCTET_STRING\n");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("TestValueLongerThan10garbage: not in length on purpose"), 21);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 115: {
            ChipLogProgress(chipTool, " ***** Test Step 115 : Read attribute OCTET_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 116: {
            ChipLogProgress(chipTool, " ***** Test Step 116 : Write attribute OCTET_STRING\n");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 117: {
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read attribute LONG_OCTET_STRING Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongOctetString::Id);
        }
        case 118: {
            ChipLogProgress(chipTool, " ***** Test Step 118 : Write attribute LONG_OCTET_STRING\n");
            chip::ByteSpan value;
            value = chip::ByteSpan(
                chip::Uint8::from_const_char("1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                                             "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                                             "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                                             "111111111111111111111111111111111111111111111garbage: not in length on purpose"),
                300);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongOctetString::Id,
                                  value);
        }
        case 119: {
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read attribute LONG_OCTET_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongOctetString::Id);
        }
        case 120: {
            ChipLogProgress(chipTool, " ***** Test Step 120 : Write attribute LONG_OCTET_STRING\n");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongOctetString::Id,
                                  value);
        }
        case 121: {
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read attribute CHAR_STRING Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 122: {
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write attribute CHAR_STRING\n");
            chip::CharSpan value;
            value = chip::Span<const char>("Tgarbage: not in length on purpose", 7);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 123: {
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read attribute CHAR_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 124: {
            ChipLogProgress(chipTool, " ***** Test Step 124 : Write attribute CHAR_STRING - Value too long\n");
            chip::CharSpan value;
            value = chip::Span<const char>("TestValueLongerThan10garbage: not in length on purpose", 27);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 125: {
            ChipLogProgress(chipTool, " ***** Test Step 125 : Read attribute CHAR_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 126: {
            ChipLogProgress(chipTool, " ***** Test Step 126 : Write attribute CHAR_STRING - Empty\n");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 127: {
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read attribute LONG_CHAR_STRING Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongCharString::Id);
        }
        case 128: {
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write attribute LONG_CHAR_STRING\n");
            chip::CharSpan value;
            value = chip::Span<const char>(
                ""
                ""
                "garbage: not in length on purpose",
                900);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongCharString::Id,
                                  value);
        }
        case 129: {
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read attribute LONG_CHAR_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongCharString::Id);
        }
        case 130: {
            ChipLogProgress(chipTool, " ***** Test Step 130 : Write attribute LONG_CHAR_STRING\n");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongCharString::Id,
                                  value);
        }
        case 131: {
            ChipLogProgress(chipTool, " ***** Test Step 131 : Read attribute LIST_LONG_OCTET_STRING (for chunked read)\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListLongOctetString::Id);
        }
        case 132: {
            ChipLogProgress(chipTool, " ***** Test Step 132 : Write attribute LIST_LONG_OCTET_STRING (for chunked write)\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::ByteSpan> value;

            {
                auto * listHolder_0 = new ListHolder<chip::ByteSpan>(5);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                listHolder_0->mList[1] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                listHolder_0->mList[2] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                listHolder_0->mList[3] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                listHolder_0->mList[4] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                value = chip::app::DataModel::List<chip::ByteSpan>(listHolder_0->mList, 5);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListLongOctetString::Id,
                                  value);
        }
        case 133: {
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read attribute LIST_LONG_OCTET_STRING (for chunked read)\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListLongOctetString::Id);
        }
        case 134: {
            ChipLogProgress(chipTool, " ***** Test Step 134 : Read attribute EPOCH_US Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 135: {
            ChipLogProgress(chipTool, " ***** Test Step 135 : Write attribute EPOCH_US Max Value\n");
            uint64_t value;
            value = 18446744073709551615ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id, value);
        }
        case 136: {
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read attribute EPOCH_US Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 137: {
            ChipLogProgress(chipTool, " ***** Test Step 137 : Write attribute EPOCH_US Min Value\n");
            uint64_t value;
            value = 0ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id, value);
        }
        case 138: {
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read attribute EPOCH_US Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 139: {
            ChipLogProgress(chipTool, " ***** Test Step 139 : Read attribute EPOCH_S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 140: {
            ChipLogProgress(chipTool, " ***** Test Step 140 : Write attribute EPOCH_S Max Value\n");
            uint32_t value;
            value = 4294967295UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id, value);
        }
        case 141: {
            ChipLogProgress(chipTool, " ***** Test Step 141 : Read attribute EPOCH_S Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 142: {
            ChipLogProgress(chipTool, " ***** Test Step 142 : Write attribute EPOCH_S Min Value\n");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id, value);
        }
        case 143: {
            ChipLogProgress(chipTool, " ***** Test Step 143 : Read attribute EPOCH_S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 144: {
            ChipLogProgress(chipTool, " ***** Test Step 144 : Read attribute UNSUPPORTED\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Unsupported::Id);
        }
        case 145: {
            ChipLogProgress(chipTool, " ***** Test Step 145 : Writeattribute UNSUPPORTED\n");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Unsupported::Id, value);
        }
        case 146: {
            ChipLogProgress(chipTool, " ***** Test Step 146 : Send Test Command to unsupported endpoint\n");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(200), TestCluster::Id, TestCluster::Commands::Test::Id, value);
        }
        case 147: {
            ChipLogProgress(chipTool, " ***** Test Step 147 : Send Test Command to unsupported cluster\n");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), TestCluster::Id, TestCluster::Commands::Test::Id, value);
        }
        case 148: {
            ChipLogProgress(chipTool, " ***** Test Step 148 : Read attribute vendor_id Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 149: {
            ChipLogProgress(chipTool, " ***** Test Step 149 : Write attribute vendor_id\n");
            chip::VendorId value;
            value = static_cast<chip::VendorId>(17);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id, value);
        }
        case 150: {
            ChipLogProgress(chipTool, " ***** Test Step 150 : Read attribute vendor_id\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 151: {
            ChipLogProgress(chipTool, " ***** Test Step 151 : Restore attribute vendor_id\n");
            chip::VendorId value;
            value = static_cast<chip::VendorId>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id, value);
        }
        case 152: {
            ChipLogProgress(chipTool, " ***** Test Step 152 : Send a command with a vendor_id and enum\n");
            chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type value;
            value.arg1 = static_cast<chip::VendorId>(20003);
            value.arg2 = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(101);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestEnumsRequest::Id, value);
        }
        case 153: {
            ChipLogProgress(chipTool, " ***** Test Step 153 : Send Test Command With Struct Argument and arg1.b is true\n");
            chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;
            value.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.g = 0.0f;
            value.arg1.h = 0;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestStructArgumentRequest::Id, value);
        }
        case 154: {
            ChipLogProgress(chipTool, " ***** Test Step 154 : Send Test Command With Struct Argument and arg1.b is false\n");
            chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = false;
            value.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.g = 0.0f;
            value.arg1.h = 0;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestStructArgumentRequest::Id, value);
        }
        case 155: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 155 : Send Test Command With Nested Struct Argument and arg1.c.b is true\n");
            chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;

            value.arg1.c.a = 0;
            value.arg1.c.b = true;
            value.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.c.g = 0.0f;
            value.arg1.c.h = 0;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNestedStructArgumentRequest::Id, value);
        }
        case 156: {
            ChipLogProgress(chipTool, " ***** Test Step 156 : Send Test Command With Nested Struct Argument arg1.c.b is false\n");
            chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;

            value.arg1.c.a = 0;
            value.arg1.c.b = false;
            value.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.c.g = 0.0f;
            value.arg1.c.h = 0;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNestedStructArgumentRequest::Id, value);
        }
        case 157: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 157 : Send Test Command With Nested Struct List Argument and all fields b of arg1.d are true\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;

            value.arg1.c.a = 0;
            value.arg1.c.b = true;
            value.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.c.g = 0.0f;
            value.arg1.c.h = 0;

            {
                auto * listHolder_1 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_1);

                listHolder_1->mList[0].a = 1;
                listHolder_1->mList[0].b = true;
                listHolder_1->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_1->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_1->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_1->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_1->mList[0].g = 0.0f;
                listHolder_1->mList[0].h = 0;

                listHolder_1->mList[1].a = 2;
                listHolder_1->mList[1].b = true;
                listHolder_1->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_1->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_1->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_1->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_1->mList[1].g = 0.0f;
                listHolder_1->mList[1].h = 0;

                value.arg1.d = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                    listHolder_1->mList, 2);
            }

            {
                auto * listHolder_1 = new ListHolder<uint32_t>(3);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] = 1UL;
                listHolder_1->mList[1] = 2UL;
                listHolder_1->mList[2] = 3UL;
                value.arg1.e           = chip::app::DataModel::List<uint32_t>(listHolder_1->mList, 3);
            }

            {
                auto * listHolder_1 = new ListHolder<chip::ByteSpan>(3);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                listHolder_1->mList[1] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                listHolder_1->mList[2] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                value.arg1.f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_1->mList, 3);
            }

            {
                auto * listHolder_1 = new ListHolder<uint8_t>(2);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] = 0;
                listHolder_1->mList[1] = 255;
                value.arg1.g           = chip::app::DataModel::List<uint8_t>(listHolder_1->mList, 2);
            }

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNestedStructListArgumentRequest::Id, value);
        }
        case 158: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 158 : Send Test Command With Nested Struct List Argument and some fields b of arg1.d "
                            "are false\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;

            value.arg1.c.a = 0;
            value.arg1.c.b = true;
            value.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.c.g = 0.0f;
            value.arg1.c.h = 0;

            {
                auto * listHolder_1 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_1);

                listHolder_1->mList[0].a = 1;
                listHolder_1->mList[0].b = true;
                listHolder_1->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_1->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_1->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_1->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_1->mList[0].g = 0.0f;
                listHolder_1->mList[0].h = 0;

                listHolder_1->mList[1].a = 2;
                listHolder_1->mList[1].b = false;
                listHolder_1->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_1->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_1->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_1->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_1->mList[1].g = 0.0f;
                listHolder_1->mList[1].h = 0;

                value.arg1.d = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                    listHolder_1->mList, 2);
            }

            {
                auto * listHolder_1 = new ListHolder<uint32_t>(3);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] = 1UL;
                listHolder_1->mList[1] = 2UL;
                listHolder_1->mList[2] = 3UL;
                value.arg1.e           = chip::app::DataModel::List<uint32_t>(listHolder_1->mList, 3);
            }

            {
                auto * listHolder_1 = new ListHolder<chip::ByteSpan>(3);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                listHolder_1->mList[1] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                listHolder_1->mList[2] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                value.arg1.f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_1->mList, 3);
            }

            {
                auto * listHolder_1 = new ListHolder<uint8_t>(2);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] = 0;
                listHolder_1->mList[1] = 255;
                value.arg1.g           = chip::app::DataModel::List<uint8_t>(listHolder_1->mList, 2);
            }

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNestedStructListArgumentRequest::Id, value);
        }
        case 159: {
            ChipLogProgress(chipTool, " ***** Test Step 159 : Send Test Command With Struct Argument and see what we get back\n");
            chip::app::Clusters::TestCluster::Commands::SimpleStructEchoRequest::Type value;

            value.arg1.a = 17;
            value.arg1.b = false;
            value.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.g = 0.1f;
            value.arg1.h = 0.1;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::SimpleStructEchoRequest::Id,
                               value);
        }
        case 160: {
            ChipLogProgress(chipTool, " ***** Test Step 160 : Send Test Command With List of INT8U and none of them is set to 0\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(9);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1;
                listHolder_0->mList[1] = 2;
                listHolder_0->mList[2] = 3;
                listHolder_0->mList[3] = 4;
                listHolder_0->mList[4] = 5;
                listHolder_0->mList[5] = 6;
                listHolder_0->mList[6] = 7;
                listHolder_0->mList[7] = 8;
                listHolder_0->mList[8] = 9;
                value.arg1             = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 9);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListInt8UArgumentRequest::Id, value);
        }
        case 161: {
            ChipLogProgress(chipTool, " ***** Test Step 161 : Send Test Command With List of INT8U and one of them is set to 0\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(10);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1;
                listHolder_0->mList[1] = 2;
                listHolder_0->mList[2] = 3;
                listHolder_0->mList[3] = 4;
                listHolder_0->mList[4] = 5;
                listHolder_0->mList[5] = 6;
                listHolder_0->mList[6] = 7;
                listHolder_0->mList[7] = 8;
                listHolder_0->mList[8] = 9;
                listHolder_0->mList[9] = 0;
                value.arg1             = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 10);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListInt8UArgumentRequest::Id, value);
        }
        case 162: {
            ChipLogProgress(chipTool, " ***** Test Step 162 : Send Test Command With List of INT8U and get it reversed\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(9);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1;
                listHolder_0->mList[1] = 2;
                listHolder_0->mList[2] = 3;
                listHolder_0->mList[3] = 4;
                listHolder_0->mList[4] = 5;
                listHolder_0->mList[5] = 6;
                listHolder_0->mList[6] = 7;
                listHolder_0->mList[7] = 8;
                listHolder_0->mList[8] = 9;
                value.arg1             = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 9);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListInt8UReverseRequest::Id, value);
        }
        case 163: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 163 : Send Test Command With empty List of INT8U and get an empty list back\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type value;

            value.arg1 = chip::app::DataModel::List<uint8_t>();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListInt8UReverseRequest::Id, value);
        }
        case 164: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 164 : Send Test Command With List of Struct Argument and arg1.b of first item is true\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].a = 0;
                listHolder_0->mList[0].b = true;
                listHolder_0->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
                listHolder_0->mList[0].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
                listHolder_0->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[0].g = 0.0f;
                listHolder_0->mList[0].h = 0;

                listHolder_0->mList[1].a = 1;
                listHolder_0->mList[1].b = true;
                listHolder_0->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_0->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_0->mList[1].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
                listHolder_0->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[1].g = 0.0f;
                listHolder_0->mList[1].h = 0;

                value.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                    listHolder_0->mList, 2);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListStructArgumentRequest::Id, value);
        }
        case 165: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 165 : Send Test Command With List of Struct Argument and arg1.b of first item is false\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].a = 1;
                listHolder_0->mList[0].b = true;
                listHolder_0->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_0->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_0->mList[0].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
                listHolder_0->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[0].g = 0.0f;
                listHolder_0->mList[0].h = 0;

                listHolder_0->mList[1].a = 0;
                listHolder_0->mList[1].b = false;
                listHolder_0->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
                listHolder_0->mList[1].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
                listHolder_0->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[1].g = 0.0f;
                listHolder_0->mList[1].h = 0;

                value.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                    listHolder_0->mList, 2);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListStructArgumentRequest::Id, value);
        }
        case 166: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 166 : Send Test Command With List of Nested Struct List Argument and all fields b of "
                            "elements of arg1.d are true\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].a = 0;
                listHolder_0->mList[0].b = true;

                listHolder_0->mList[0].c.a = 0;
                listHolder_0->mList[0].c.b = true;
                listHolder_0->mList[0].c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[0].c.d =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
                listHolder_0->mList[0].c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
                listHolder_0->mList[0].c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[0].c.g = 0.0f;
                listHolder_0->mList[0].c.h = 0;

                {
                    auto * listHolder_2 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                    listFreer.add(listHolder_2);

                    listHolder_2->mList[0].a = 1;
                    listHolder_2->mList[0].b = true;
                    listHolder_2->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                    listHolder_2->mList[0].d =
                        chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                    listHolder_2->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                    listHolder_2->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                    listHolder_2->mList[0].g = 0.0f;
                    listHolder_2->mList[0].h = 0;

                    listHolder_2->mList[1].a = 2;
                    listHolder_2->mList[1].b = true;
                    listHolder_2->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                    listHolder_2->mList[1].d =
                        chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                    listHolder_2->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                    listHolder_2->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                    listHolder_2->mList[1].g = 0.0f;
                    listHolder_2->mList[1].h = 0;

                    listHolder_0->mList[0].d =
                        chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                            listHolder_2->mList, 2);
                }

                {
                    auto * listHolder_2 = new ListHolder<uint32_t>(3);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0]   = 1UL;
                    listHolder_2->mList[1]   = 2UL;
                    listHolder_2->mList[2]   = 3UL;
                    listHolder_0->mList[0].e = chip::app::DataModel::List<uint32_t>(listHolder_2->mList, 3);
                }

                {
                    auto * listHolder_2 = new ListHolder<chip::ByteSpan>(3);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                    listHolder_2->mList[1] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                    listHolder_2->mList[2] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                    listHolder_0->mList[0].f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_2->mList, 3);
                }

                {
                    auto * listHolder_2 = new ListHolder<uint8_t>(2);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0]   = 0;
                    listHolder_2->mList[1]   = 255;
                    listHolder_0->mList[0].g = chip::app::DataModel::List<uint8_t>(listHolder_2->mList, 2);
                }

                value.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(
                    listHolder_0->mList, 1);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListNestedStructListArgumentRequest::Id, value);
        }
        case 167: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 167 : Send Test Command With Nested Struct List Argument and some fields b of "
                            "elements of arg1.d are false\n");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].a = 0;
                listHolder_0->mList[0].b = true;

                listHolder_0->mList[0].c.a = 0;
                listHolder_0->mList[0].c.b = true;
                listHolder_0->mList[0].c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[0].c.d =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
                listHolder_0->mList[0].c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
                listHolder_0->mList[0].c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[0].c.g = 0.0f;
                listHolder_0->mList[0].c.h = 0;

                {
                    auto * listHolder_2 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                    listFreer.add(listHolder_2);

                    listHolder_2->mList[0].a = 1;
                    listHolder_2->mList[0].b = true;
                    listHolder_2->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                    listHolder_2->mList[0].d =
                        chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                    listHolder_2->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                    listHolder_2->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                    listHolder_2->mList[0].g = 0.0f;
                    listHolder_2->mList[0].h = 0;

                    listHolder_2->mList[1].a = 2;
                    listHolder_2->mList[1].b = false;
                    listHolder_2->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                    listHolder_2->mList[1].d =
                        chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                    listHolder_2->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                    listHolder_2->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                    listHolder_2->mList[1].g = 0.0f;
                    listHolder_2->mList[1].h = 0;

                    listHolder_0->mList[0].d =
                        chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                            listHolder_2->mList, 2);
                }

                {
                    auto * listHolder_2 = new ListHolder<uint32_t>(3);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0]   = 1UL;
                    listHolder_2->mList[1]   = 2UL;
                    listHolder_2->mList[2]   = 3UL;
                    listHolder_0->mList[0].e = chip::app::DataModel::List<uint32_t>(listHolder_2->mList, 3);
                }

                {
                    auto * listHolder_2 = new ListHolder<chip::ByteSpan>(3);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                    listHolder_2->mList[1] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                    listHolder_2->mList[2] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                    listHolder_0->mList[0].f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_2->mList, 3);
                }

                {
                    auto * listHolder_2 = new ListHolder<uint8_t>(2);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0]   = 0;
                    listHolder_2->mList[1]   = 255;
                    listHolder_0->mList[0].g = chip::app::DataModel::List<uint8_t>(listHolder_2->mList, 2);
                }

                value.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(
                    listHolder_0->mList, 1);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListNestedStructListArgumentRequest::Id, value);
        }
        case 168: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 168 : Write attribute LIST With List of INT8U and none of them is set to 0\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const uint8_t> value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(4);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1;
                listHolder_0->mList[1] = 2;
                listHolder_0->mList[2] = 3;
                listHolder_0->mList[3] = 4;
                value                  = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id, value);
        }
        case 169: {
            ChipLogProgress(chipTool, " ***** Test Step 169 : Read attribute LIST With List of INT8U\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id);
        }
        case 170: {
            ChipLogProgress(chipTool, " ***** Test Step 170 : Write attribute LIST With List of OCTET_STRING\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::ByteSpan> value;

            {
                auto * listHolder_0 = new ListHolder<chip::ByteSpan>(4);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);
                listHolder_0->mList[1] = chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);
                listHolder_0->mList[2] = chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);
                listHolder_0->mList[3] = chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);
                value                  = chip::app::DataModel::List<chip::ByteSpan>(listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListOctetString::Id,
                                  value);
        }
        case 171: {
            ChipLogProgress(chipTool, " ***** Test Step 171 : Read attribute LIST With List of OCTET_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListOctetString::Id);
        }
        case 172: {
            ChipLogProgress(chipTool, " ***** Test Step 172 : Write attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>(4);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].fabricIndex = 0ULL;
                listHolder_0->mList[0].operationalCert =
                    chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);

                listHolder_0->mList[1].fabricIndex = 1ULL;
                listHolder_0->mList[1].operationalCert =
                    chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);

                listHolder_0->mList[2].fabricIndex = 2ULL;
                listHolder_0->mList[2].operationalCert =
                    chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);

                listHolder_0->mList[3].fabricIndex = 3ULL;
                listHolder_0->mList[3].operationalCert =
                    chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);

                value = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>(
                    listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::ListStructOctetString::Id, value);
        }
        case 173: {
            ChipLogProgress(chipTool, " ***** Test Step 173 : Read attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::ListStructOctetString::Id);
        }
        case 174: {
            ChipLogProgress(chipTool, " ***** Test Step 174 : Send Test Command with optional arg set.\n");
            chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type value;
            value.arg1.Emplace();
            value.arg1.Value().SetNonNull();
            value.arg1.Value().Value() = 5;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNullableOptionalRequest::Id, value);
        }
        case 175: {
            ChipLogProgress(chipTool, " ***** Test Step 175 : Send Test Command without its optional arg.\n");
            chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNullableOptionalRequest::Id, value);
        }
        case 176: {
            ChipLogProgress(chipTool, " ***** Test Step 176 : Read list of structs containing nullables and optionals\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::ListNullablesAndOptionalsStruct::Id);
        }
        case 177: {
            ChipLogProgress(chipTool, " ***** Test Step 177 : Write list of structs containing nullables and optionals\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type> value;

            {
                auto * listHolder_0 =
                    new ListHolder<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].nullableInt.SetNull();
                listHolder_0->mList[0].nullableString.SetNull();
                listHolder_0->mList[0].nullableStruct.SetNull();
                listHolder_0->mList[0].nullableList.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                    listFreer.add(listHolder_3);
                    listHolder_3->mList[0] = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(1);
                    listHolder_3->mList[1] = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                    listHolder_0->mList[0].nullableList.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::TestCluster::SimpleEnum>(listHolder_3->mList, 2);
                }

                value = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>(
                    listHolder_0->mList, 1);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::ListNullablesAndOptionalsStruct::Id, value);
        }
        case 178: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 178 : Read list of structs containing nullables and optionals after writing\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::ListNullablesAndOptionalsStruct::Id);
        }
        case 179: {
            ChipLogProgress(chipTool, " ***** Test Step 179 : Write attribute NULLABLE_BOOLEAN null\n");
            chip::app::DataModel::Nullable<bool> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBoolean::Id,
                                  value);
        }
        case 180: {
            ChipLogProgress(chipTool, " ***** Test Step 180 : Read attribute NULLABLE_BOOLEAN null\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBoolean::Id);
        }
        case 181: {
            ChipLogProgress(chipTool, " ***** Test Step 181 : Write attribute NULLABLE_BOOLEAN True\n");
            chip::app::DataModel::Nullable<bool> value;
            value.SetNonNull();
            value.Value() = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBoolean::Id,
                                  value);
        }
        case 182: {
            ChipLogProgress(chipTool, " ***** Test Step 182 : Read attribute NULLABLE_BOOLEAN True\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBoolean::Id);
        }
        case 183: {
            ChipLogProgress(chipTool, " ***** Test Step 183 : Write attribute NULLABLE_BITMAP8 Max Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id,
                                  value);
        }
        case 184: {
            ChipLogProgress(chipTool, " ***** Test Step 184 : Read attribute NULLABLE_BITMAP8 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id);
        }
        case 185: {
            ChipLogProgress(chipTool, " ***** Test Step 185 : Write attribute NULLABLE_BITMAP8 Invalid Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id,
                                  value);
        }
        case 186: {
            ChipLogProgress(chipTool, " ***** Test Step 186 : Read attribute NULLABLE_BITMAP8 unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id);
        }
        case 187: {
            ChipLogProgress(chipTool, " ***** Test Step 187 : Write attribute NULLABLE_BITMAP8 null Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id,
                                  value);
        }
        case 188: {
            ChipLogProgress(chipTool, " ***** Test Step 188 : Read attribute NULLABLE_BITMAP8 null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id);
        }
        case 189: {
            ChipLogProgress(chipTool, " ***** Test Step 189 : Write attribute NULLABLE_BITMAP16 Max Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65534U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id,
                                  value);
        }
        case 190: {
            ChipLogProgress(chipTool, " ***** Test Step 190 : Read attribute NULLABLE_BITMAP16 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id);
        }
        case 191: {
            ChipLogProgress(chipTool, " ***** Test Step 191 : Write attribute NULLABLE_BITMAP16 Invalid Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id,
                                  value);
        }
        case 192: {
            ChipLogProgress(chipTool, " ***** Test Step 192 : Read attribute NULLABLE_BITMAP16 unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id);
        }
        case 193: {
            ChipLogProgress(chipTool, " ***** Test Step 193 : Write attribute NULLABLE_BITMAP16 null Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id,
                                  value);
        }
        case 194: {
            ChipLogProgress(chipTool, " ***** Test Step 194 : Read attribute NULLABLE_BITMAP16 null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id);
        }
        case 195: {
            ChipLogProgress(chipTool, " ***** Test Step 195 : Write attribute NULLABLE_BITMAP32 Max Value\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 4294967294UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id,
                                  value);
        }
        case 196: {
            ChipLogProgress(chipTool, " ***** Test Step 196 : Read attribute NULLABLE_BITMAP32 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id);
        }
        case 197: {
            ChipLogProgress(chipTool, " ***** Test Step 197 : Write attribute NULLABLE_BITMAP32 Invalid Value\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 4294967295UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id,
                                  value);
        }
        case 198: {
            ChipLogProgress(chipTool, " ***** Test Step 198 : Read attribute NULLABLE_BITMAP32 unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id);
        }
        case 199: {
            ChipLogProgress(chipTool, " ***** Test Step 199 : Write attribute NULLABLE_BITMAP32 null Value\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id,
                                  value);
        }
        case 200: {
            ChipLogProgress(chipTool, " ***** Test Step 200 : Read attribute NULLABLE_BITMAP32 null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id);
        }
        case 201: {
            ChipLogProgress(chipTool, " ***** Test Step 201 : Write attribute NULLABLE_BITMAP64 Max Value\n");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 18446744073709551614ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id,
                                  value);
        }
        case 202: {
            ChipLogProgress(chipTool, " ***** Test Step 202 : Read attribute NULLABLE_BITMAP64 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id);
        }
        case 203: {
            ChipLogProgress(chipTool, " ***** Test Step 203 : Write attribute NULLABLE_BITMAP64 Invalid Value\n");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 18446744073709551615ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id,
                                  value);
        }
        case 204: {
            ChipLogProgress(chipTool, " ***** Test Step 204 : Read attribute NULLABLE_BITMAP64 unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id);
        }
        case 205: {
            ChipLogProgress(chipTool, " ***** Test Step 205 : Write attribute NULLABLE_BITMAP64 null Value\n");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id,
                                  value);
        }
        case 206: {
            ChipLogProgress(chipTool, " ***** Test Step 206 : Read attribute NULLABLE_BITMAP64 null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id);
        }
        case 207: {
            ChipLogProgress(chipTool, " ***** Test Step 207 : Write attribute NULLABLE_INT8U Min Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 208: {
            ChipLogProgress(chipTool, " ***** Test Step 208 : Read attribute NULLABLE_INT8U Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 209: {
            ChipLogProgress(chipTool, " ***** Test Step 209 : Write attribute NULLABLE_INT8U Max Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 210: {
            ChipLogProgress(chipTool, " ***** Test Step 210 : Read attribute NULLABLE_INT8U Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 211: {
            ChipLogProgress(chipTool, " ***** Test Step 211 : Write attribute NULLABLE_INT8U Invalid Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 212: {
            ChipLogProgress(chipTool, " ***** Test Step 212 : Read attribute NULLABLE_INT8U unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 213: {
            ChipLogProgress(chipTool, " ***** Test Step 213 : Read attribute NULLABLE_INT8U unchanged Value with constraint\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 214: {
            ChipLogProgress(chipTool, " ***** Test Step 214 : Write attribute NULLABLE_INT8U null Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 215: {
            ChipLogProgress(chipTool, " ***** Test Step 215 : Read attribute NULLABLE_INT8U null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 216: {
            ChipLogProgress(chipTool, " ***** Test Step 216 : Read attribute NULLABLE_INT8U null Value & range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 217: {
            ChipLogProgress(chipTool, " ***** Test Step 217 : Read attribute NULLABLE_INT8U null Value & not\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 218: {
            ChipLogProgress(chipTool, " ***** Test Step 218 : Write attribute NULLABLE_INT8U Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 219: {
            ChipLogProgress(chipTool, " ***** Test Step 219 : Read attribute NULLABLE_INT8U Value in range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 220: {
            ChipLogProgress(chipTool, " ***** Test Step 220 : Read attribute NULLABLE_INT8U notValue OK\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 221: {
            ChipLogProgress(chipTool, " ***** Test Step 221 : Write attribute NULLABLE_INT16U Min Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 222: {
            ChipLogProgress(chipTool, " ***** Test Step 222 : Read attribute NULLABLE_INT16U Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 223: {
            ChipLogProgress(chipTool, " ***** Test Step 223 : Write attribute NULLABLE_INT16U Max Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65534U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 224: {
            ChipLogProgress(chipTool, " ***** Test Step 224 : Read attribute NULLABLE_INT16U Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 225: {
            ChipLogProgress(chipTool, " ***** Test Step 225 : Write attribute NULLABLE_INT16U Invalid Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 226: {
            ChipLogProgress(chipTool, " ***** Test Step 226 : Read attribute NULLABLE_INT16U unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 227: {
            ChipLogProgress(chipTool, " ***** Test Step 227 : Write attribute NULLABLE_INT16U null Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 228: {
            ChipLogProgress(chipTool, " ***** Test Step 228 : Read attribute NULLABLE_INT16U null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 229: {
            ChipLogProgress(chipTool, " ***** Test Step 229 : Read attribute NULLABLE_INT16U null Value & range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 230: {
            ChipLogProgress(chipTool, " ***** Test Step 230 : Read attribute NULLABLE_INT16U null Value & not\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 231: {
            ChipLogProgress(chipTool, " ***** Test Step 231 : Write attribute NULLABLE_INT16U Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 32000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 232: {
            ChipLogProgress(chipTool, " ***** Test Step 232 : Read attribute NULLABLE_INT16U Value in range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 233: {
            ChipLogProgress(chipTool, " ***** Test Step 233 : Read attribute NULLABLE_INT16U notValue OK\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 234: {
            ChipLogProgress(chipTool, " ***** Test Step 234 : Write attribute NULLABLE_INT32U Min Value\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 235: {
            ChipLogProgress(chipTool, " ***** Test Step 235 : Read attribute NULLABLE_INT32U Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 236: {
            ChipLogProgress(chipTool, " ***** Test Step 236 : Write attribute NULLABLE_INT32U Max Value\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 4294967294UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 237: {
            ChipLogProgress(chipTool, " ***** Test Step 237 : Read attribute NULLABLE_INT32U Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 238: {
            ChipLogProgress(chipTool, " ***** Test Step 238 : Write attribute NULLABLE_INT32U Invalid Value\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 4294967295UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 239: {
            ChipLogProgress(chipTool, " ***** Test Step 239 : Read attribute NULLABLE_INT32U unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 240: {
            ChipLogProgress(chipTool, " ***** Test Step 240 : Write attribute NULLABLE_INT32U null Value\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 241: {
            ChipLogProgress(chipTool, " ***** Test Step 241 : Read attribute NULLABLE_INT32U null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 242: {
            ChipLogProgress(chipTool, " ***** Test Step 242 : Read attribute NULLABLE_INT32U null Value & range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 243: {
            ChipLogProgress(chipTool, " ***** Test Step 243 : Read attribute NULLABLE_INT32U null Value & not\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 244: {
            ChipLogProgress(chipTool, " ***** Test Step 244 : Write attribute NULLABLE_INT32U Value\n");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 2147483647UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 245: {
            ChipLogProgress(chipTool, " ***** Test Step 245 : Read attribute NULLABLE_INT32U Value in range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 246: {
            ChipLogProgress(chipTool, " ***** Test Step 246 : Read attribute NULLABLE_INT32U notValue OK\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 247: {
            ChipLogProgress(chipTool, " ***** Test Step 247 : Write attribute NULLABLE_INT64U Min Value\n");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 0ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 248: {
            ChipLogProgress(chipTool, " ***** Test Step 248 : Read attribute NULLABLE_INT64U Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 249: {
            ChipLogProgress(chipTool, " ***** Test Step 249 : Write attribute NULLABLE_INT64U Max Value\n");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 18446744073709551614ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 250: {
            ChipLogProgress(chipTool, " ***** Test Step 250 : Read attribute NULLABLE_INT64U Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 251: {
            ChipLogProgress(chipTool, " ***** Test Step 251 : Write attribute NULLABLE_INT64U Invalid Value\n");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 18446744073709551615ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 252: {
            ChipLogProgress(chipTool, " ***** Test Step 252 : Read attribute NULLABLE_INT64U unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 253: {
            ChipLogProgress(chipTool, " ***** Test Step 253 : Write attribute NULLABLE_INT64U null Value\n");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 254: {
            ChipLogProgress(chipTool, " ***** Test Step 254 : Read attribute NULLABLE_INT64U null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 255: {
            ChipLogProgress(chipTool, " ***** Test Step 255 : Read attribute NULLABLE_INT64U null Value & range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 256: {
            ChipLogProgress(chipTool, " ***** Test Step 256 : Read attribute NULLABLE_INT64U null Value & not\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 257: {
            ChipLogProgress(chipTool, " ***** Test Step 257 : Write attribute NULLABLE_INT64U Value\n");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 18000000000000000000ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 258: {
            ChipLogProgress(chipTool, " ***** Test Step 258 : Read attribute NULLABLE_INT64U Value in range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 259: {
            ChipLogProgress(chipTool, " ***** Test Step 259 : Read attribute NULLABLE_INT64U notValue OK\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 260: {
            ChipLogProgress(chipTool, " ***** Test Step 260 : Write attribute NULLABLE_INT8S Min Value\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id,
                                  value);
        }
        case 261: {
            ChipLogProgress(chipTool, " ***** Test Step 261 : Read attribute NULLABLE_INT8S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 262: {
            ChipLogProgress(chipTool, " ***** Test Step 262 : Write attribute NULLABLE_INT8S Invalid Value\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id,
                                  value);
        }
        case 263: {
            ChipLogProgress(chipTool, " ***** Test Step 263 : Read attribute NULLABLE_INT8S unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 264: {
            ChipLogProgress(chipTool, " ***** Test Step 264 : Write attribute NULLABLE_INT8S null Value\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id,
                                  value);
        }
        case 265: {
            ChipLogProgress(chipTool, " ***** Test Step 265 : Read attribute NULLABLE_INT8S null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 266: {
            ChipLogProgress(chipTool, " ***** Test Step 266 : Read attribute NULLABLE_INT8S null Value & range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 267: {
            ChipLogProgress(chipTool, " ***** Test Step 267 : Read attribute NULLABLE_INT8S null Value & not\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 268: {
            ChipLogProgress(chipTool, " ***** Test Step 268 : Write attribute NULLABLE_INT8S Value\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id,
                                  value);
        }
        case 269: {
            ChipLogProgress(chipTool, " ***** Test Step 269 : Read attribute NULLABLE_INT8S Value in range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 270: {
            ChipLogProgress(chipTool, " ***** Test Step 270 : Read attribute NULLABLE_INT8S notValue OK\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 271: {
            ChipLogProgress(chipTool, " ***** Test Step 271 : Write attribute NULLABLE_INT16S Min Value\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id,
                                  value);
        }
        case 272: {
            ChipLogProgress(chipTool, " ***** Test Step 272 : Read attribute NULLABLE_INT16S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 273: {
            ChipLogProgress(chipTool, " ***** Test Step 273 : Write attribute NULLABLE_INT16S Invalid Value\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -32768;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id,
                                  value);
        }
        case 274: {
            ChipLogProgress(chipTool, " ***** Test Step 274 : Read attribute NULLABLE_INT16S unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 275: {
            ChipLogProgress(chipTool, " ***** Test Step 275 : Write attribute NULLABLE_INT16S null Value\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id,
                                  value);
        }
        case 276: {
            ChipLogProgress(chipTool, " ***** Test Step 276 : Read attribute NULLABLE_INT16S null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 277: {
            ChipLogProgress(chipTool, " ***** Test Step 277 : Read attribute NULLABLE_INT16S null Value & range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 278: {
            ChipLogProgress(chipTool, " ***** Test Step 278 : Read attribute NULLABLE_INT16S null Value & not\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 279: {
            ChipLogProgress(chipTool, " ***** Test Step 279 : Write attribute NULLABLE_INT16S Value\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id,
                                  value);
        }
        case 280: {
            ChipLogProgress(chipTool, " ***** Test Step 280 : Read attribute NULLABLE_INT16S Value in range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 281: {
            ChipLogProgress(chipTool, " ***** Test Step 281 : Read attribute NULLABLE_INT16S notValue OK\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 282: {
            ChipLogProgress(chipTool, " ***** Test Step 282 : Write attribute NULLABLE_INT32S Min Value\n");
            chip::app::DataModel::Nullable<int32_t> value;
            value.SetNonNull();
            value.Value() = -2147483647L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id,
                                  value);
        }
        case 283: {
            ChipLogProgress(chipTool, " ***** Test Step 283 : Read attribute NULLABLE_INT32S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 284: {
            ChipLogProgress(chipTool, " ***** Test Step 284 : Write attribute NULLABLE_INT32S Invalid Value\n");
            chip::app::DataModel::Nullable<int32_t> value;
            value.SetNonNull();
            value.Value() = -2147483648L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id,
                                  value);
        }
        case 285: {
            ChipLogProgress(chipTool, " ***** Test Step 285 : Read attribute NULLABLE_INT32S unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 286: {
            ChipLogProgress(chipTool, " ***** Test Step 286 : Write attribute NULLABLE_INT32S null Value\n");
            chip::app::DataModel::Nullable<int32_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id,
                                  value);
        }
        case 287: {
            ChipLogProgress(chipTool, " ***** Test Step 287 : Read attribute NULLABLE_INT32S null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 288: {
            ChipLogProgress(chipTool, " ***** Test Step 288 : Read attribute NULLABLE_INT32S null Value & range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 289: {
            ChipLogProgress(chipTool, " ***** Test Step 289 : Read attribute NULLABLE_INT32S null Value & not\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 290: {
            ChipLogProgress(chipTool, " ***** Test Step 290 : Write attribute NULLABLE_INT32S Value\n");
            chip::app::DataModel::Nullable<int32_t> value;
            value.SetNonNull();
            value.Value() = -2147483647L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id,
                                  value);
        }
        case 291: {
            ChipLogProgress(chipTool, " ***** Test Step 291 : Read attribute NULLABLE_INT32S Value in range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 292: {
            ChipLogProgress(chipTool, " ***** Test Step 292 : Read attribute NULLABLE_INT32S notValue OK\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 293: {
            ChipLogProgress(chipTool, " ***** Test Step 293 : Write attribute NULLABLE_INT64S Min Value\n");
            chip::app::DataModel::Nullable<int64_t> value;
            value.SetNonNull();
            value.Value() = -9223372036854775807LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id,
                                  value);
        }
        case 294: {
            ChipLogProgress(chipTool, " ***** Test Step 294 : Read attribute NULLABLE_INT64S Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 295: {
            ChipLogProgress(chipTool, " ***** Test Step 295 : Write attribute NULLABLE_INT64S Invalid Value\n");
            chip::app::DataModel::Nullable<int64_t> value;
            value.SetNonNull();
            value.Value() = -9223372036854775807LL - 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id,
                                  value);
        }
        case 296: {
            ChipLogProgress(chipTool, " ***** Test Step 296 : Read attribute NULLABLE_INT64S unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 297: {
            ChipLogProgress(chipTool, " ***** Test Step 297 : Write attribute NULLABLE_INT64S null Value\n");
            chip::app::DataModel::Nullable<int64_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id,
                                  value);
        }
        case 298: {
            ChipLogProgress(chipTool, " ***** Test Step 298 : Read attribute NULLABLE_INT64S null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 299: {
            ChipLogProgress(chipTool, " ***** Test Step 299 : Read attribute NULLABLE_INT64S null Value & range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 300: {
            ChipLogProgress(chipTool, " ***** Test Step 300 : Read attribute NULLABLE_INT64S null Value & not\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 301: {
            ChipLogProgress(chipTool, " ***** Test Step 301 : Write attribute NULLABLE_INT64S Value\n");
            chip::app::DataModel::Nullable<int64_t> value;
            value.SetNonNull();
            value.Value() = -9223372036854775807LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id,
                                  value);
        }
        case 302: {
            ChipLogProgress(chipTool, " ***** Test Step 302 : Read attribute NULLABLE_INT64S Value in range\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 303: {
            ChipLogProgress(chipTool, " ***** Test Step 303 : Read attribute NULLABLE_INT64S notValue OK\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 304: {
            ChipLogProgress(chipTool, " ***** Test Step 304 : Write attribute NULLABLE_SINGLE medium Value\n");
            chip::app::DataModel::Nullable<float> value;
            value.SetNonNull();
            value.Value() = 0.1f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 305: {
            ChipLogProgress(chipTool, " ***** Test Step 305 : Read attribute NULLABLE_SINGLE medium Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 306: {
            ChipLogProgress(chipTool, " ***** Test Step 306 : Write attribute NULLABLE_SINGLE largest Value\n");
            chip::app::DataModel::Nullable<float> value;
            value.SetNonNull();
            value.Value() = INFINITY;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 307: {
            ChipLogProgress(chipTool, " ***** Test Step 307 : Read attribute NULLABLE_SINGLE largest Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 308: {
            ChipLogProgress(chipTool, " ***** Test Step 308 : Write attribute NULLABLE_SINGLE smallest Value\n");
            chip::app::DataModel::Nullable<float> value;
            value.SetNonNull();
            value.Value() = -INFINITY;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 309: {
            ChipLogProgress(chipTool, " ***** Test Step 309 : Read attribute NULLABLE_SINGLE smallest Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 310: {
            ChipLogProgress(chipTool, " ***** Test Step 310 : Write attribute NULLABLE_SINGLE null Value\n");
            chip::app::DataModel::Nullable<float> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 311: {
            ChipLogProgress(chipTool, " ***** Test Step 311 : Read attribute NULLABLE_SINGLE null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 312: {
            ChipLogProgress(chipTool, " ***** Test Step 312 : Write attribute NULLABLE_SINGLE 0 Value\n");
            chip::app::DataModel::Nullable<float> value;
            value.SetNonNull();
            value.Value() = 0.0f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 313: {
            ChipLogProgress(chipTool, " ***** Test Step 313 : Read attribute NULLABLE_SINGLE 0 Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 314: {
            ChipLogProgress(chipTool, " ***** Test Step 314 : Write attribute NULLABLE_DOUBLE medium Value\n");
            chip::app::DataModel::Nullable<double> value;
            value.SetNonNull();
            value.Value() = 0.1234567890123;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 315: {
            ChipLogProgress(chipTool, " ***** Test Step 315 : Read attribute NULLABLE_DOUBLE medium Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 316: {
            ChipLogProgress(chipTool, " ***** Test Step 316 : Write attribute NULLABLE_DOUBLE largest Value\n");
            chip::app::DataModel::Nullable<double> value;
            value.SetNonNull();
            value.Value() = INFINITY;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 317: {
            ChipLogProgress(chipTool, " ***** Test Step 317 : Read attribute NULLABLE_DOUBLE largest Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 318: {
            ChipLogProgress(chipTool, " ***** Test Step 318 : Write attribute NULLABLE_DOUBLE smallest Value\n");
            chip::app::DataModel::Nullable<double> value;
            value.SetNonNull();
            value.Value() = -INFINITY;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 319: {
            ChipLogProgress(chipTool, " ***** Test Step 319 : Read attribute NULLABLE_DOUBLE smallest Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 320: {
            ChipLogProgress(chipTool, " ***** Test Step 320 : Write attribute NULLABLE_DOUBLE null Value\n");
            chip::app::DataModel::Nullable<double> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 321: {
            ChipLogProgress(chipTool, " ***** Test Step 321 : Read attribute NULLABLE_DOUBLE null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 322: {
            ChipLogProgress(chipTool, " ***** Test Step 322 : Write attribute NULLABLE_DOUBLE 0 Value\n");
            chip::app::DataModel::Nullable<double> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 323: {
            ChipLogProgress(chipTool, " ***** Test Step 323 : Read attribute NULLABLE_DOUBLE 0 Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 324: {
            ChipLogProgress(chipTool, " ***** Test Step 324 : Write attribute NULLABLE_ENUM8 Min Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id,
                                  value);
        }
        case 325: {
            ChipLogProgress(chipTool, " ***** Test Step 325 : Read attribute NULLABLE_ENUM8 Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id);
        }
        case 326: {
            ChipLogProgress(chipTool, " ***** Test Step 326 : Write attribute NULLABLE_ENUM8 Max Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id,
                                  value);
        }
        case 327: {
            ChipLogProgress(chipTool, " ***** Test Step 327 : Read attribute NULLABLE_ENUM8 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id);
        }
        case 328: {
            ChipLogProgress(chipTool, " ***** Test Step 328 : Write attribute NULLABLE_ENUM8 Invalid Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id,
                                  value);
        }
        case 329: {
            ChipLogProgress(chipTool, " ***** Test Step 329 : Read attribute NULLABLE_ENUM8 unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id);
        }
        case 330: {
            ChipLogProgress(chipTool, " ***** Test Step 330 : Write attribute NULLABLE_ENUM8 null Value\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id,
                                  value);
        }
        case 331: {
            ChipLogProgress(chipTool, " ***** Test Step 331 : Read attribute NULLABLE_ENUM8 null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id);
        }
        case 332: {
            ChipLogProgress(chipTool, " ***** Test Step 332 : Write attribute NULLABLE_ENUM16 Min Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id,
                                  value);
        }
        case 333: {
            ChipLogProgress(chipTool, " ***** Test Step 333 : Read attribute NULLABLE_ENUM16 Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id);
        }
        case 334: {
            ChipLogProgress(chipTool, " ***** Test Step 334 : Write attribute NULLABLE_ENUM16 Max Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65534U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id,
                                  value);
        }
        case 335: {
            ChipLogProgress(chipTool, " ***** Test Step 335 : Read attribute NULLABLE_ENUM16 Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id);
        }
        case 336: {
            ChipLogProgress(chipTool, " ***** Test Step 336 : Write attribute NULLABLE_ENUM16 Invalid Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id,
                                  value);
        }
        case 337: {
            ChipLogProgress(chipTool, " ***** Test Step 337 : Read attribute NULLABLE_ENUM16 unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id);
        }
        case 338: {
            ChipLogProgress(chipTool, " ***** Test Step 338 : Write attribute NULLABLE_ENUM16 null Value\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id,
                                  value);
        }
        case 339: {
            ChipLogProgress(chipTool, " ***** Test Step 339 : Read attribute NULLABLE_ENUM16 null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id);
        }
        case 340: {
            ChipLogProgress(chipTool, " ***** Test Step 340 : Write attribute NULLABLE_SIMPLE_ENUM Min Value\n");
            chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id,
                                  value);
        }
        case 341: {
            ChipLogProgress(chipTool, " ***** Test Step 341 : Read attribute NULLABLE_SIMPLE_ENUM Min Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id);
        }
        case 342: {
            ChipLogProgress(chipTool, " ***** Test Step 342 : Write attribute NULLABLE_SIMPLE_ENUM Max Value\n");
            chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(254);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id,
                                  value);
        }
        case 343: {
            ChipLogProgress(chipTool, " ***** Test Step 343 : Read attribute NULLABLE_SIMPLE_ENUM Max Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id);
        }
        case 344: {
            ChipLogProgress(chipTool, " ***** Test Step 344 : Write attribute NULLABLE_SIMPLE_ENUM Invalid Value\n");
            chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(255);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id,
                                  value);
        }
        case 345: {
            ChipLogProgress(chipTool, " ***** Test Step 345 : Read attribute NULLABLE_SIMPLE_ENUM unchanged Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id);
        }
        case 346: {
            ChipLogProgress(chipTool, " ***** Test Step 346 : Write attribute NULLABLE_SIMPLE_ENUM null Value\n");
            chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id,
                                  value);
        }
        case 347: {
            ChipLogProgress(chipTool, " ***** Test Step 347 : Read attribute NULLABLE_SIMPLE_ENUM null Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id);
        }
        case 348: {
            ChipLogProgress(chipTool, " ***** Test Step 348 : Read attribute NULLABLE_OCTET_STRING Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id);
        }
        case 349: {
            ChipLogProgress(chipTool, " ***** Test Step 349 : Write attribute NULLABLE_OCTET_STRING\n");
            chip::app::DataModel::Nullable<chip::ByteSpan> value;
            value.SetNonNull();
            value.Value() = chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id,
                                  value);
        }
        case 350: {
            ChipLogProgress(chipTool, " ***** Test Step 350 : Read attribute NULLABLE_OCTET_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id);
        }
        case 351: {
            ChipLogProgress(chipTool, " ***** Test Step 351 : Write attribute NULLABLE_OCTET_STRING\n");
            chip::app::DataModel::Nullable<chip::ByteSpan> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id,
                                  value);
        }
        case 352: {
            ChipLogProgress(chipTool, " ***** Test Step 352 : Read attribute NULLABLE_OCTET_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id);
        }
        case 353: {
            ChipLogProgress(chipTool, " ***** Test Step 353 : Write attribute NULLABLE_OCTET_STRING\n");
            chip::app::DataModel::Nullable<chip::ByteSpan> value;
            value.SetNonNull();
            value.Value() = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id,
                                  value);
        }
        case 354: {
            ChipLogProgress(chipTool, " ***** Test Step 354 : Read attribute NULLABLE_OCTET_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id);
        }
        case 355: {
            ChipLogProgress(chipTool, " ***** Test Step 355 : Read attribute NULLABLE_CHAR_STRING Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id);
        }
        case 356: {
            ChipLogProgress(chipTool, " ***** Test Step 356 : Write attribute NULLABLE_CHAR_STRING\n");
            chip::app::DataModel::Nullable<chip::CharSpan> value;
            value.SetNonNull();
            value.Value() = chip::Span<const char>("Tgarbage: not in length on purpose", 7);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id,
                                  value);
        }
        case 357: {
            ChipLogProgress(chipTool, " ***** Test Step 357 : Read attribute NULLABLE_CHAR_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id);
        }
        case 358: {
            ChipLogProgress(chipTool, " ***** Test Step 358 : Write attribute NULLABLE_CHAR_STRING - Value too long\n");
            chip::app::DataModel::Nullable<chip::CharSpan> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id,
                                  value);
        }
        case 359: {
            ChipLogProgress(chipTool, " ***** Test Step 359 : Read attribute NULLABLE_CHAR_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id);
        }
        case 360: {
            ChipLogProgress(chipTool, " ***** Test Step 360 : Write attribute NULLABLE_CHAR_STRING - Empty\n");
            chip::app::DataModel::Nullable<chip::CharSpan> value;
            value.SetNonNull();
            value.Value() = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id,
                                  value);
        }
        case 361: {
            ChipLogProgress(chipTool, " ***** Test Step 361 : Read attribute NULLABLE_CHAR_STRING\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id);
        }
        case 362: {
            ChipLogProgress(chipTool, " ***** Test Step 362 : Read attribute from nonexistent endpoint.\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(200), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id);
        }
        case 363: {
            ChipLogProgress(chipTool, " ***** Test Step 363 : Read attribute from nonexistent cluster.\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id);
        }
        case 364: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 364 : Send a command that takes an optional parameter but do not set it.\n");
            chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestSimpleOptionalArgumentRequest::Id, value);
        }
        case 365: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 365 : Send a command that takes an optional parameter but do not set it.\n");
            chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type value;
            value.arg1.Emplace();
            value.arg1.Value() = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestSimpleOptionalArgumentRequest::Id, value);
        }
        case 366: {
            ChipLogProgress(chipTool, " ***** Test Step 366 : Subscribe to list attribute\n");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id, 2,
                                      5);
        }
        case 367: {
            ChipLogProgress(chipTool, " ***** Test Step 367 : Write subscribed-to list attribute\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const uint8_t> value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(4);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 5;
                listHolder_0->mList[1] = 6;
                listHolder_0->mList[2] = 7;
                listHolder_0->mList[3] = 8;
                value                  = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id, value);
        }
        case 368: {
            ChipLogProgress(chipTool, " ***** Test Step 368 : Check for list attribute report\n");
            return WaitForReport();
        }
        case 369: {
            ChipLogProgress(chipTool, " ***** Test Step 369 : Read range-restricted unsigned 8-bit integer\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 370: {
            ChipLogProgress(chipTool, " ***** Test Step 370 : Write min value to a range-restricted unsigned 8-bit integer\n");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 371: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 371 : Write just-below-range value to a range-restricted unsigned 8-bit integer\n");
            uint8_t value;
            value = 19;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 372: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 372 : Write just-above-range value to a range-restricted unsigned 8-bit integer\n");
            uint8_t value;
            value = 101;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 373: {
            ChipLogProgress(chipTool, " ***** Test Step 373 : Write max value to a range-restricted unsigned 8-bit integer\n");
            uint8_t value;
            value = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 374: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 374 : Verify range-restricted unsigned 8-bit integer value has not changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 375: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 375 : Write min valid value to a range-restricted unsigned 8-bit integer\n");
            uint8_t value;
            value = 20;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 376: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 376 : Verify range-restricted unsigned 8-bit integer value is at min valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 377: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 377 : Write max valid value to a range-restricted unsigned 8-bit integer\n");
            uint8_t value;
            value = 100;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 378: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 378 : Verify range-restricted unsigned 8-bit integer value is at max valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 379: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 379 : Write middle valid value to a range-restricted unsigned 8-bit integer\n");
            uint8_t value;
            value = 50;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 380: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 380 : Verify range-restricted unsigned 8-bit integer value is at mid valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 381: {
            ChipLogProgress(chipTool, " ***** Test Step 381 : Read range-restricted unsigned 16-bit integer\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 382: {
            ChipLogProgress(chipTool, " ***** Test Step 382 : Write min value to a range-restricted unsigned 16-bit integer\n");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 383: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 383 : Write just-below-range value to a range-restricted unsigned 16-bit integer\n");
            uint16_t value;
            value = 99U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 384: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 384 : Write just-above-range value to a range-restricted unsigned 16-bit integer\n");
            uint16_t value;
            value = 1001U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 385: {
            ChipLogProgress(chipTool, " ***** Test Step 385 : Write max value to a range-restricted unsigned 16-bit integer\n");
            uint16_t value;
            value = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 386: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 386 : Verify range-restricted unsigned 16-bit integer value has not changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 387: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 387 : Write min valid value to a range-restricted unsigned 16-bit integer\n");
            uint16_t value;
            value = 100U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 388: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 388 : Verify range-restricted unsigned 16-bit integer value is at min valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 389: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 389 : Write max valid value to a range-restricted unsigned 16-bit integer\n");
            uint16_t value;
            value = 1000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 390: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 390 : Verify range-restricted unsigned 16-bit integer value is at max valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 391: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 391 : Write middle valid value to a range-restricted unsigned 16-bit integer\n");
            uint16_t value;
            value = 500U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 392: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 392 : Verify range-restricted unsigned 16-bit integer value is at mid valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 393: {
            ChipLogProgress(chipTool, " ***** Test Step 393 : Read range-restricted signed 8-bit integer\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 394: {
            ChipLogProgress(chipTool, " ***** Test Step 394 : Write min value to a range-restricted signed 8-bit integer\n");
            int8_t value;
            value = -128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 395: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 395 : Write just-below-range value to a range-restricted signed 8-bit integer\n");
            int8_t value;
            value = -41;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 396: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 396 : Write just-above-range value to a range-restricted signed 8-bit integer\n");
            int8_t value;
            value = 51;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 397: {
            ChipLogProgress(chipTool, " ***** Test Step 397 : Write max value to a range-restricted signed 8-bit integer\n");
            int8_t value;
            value = 127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 398: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 398 : Verify range-restricted signed 8-bit integer value has not changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 399: {
            ChipLogProgress(chipTool, " ***** Test Step 399 : Write min valid value to a range-restricted signed 8-bit integer\n");
            int8_t value;
            value = -40;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 400: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 400 : Verify range-restricted signed 8-bit integer value is at min valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 401: {
            ChipLogProgress(chipTool, " ***** Test Step 401 : Write max valid value to a range-restricted signed 8-bit integer\n");
            int8_t value;
            value = 50;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 402: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 402 : Verify range-restricted signed 8-bit integer value is at max valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 403: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 403 : Write middle valid value to a range-restricted signed 8-bit integer\n");
            int8_t value;
            value = 6;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 404: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 404 : Verify range-restricted signed 8-bit integer value is at mid valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 405: {
            ChipLogProgress(chipTool, " ***** Test Step 405 : Read range-restricted signed 16-bit integer\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 406: {
            ChipLogProgress(chipTool, " ***** Test Step 406 : Write min value to a range-restricted signed 16-bit integer\n");
            int16_t value;
            value = -32768;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 407: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 407 : Write just-below-range value to a range-restricted signed 16-bit integer\n");
            int16_t value;
            value = -151;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 408: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 408 : Write just-above-range value to a range-restricted signed 16-bit integer\n");
            int16_t value;
            value = 201;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 409: {
            ChipLogProgress(chipTool, " ***** Test Step 409 : Write max value to a range-restricted signed 16-bit integer\n");
            int16_t value;
            value = 32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 410: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 410 : Verify range-restricted signed 16-bit integer value has not changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 411: {
            ChipLogProgress(chipTool, " ***** Test Step 411 : Write min valid value to a range-restricted signed 16-bit integer\n");
            int16_t value;
            value = -150;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 412: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 412 : Verify range-restricted signed 16-bit integer value is at min valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 413: {
            ChipLogProgress(chipTool, " ***** Test Step 413 : Write max valid value to a range-restricted signed 16-bit integer\n");
            int16_t value;
            value = 200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 414: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 414 : Verify range-restricted signed 16-bit integer value is at max valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 415: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 415 : Write middle valid value to a range-restricted signed 16-bit integer\n");
            int16_t value;
            value = 7;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 416: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 416 : Verify range-restricted signed 16-bit integer value is at mid valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 417: {
            ChipLogProgress(chipTool, " ***** Test Step 417 : Read nullable range-restricted unsigned 8-bit integer\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 418: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 418 : Write min value to a nullable range-restricted unsigned 8-bit integer\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 419: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 419 : Write just-below-range value to a nullable range-restricted unsigned 8-bit integer\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 19;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 420: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 420 : Write just-above-range value to a nullable range-restricted unsigned 8-bit integer\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 101;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 421: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 421 : Write max value to a nullable range-restricted unsigned 8-bit integer\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 422: {
            ChipLogProgress(
                chipTool, " ***** Test Step 422 : Verify nullable range-restricted unsigned 8-bit integer value has not changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 423: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 423 : Write min valid value to a nullable range-restricted unsigned 8-bit integer\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 20;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 424: {
            ChipLogProgress(
                chipTool, " ***** Test Step 424 : Verify nullable range-restricted unsigned 8-bit integer value is at min valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 425: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 425 : Write max valid value to a nullable range-restricted unsigned 8-bit integer\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 100;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 426: {
            ChipLogProgress(
                chipTool, " ***** Test Step 426 : Verify nullable range-restricted unsigned 8-bit integer value is at max valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 427: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 427 : Write middle valid value to a nullable range-restricted unsigned 8-bit integer\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 50;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 428: {
            ChipLogProgress(
                chipTool, " ***** Test Step 428 : Verify nullable range-restricted unsigned 8-bit integer value is at mid valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 429: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 429 : Write null value to a nullable range-restricted unsigned 8-bit integer\n");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 430: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 430 : Verify nullable range-restricted unsigned 8-bit integer value is null\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 431: {
            ChipLogProgress(chipTool, " ***** Test Step 431 : Read nullable range-restricted unsigned 16-bit integer\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 432: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 432 : Write min value to a nullable range-restricted unsigned 16-bit integer\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 433: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 433 : Write just-below-range value to a nullable range-restricted unsigned 16-bit integer\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 99U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 434: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 434 : Write just-above-range value to a nullable range-restricted unsigned 16-bit integer\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 1001U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 435: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 435 : Write max value to a nullable range-restricted unsigned 16-bit integer\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65534U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 436: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 436 : Verify nullable range-restricted unsigned 16-bit integer value has not changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 437: {
            ChipLogProgress(
                chipTool, " ***** Test Step 437 : Write min valid value to a nullable range-restricted unsigned 16-bit integer\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 100U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 438: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 438 : Verify nullable range-restricted unsigned 16-bit integer value is at min valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 439: {
            ChipLogProgress(
                chipTool, " ***** Test Step 439 : Write max valid value to a nullable range-restricted unsigned 16-bit integer\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 1000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 440: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 440 : Verify nullable range-restricted unsigned 16-bit integer value is at max valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 441: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 441 : Write middle valid value to a nullable range-restricted unsigned 16-bit integer\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 500U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 442: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 442 : Verify nullable range-restricted unsigned 16-bit integer value is at mid valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 443: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 443 : Write null value to a nullable range-restricted unsigned 16-bit integer\n");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 444: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 444 : Verify nullable range-restricted unsigned 16-bit integer value is null\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 445: {
            ChipLogProgress(chipTool, " ***** Test Step 445 : Read nullable range-restricted signed 8-bit integer\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 446: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 446 : Write min value to a nullable range-restricted signed 8-bit integer\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 447: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 447 : Write just-below-range value to a nullable range-restricted signed 8-bit integer\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -41;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 448: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 448 : Write just-above-range value to a nullable range-restricted signed 8-bit integer\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = 51;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 449: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 449 : Write max value to a nullable range-restricted signed 8-bit integer\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = 127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 450: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 450 : Verify nullable range-restricted signed 8-bit integer value has not changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 451: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 451 : Write min valid value to a nullable range-restricted signed 8-bit integer\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -40;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 452: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 452 : Verify nullable range-restricted signed 8-bit integer value is at min valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 453: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 453 : Write max valid value to a nullable range-restricted signed 8-bit integer\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = 50;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 454: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 454 : Verify nullable range-restricted signed 8-bit integer value is at max valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 455: {
            ChipLogProgress(
                chipTool, " ***** Test Step 455 : Write middle valid value to a nullable range-restricted signed 8-bit integer\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = 6;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 456: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 456 : Verify nullable range-restricted signed 8-bit integer value is at mid valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 457: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 457 : Write null value to a nullable range-restricted signed 8-bit integer\n");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 458: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 458 : Verify nullable range-restricted signed 8-bit integer value is at null\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 459: {
            ChipLogProgress(chipTool, " ***** Test Step 459 : Read nullable range-restricted signed 16-bit integer\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 460: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 460 : Write min value to a nullable range-restricted signed 16-bit integer\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 461: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 461 : Write just-below-range value to a nullable range-restricted signed 16-bit integer\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -151;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 462: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 462 : Write just-above-range value to a nullable range-restricted signed 16-bit integer\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 201;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 463: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 463 : Write max value to a nullable range-restricted signed 16-bit integer\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 464: {
            ChipLogProgress(
                chipTool, " ***** Test Step 464 : Verify nullable range-restricted signed 16-bit integer value has not changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 465: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 465 : Write min valid value to a nullable range-restricted signed 16-bit integer\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -150;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 466: {
            ChipLogProgress(
                chipTool, " ***** Test Step 466 : Verify nullable range-restricted signed 16-bit integer value is at min valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 467: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 467 : Write max valid value to a nullable range-restricted signed 16-bit integer\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 468: {
            ChipLogProgress(
                chipTool, " ***** Test Step 468 : Verify nullable range-restricted signed 16-bit integer value is at max valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 469: {
            ChipLogProgress(
                chipTool, " ***** Test Step 469 : Write middle valid value to a nullable range-restricted signed 16-bit integer\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 7;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 470: {
            ChipLogProgress(
                chipTool, " ***** Test Step 470 : Verify nullable range-restricted signed 16-bit integer value is at mid valid\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 471: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 471 : Write null value to a nullable range-restricted signed 16-bit integer\n");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 472: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 472 : Verify nullable range-restricted signed 16-bit integer value is null\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 473: {
            ChipLogProgress(chipTool, " ***** Test Step 473 : Write attribute that returns general status on write\n");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::GeneralErrorBoolean::Id,
                                  value);
        }
        case 474: {
            ChipLogProgress(chipTool, " ***** Test Step 474 : Write attribute that returns cluster-specific status on write\n");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ClusterErrorBoolean::Id,
                                  value);
        }
        case 475: {
            ChipLogProgress(chipTool, " ***** Test Step 475 : Read attribute that returns general status on read\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::GeneralErrorBoolean::Id);
        }
        case 476: {
            ChipLogProgress(chipTool, " ***** Test Step 476 : read attribute that returns cluster-specific status on read\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ClusterErrorBoolean::Id);
        }
        case 477: {
            ChipLogProgress(chipTool, " ***** Test Step 477 : read ClientGeneratedCommandList attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::ClientGeneratedCommandList::Id);
        }
        case 478: {
            ChipLogProgress(chipTool, " ***** Test Step 478 : read ServerGeneratedCommandList attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::ServerGeneratedCommandList::Id);
        }
        case 479: {
            ChipLogProgress(chipTool, " ***** Test Step 479 : Write struct-typed attribute\n");
            chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type value;

            value.a = 5;
            value.b = true;
            value.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.d = chip::ByteSpan(chip::Uint8::from_const_char("abcgarbage: not in length on purpose"), 3);
            value.e = chip::Span<const char>("garbage: not in length on purpose", 0);
            value.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(17);
            value.g = 1.5f;
            value.h = 3.14159265358979;

            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::StructAttr::Id, value);
        }
        case 480: {
            ChipLogProgress(chipTool, " ***** Test Step 480 : Read struct-typed attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::StructAttr::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestSpecificResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, 7));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, 20));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, 1));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, 0));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, 0));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, 255));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, 0));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, 0U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, 65535U));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, 0U));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, 0UL));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, 4294967295UL));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, 0UL));
            }
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, 0ULL));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, 18446744073709551615ULL));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, 0ULL));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, 0));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, 255));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, 0));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, 0U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, 65535U));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, 0U));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, 0UL));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, 4294967295UL));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, 0UL));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, 0ULL));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, 18446744073709551615ULL));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, 0ULL));
            }
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, 0));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, 127));
            }
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, -128));
            }
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, 0));
            }
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, 0));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, 32767));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, -32768));
            }
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, 0));
            }
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, 0L));
            }
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, 2147483647L));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, -2147483648L));
            }
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, 0L));
            }
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, 0LL));
            }
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, 9223372036854775807LL));
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, -9223372036854775807LL));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, 0LL));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 0.0f));
            }
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 0.1f));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 17000000000.0f));
            }
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 1.7e-10f));
            }
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 0.0f));
            }
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 0));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 0.1234567890123));
            }
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 1.7e+200));
            }
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 1.7e-200));
            }
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 0));
            }
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, 0));
            }
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, 255));
            }
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, 0));
            }
            break;
        case 102:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, 0U));
            }
            break;
        case 103:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 104:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, 65535U));
            }
            break;
        case 105:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 106:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, 0U));
            }
            break;
        case 107:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
            }
            break;
        case 108:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 109:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("Tes\x00ti\x00ng"), 9)));
            }
            break;
        case 110:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 111:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value,
                                                  chip::ByteSpan(chip::Uint8::from_const_char("\x0d\x0a\xff\x22\xa0"), 5)));
            }
            break;
        case 112:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 113:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
            }
            break;
        case 114:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 115:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
            }
            break;
        case 116:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 117:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("longOctetString", value, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
            }
            break;
        case 118:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 119:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString(
                    "longOctetString", value,
                    chip::ByteSpan(
                        chip::Uint8::from_const_char(
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"),
                        300)));
            }
            break;
        case 120:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 121:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("", 0)));
            }
            break;
        case 122:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 123:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("T", 7)));
            }
            break;
        case 124:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 125:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("T", 7)));
            }
            break;
        case 126:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 127:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("longCharString", value, chip::CharSpan("", 0)));
            }
            break;
        case 128:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 129:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString(
                    "longCharString", value,
                    chip::CharSpan(
                        ""
                        ""
                        "",
                        900)));
            }
            break;
        case 130:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 131:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[0]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[1]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[2]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 3));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[3]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listLongOctetString", iter_0, 4));
                }
            }
            break;
        case 132:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 133:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[0]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[1]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[2]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 3));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[3]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 4));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[4]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listLongOctetString", iter_0, 5));
                }
            }
            break;
        case 134:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, 0ULL));
            }
            break;
        case 135:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 136:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, 18446744073709551615ULL));
            }
            break;
        case 137:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 138:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, 0ULL));
            }
            break;
        case 139:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, 0UL));
            }
            break;
        case 140:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 141:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, 4294967295UL));
            }
            break;
        case 142:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 143:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, 0UL));
            }
            break;
        case 144:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("unsupported", value, 0));
            }
            break;
        case 145:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 146:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ENDPOINT));
            break;
        case 147:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER));
            break;
        case 148:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorId", value, 0U));
            }
            break;
        case 149:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 150:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorId", value, 17U));
            }
            break;
        case 151:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 152:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestEnumsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("arg1", value.arg1, 20003U));
                VerifyOrReturn(CheckValue("arg2", value.arg2, 101));
            }
            break;
        case 153:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 154:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 155:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 156:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 157:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 158:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 159:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::SimpleStructResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("arg1.a", value.arg1.a, 17));
                VerifyOrReturn(CheckValue("arg1.b", value.arg1.b, false));
                VerifyOrReturn(CheckValue("arg1.c", value.arg1.c, 2));
                VerifyOrReturn(
                    CheckValueAsString("arg1.d", value.arg1.d, chip::ByteSpan(chip::Uint8::from_const_char("octet_string"), 12)));
                VerifyOrReturn(CheckValueAsString("arg1.e", value.arg1.e, chip::CharSpan("char_string", 11)));
                VerifyOrReturn(CheckValue("arg1.f", value.arg1.f, 1));
                VerifyOrReturn(CheckValue("arg1.g", value.arg1.g, 0.1f));
                VerifyOrReturn(CheckValue("arg1.h", value.arg1.h, 0.1));
            }
            break;
        case 160:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 161:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 162:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.arg1.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 0));
                    VerifyOrReturn(CheckValue("arg1[0]", iter_0.GetValue(), 9));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 1));
                    VerifyOrReturn(CheckValue("arg1[1]", iter_0.GetValue(), 8));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 2));
                    VerifyOrReturn(CheckValue("arg1[2]", iter_0.GetValue(), 7));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 3));
                    VerifyOrReturn(CheckValue("arg1[3]", iter_0.GetValue(), 6));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 4));
                    VerifyOrReturn(CheckValue("arg1[4]", iter_0.GetValue(), 5));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 5));
                    VerifyOrReturn(CheckValue("arg1[5]", iter_0.GetValue(), 4));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 6));
                    VerifyOrReturn(CheckValue("arg1[6]", iter_0.GetValue(), 3));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 7));
                    VerifyOrReturn(CheckValue("arg1[7]", iter_0.GetValue(), 2));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 8));
                    VerifyOrReturn(CheckValue("arg1[8]", iter_0.GetValue(), 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.arg1)>("arg1", iter_0, 9));
                }
            }
            break;
        case 163:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.arg1.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.arg1)>("arg1", iter_0, 0));
                }
            }
            break;
        case 164:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 165:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 166:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 167:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 168:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 169:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 0));
                    VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 1));
                    VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 2));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 2));
                    VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 3));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 3));
                    VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 4));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listInt8u", iter_0, 4));
                }
            }
            break;
        case 170:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 171:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listOctetString", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("listOctetString[0]", iter_0.GetValue(),
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listOctetString", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString("listOctetString[1]", iter_0.GetValue(),
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listOctetString", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString("listOctetString[2]", iter_0.GetValue(),
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listOctetString", iter_0, 3));
                    VerifyOrReturn(CheckValueAsString("listOctetString[3]", iter_0.GetValue(),
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listOctetString", iter_0, 4));
                }
            }
            break;
        case 172:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 173:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listStructOctetString", iter_0, 0));
                    VerifyOrReturn(CheckValue("listStructOctetString[0].fabricIndex", iter_0.GetValue().fabricIndex, 0ULL));
                    VerifyOrReturn(CheckValueAsString("listStructOctetString[0].operationalCert", iter_0.GetValue().operationalCert,
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listStructOctetString", iter_0, 1));
                    VerifyOrReturn(CheckValue("listStructOctetString[1].fabricIndex", iter_0.GetValue().fabricIndex, 1ULL));
                    VerifyOrReturn(CheckValueAsString("listStructOctetString[1].operationalCert", iter_0.GetValue().operationalCert,
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listStructOctetString", iter_0, 2));
                    VerifyOrReturn(CheckValue("listStructOctetString[2].fabricIndex", iter_0.GetValue().fabricIndex, 2ULL));
                    VerifyOrReturn(CheckValueAsString("listStructOctetString[2].operationalCert", iter_0.GetValue().operationalCert,
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listStructOctetString", iter_0, 3));
                    VerifyOrReturn(CheckValue("listStructOctetString[3].fabricIndex", iter_0.GetValue().fabricIndex, 3ULL));
                    VerifyOrReturn(CheckValueAsString("listStructOctetString[3].operationalCert", iter_0.GetValue().operationalCert,
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listStructOctetString", iter_0, 4));
                }
            }
            break;
        case 174:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("wasPresent", value.wasPresent, true));
                VerifyOrReturn(CheckValuePresent("wasNull", value.wasNull));
                VerifyOrReturn(CheckValue("wasNull.Value()", value.wasNull.Value(), false));
                VerifyOrReturn(CheckValuePresent("value", value.value));
                VerifyOrReturn(CheckValue("value.Value()", value.value.Value(), 5));
                VerifyOrReturn(CheckValuePresent("originalValue", value.originalValue));
                VerifyOrReturn(CheckValueNonNull("originalValue.Value()", value.originalValue.Value()));
                VerifyOrReturn(CheckValue("originalValue.Value().Value()", value.originalValue.Value().Value(), 5));
            }
            break;
        case 175:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("wasPresent", value.wasPresent, false));
            }
            break;
        case 176:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listNullablesAndOptionalsStruct", iter_0, 0));
                    VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableInt", iter_0.GetValue().nullableInt));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableString", iter_0.GetValue().nullableString));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableStruct", iter_0.GetValue().nullableStruct));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableList", iter_0.GetValue().nullableList));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listNullablesAndOptionalsStruct", iter_0, 1));
                }
            }
            break;
        case 177:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 178:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listNullablesAndOptionalsStruct", iter_0, 0));
                    VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableInt", iter_0.GetValue().nullableInt));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableString", iter_0.GetValue().nullableString));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableStruct", iter_0.GetValue().nullableStruct));
                    VerifyOrReturn(
                        CheckValueNonNull("listNullablesAndOptionalsStruct[0].nullableList", iter_0.GetValue().nullableList));
                    {
                        auto iter_NaN = iter_0.GetValue().nullableList.Value().begin();
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().nullableList.Value())>(
                            "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 0));
                        VerifyOrReturn(
                            CheckValue("listNullablesAndOptionalsStruct[0].nullableList.Value()[0]", iter_NaN.GetValue(), 1));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().nullableList.Value())>(
                            "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 1));
                        VerifyOrReturn(
                            CheckValue("listNullablesAndOptionalsStruct[0].nullableList.Value()[1]", iter_NaN.GetValue(), 2));
                        VerifyOrReturn(CheckNoMoreListItems<decltype(iter_0.GetValue().nullableList.Value())>(
                            "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 2));
                    }
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listNullablesAndOptionalsStruct", iter_0, 1));
                }
            }
            break;
        case 179:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 180:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<bool> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBoolean", value));
            }
            break;
        case 181:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 182:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<bool> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBoolean", value));
                VerifyOrReturn(CheckValue("nullableBoolean.Value()", value.Value(), true));
            }
            break;
        case 183:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 184:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap8", value));
                VerifyOrReturn(CheckValue("nullableBitmap8.Value()", value.Value(), 254));
            }
            break;
        case 185:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 186:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap8", value));
                VerifyOrReturn(CheckValue("nullableBitmap8.Value()", value.Value(), 254));
            }
            break;
        case 187:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 188:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBitmap8", value));
            }
            break;
        case 189:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 190:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap16", value));
                VerifyOrReturn(CheckValue("nullableBitmap16.Value()", value.Value(), 65534U));
            }
            break;
        case 191:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 192:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap16", value));
                VerifyOrReturn(CheckValue("nullableBitmap16.Value()", value.Value(), 65534U));
            }
            break;
        case 193:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 194:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBitmap16", value));
            }
            break;
        case 195:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 196:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap32", value));
                VerifyOrReturn(CheckValue("nullableBitmap32.Value()", value.Value(), 4294967294UL));
            }
            break;
        case 197:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 198:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap32", value));
                VerifyOrReturn(CheckValue("nullableBitmap32.Value()", value.Value(), 4294967294UL));
            }
            break;
        case 199:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 200:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBitmap32", value));
            }
            break;
        case 201:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 202:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap64", value));
                VerifyOrReturn(CheckValue("nullableBitmap64.Value()", value.Value(), 18446744073709551614ULL));
            }
            break;
        case 203:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 204:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap64", value));
                VerifyOrReturn(CheckValue("nullableBitmap64.Value()", value.Value(), 18446744073709551614ULL));
            }
            break;
        case 205:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 206:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBitmap64", value));
            }
            break;
        case 207:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 208:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8u", value));
                VerifyOrReturn(CheckValue("nullableInt8u.Value()", value.Value(), 0));
            }
            break;
        case 209:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 210:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8u", value));
                VerifyOrReturn(CheckValue("nullableInt8u.Value()", value.Value(), 254));
            }
            break;
        case 211:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 212:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8u", value));
                VerifyOrReturn(CheckValue("nullableInt8u.Value()", value.Value(), 254));
            }
            break;
        case 213:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("value", value));
            }
            break;
        case 214:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 215:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt8u", value));
            }
            break;
        case 216:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 254));
            }
            break;
        case 217:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 254));
            }
            break;
        case 218:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 219:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("value", value, 254));
            }
            break;
        case 220:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 129));
            }
            break;
        case 221:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 222:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16u", value));
                VerifyOrReturn(CheckValue("nullableInt16u.Value()", value.Value(), 0U));
            }
            break;
        case 223:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 224:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16u", value));
                VerifyOrReturn(CheckValue("nullableInt16u.Value()", value.Value(), 65534U));
            }
            break;
        case 225:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 226:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16u", value));
                VerifyOrReturn(CheckValue("nullableInt16u.Value()", value.Value(), 65534U));
            }
            break;
        case 227:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 228:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt16u", value));
            }
            break;
        case 229:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65534U));
            }
            break;
        case 230:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 65534U));
            }
            break;
        case 231:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 232:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value", value, 65534U));
            }
            break;
        case 233:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 32001U));
            }
            break;
        case 234:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 235:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32u", value));
                VerifyOrReturn(CheckValue("nullableInt32u.Value()", value.Value(), 0UL));
            }
            break;
        case 236:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 237:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32u", value));
                VerifyOrReturn(CheckValue("nullableInt32u.Value()", value.Value(), 4294967294UL));
            }
            break;
        case 238:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 239:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32u", value));
                VerifyOrReturn(CheckValue("nullableInt32u.Value()", value.Value(), 4294967294UL));
            }
            break;
        case 240:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 241:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt32u", value));
            }
            break;
        case 242:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint32_t>("value", value, 0UL));
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("value", value, 4294967294UL));
            }
            break;
        case 243:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 4294967294UL));
            }
            break;
        case 244:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 245:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint32_t>("value", value, 0UL));
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("value", value, 4294967294UL));
            }
            break;
        case 246:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 2147483648UL));
            }
            break;
        case 247:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 248:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64u", value));
                VerifyOrReturn(CheckValue("nullableInt64u.Value()", value.Value(), 0ULL));
            }
            break;
        case 249:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 250:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64u", value));
                VerifyOrReturn(CheckValue("nullableInt64u.Value()", value.Value(), 18446744073709551614ULL));
            }
            break;
        case 251:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 252:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64u", value));
                VerifyOrReturn(CheckValue("nullableInt64u.Value()", value.Value(), 18446744073709551614ULL));
            }
            break;
        case 253:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 254:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt64u", value));
            }
            break;
        case 255:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint64_t>("value", value, 0ULL));
                VerifyOrReturn(CheckConstraintMaxValue<uint64_t>("value", value, 18446744073709551614ULL));
            }
            break;
        case 256:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 18446744073709551614ULL));
            }
            break;
        case 257:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 258:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint64_t>("value", value, 0ULL));
                VerifyOrReturn(CheckConstraintMaxValue<uint64_t>("value", value, 18446744073709551614ULL));
            }
            break;
        case 259:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 18000000000000000001ULL));
            }
            break;
        case 260:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 261:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8s", value));
                VerifyOrReturn(CheckValue("nullableInt8s.Value()", value.Value(), -127));
            }
            break;
        case 262:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 263:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8s", value));
                VerifyOrReturn(CheckValue("nullableInt8s.Value()", value.Value(), -127));
            }
            break;
        case 264:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 265:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt8s", value));
            }
            break;
        case 266:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<int8_t>("value", value, -127));
                VerifyOrReturn(CheckConstraintMaxValue<int8_t>("value", value, 127));
            }
            break;
        case 267:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -127));
            }
            break;
        case 268:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 269:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<int8_t>("value", value, -127));
                VerifyOrReturn(CheckConstraintMaxValue<int8_t>("value", value, 127));
            }
            break;
        case 270:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -126));
            }
            break;
        case 271:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 272:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16s", value));
                VerifyOrReturn(CheckValue("nullableInt16s.Value()", value.Value(), -32767));
            }
            break;
        case 273:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 274:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16s", value));
                VerifyOrReturn(CheckValue("nullableInt16s.Value()", value.Value(), -32767));
            }
            break;
        case 275:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 276:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt16s", value));
            }
            break;
        case 277:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, -32767));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 32767));
            }
            break;
        case 278:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -32767));
            }
            break;
        case 279:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 280:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("value", value, -32767));
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("value", value, 32767));
            }
            break;
        case 281:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -32766));
            }
            break;
        case 282:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 283:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32s", value));
                VerifyOrReturn(CheckValue("nullableInt32s.Value()", value.Value(), -2147483647L));
            }
            break;
        case 284:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 285:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32s", value));
                VerifyOrReturn(CheckValue("nullableInt32s.Value()", value.Value(), -2147483647L));
            }
            break;
        case 286:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 287:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt32s", value));
            }
            break;
        case 288:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<int32_t>("value", value, -2147483647L));
                VerifyOrReturn(CheckConstraintMaxValue<int32_t>("value", value, 2147483647L));
            }
            break;
        case 289:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -2147483647L));
            }
            break;
        case 290:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 291:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<int32_t>("value", value, -2147483647L));
                VerifyOrReturn(CheckConstraintMaxValue<int32_t>("value", value, 2147483647L));
            }
            break;
        case 292:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -2147483646L));
            }
            break;
        case 293:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 294:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64s", value));
                VerifyOrReturn(CheckValue("nullableInt64s.Value()", value.Value(), -9223372036854775807LL));
            }
            break;
        case 295:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 296:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64s", value));
                VerifyOrReturn(CheckValue("nullableInt64s.Value()", value.Value(), -9223372036854775807LL));
            }
            break;
        case 297:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 298:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt64s", value));
            }
            break;
        case 299:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<int64_t>("value", value, -9223372036854775807LL));
                VerifyOrReturn(CheckConstraintMaxValue<int64_t>("value", value, 9223372036854775807LL));
            }
            break;
        case 300:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -9223372036854775807LL));
            }
            break;
        case 301:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 302:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<int64_t>("value", value, -9223372036854775807LL));
                VerifyOrReturn(CheckConstraintMaxValue<int64_t>("value", value, 9223372036854775807LL));
            }
            break;
        case 303:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -9223372036854775806LL));
            }
            break;
        case 304:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 305:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", value));
                VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", value.Value(), 0.1f));
            }
            break;
        case 306:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 307:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", value));
                VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", value.Value(), INFINITY));
            }
            break;
        case 308:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 309:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", value));
                VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", value.Value(), -INFINITY));
            }
            break;
        case 310:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 311:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableFloatSingle", value));
            }
            break;
        case 312:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 313:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", value));
                VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", value.Value(), 0.0f));
            }
            break;
        case 314:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 315:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", value));
                VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", value.Value(), 0.1234567890123));
            }
            break;
        case 316:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 317:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", value));
                VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", value.Value(), INFINITY));
            }
            break;
        case 318:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 319:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", value));
                VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", value.Value(), -INFINITY));
            }
            break;
        case 320:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 321:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableFloatDouble", value));
            }
            break;
        case 322:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 323:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", value));
                VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", value.Value(), 0));
            }
            break;
        case 324:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 325:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum8", value));
                VerifyOrReturn(CheckValue("nullableEnum8.Value()", value.Value(), 0));
            }
            break;
        case 326:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 327:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum8", value));
                VerifyOrReturn(CheckValue("nullableEnum8.Value()", value.Value(), 254));
            }
            break;
        case 328:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 329:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum8", value));
                VerifyOrReturn(CheckValue("nullableEnum8.Value()", value.Value(), 254));
            }
            break;
        case 330:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 331:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableEnum8", value));
            }
            break;
        case 332:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 333:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum16", value));
                VerifyOrReturn(CheckValue("nullableEnum16.Value()", value.Value(), 0U));
            }
            break;
        case 334:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 335:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum16", value));
                VerifyOrReturn(CheckValue("nullableEnum16.Value()", value.Value(), 65534U));
            }
            break;
        case 336:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 337:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum16", value));
                VerifyOrReturn(CheckValue("nullableEnum16.Value()", value.Value(), 65534U));
            }
            break;
        case 338:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 339:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableEnum16", value));
            }
            break;
        case 340:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 341:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", value));
                VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", value.Value(), 0));
            }
            break;
        case 342:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 343:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", value));
                VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", value.Value(), 254));
            }
            break;
        case 344:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 345:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", value));
                VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", value.Value(), 254));
            }
            break;
        case 346:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 347:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableEnumAttr", value));
            }
            break;
        case 348:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableOctetString", value));
                VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", value.Value(),
                                                  chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
            }
            break;
        case 349:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 350:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableOctetString", value));
                VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", value.Value(),
                                                  chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
            }
            break;
        case 351:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 352:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableOctetString", value));
            }
            break;
        case 353:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 354:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableOctetString", value));
                VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", value.Value(),
                                                  chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
            }
            break;
        case 355:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableCharString", value));
                VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", value.Value(), chip::CharSpan("", 0)));
            }
            break;
        case 356:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 357:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableCharString", value));
                VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", value.Value(), chip::CharSpan("T", 7)));
            }
            break;
        case 358:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 359:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableCharString", value));
            }
            break;
        case 360:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 361:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableCharString", value));
                VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", value.Value(), chip::CharSpan("", 0)));
            }
            break;
        case 362:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ENDPOINT));
            break;
        case 363:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER));
            break;
        case 364:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_VALUE));
            break;
        case 365:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 366:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 0));
                    VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 1));
                    VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 2));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 2));
                    VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 3));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 3));
                    VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 4));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listInt8u", iter_0, 4));
                }
            }
            break;
        case 367:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 368:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 0));
                    VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 5));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 1));
                    VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 6));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 2));
                    VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 7));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 3));
                    VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 8));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listInt8u", iter_0, 4));
                }
            }
            shouldContinue = true;
            break;
        case 369:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 70));
            }
            break;
        case 370:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 371:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 372:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 373:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 374:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 70));
            }
            break;
        case 375:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 376:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 20));
            }
            break;
        case 377:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 378:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 100));
            }
            break;
        case 379:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 380:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 50));
            }
            break;
        case 381:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 200U));
            }
            break;
        case 382:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 383:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 384:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 385:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 386:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 200U));
            }
            break;
        case 387:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 388:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 100U));
            }
            break;
        case 389:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 390:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 1000U));
            }
            break;
        case 391:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 392:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 500U));
            }
            break;
        case 393:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, -20));
            }
            break;
        case 394:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 395:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 396:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 397:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 398:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, -20));
            }
            break;
        case 399:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 400:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, -40));
            }
            break;
        case 401:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 402:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, 50));
            }
            break;
        case 403:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 404:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, 6));
            }
            break;
        case 405:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, -100));
            }
            break;
        case 406:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 407:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 408:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 409:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 410:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, -100));
            }
            break;
        case 411:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 412:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, -150));
            }
            break;
        case 413:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 414:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, 200));
            }
            break;
        case 415:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 416:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, 7));
            }
            break;
        case 417:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 70));
            }
            break;
        case 418:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 419:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 420:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 421:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 422:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 70));
            }
            break;
        case 423:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 424:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 20));
            }
            break;
        case 425:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 426:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 100));
            }
            break;
        case 427:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 428:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 50));
            }
            break;
        case 429:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 430:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt8u", value));
            }
            break;
        case 431:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 200U));
            }
            break;
        case 432:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 433:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 434:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 435:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 436:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 200U));
            }
            break;
        case 437:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 438:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 100U));
            }
            break;
        case 439:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 440:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 1000U));
            }
            break;
        case 441:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 442:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 500U));
            }
            break;
        case 443:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 444:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt16u", value));
            }
            break;
        case 445:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), -20));
            }
            break;
        case 446:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 447:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 448:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 449:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 450:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), -20));
            }
            break;
        case 451:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 452:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), -40));
            }
            break;
        case 453:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 454:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), 50));
            }
            break;
        case 455:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 456:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), 6));
            }
            break;
        case 457:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 458:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt8s", value));
            }
            break;
        case 459:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), -100));
            }
            break;
        case 460:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 461:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 462:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 463:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 464:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), -100));
            }
            break;
        case 465:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 466:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), -150));
            }
            break;
        case 467:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 468:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), 200));
            }
            break;
        case 469:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 470:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), 7));
            }
            break;
        case 471:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 472:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt16s", value));
            }
            break;
        case 473:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_DATA_TYPE));
            break;
        case 474:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 475:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_DATA_TYPE));
            break;
        case 476:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 477:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 0));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 1));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 2));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[2]", iter_0.GetValue(), 2UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 3));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[3]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 4));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[4]", iter_0.GetValue(), 7UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 5));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[5]", iter_0.GetValue(), 8UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 6));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[6]", iter_0.GetValue(), 9UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 7));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[7]", iter_0.GetValue(), 10UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 8));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[8]", iter_0.GetValue(), 11UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 9));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[9]", iter_0.GetValue(), 12UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 10));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[10]", iter_0.GetValue(), 13UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 11));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[11]", iter_0.GetValue(), 14UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 12));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[12]", iter_0.GetValue(), 15UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 13));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[13]", iter_0.GetValue(), 17UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 14));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[14]", iter_0.GetValue(), 18UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 15));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[15]", iter_0.GetValue(), 19UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 16));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[16]", iter_0.GetValue(), 20UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientGeneratedCommandList", iter_0, 17));
                    VerifyOrReturn(CheckValue("clientGeneratedCommandList[17]", iter_0.GetValue(), 21UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("clientGeneratedCommandList", iter_0, 18));
                }
            }
            break;
        case 478:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverGeneratedCommandList", iter_0, 0));
                    VerifyOrReturn(CheckValue("serverGeneratedCommandList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverGeneratedCommandList", iter_0, 1));
                    VerifyOrReturn(CheckValue("serverGeneratedCommandList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverGeneratedCommandList", iter_0, 2));
                    VerifyOrReturn(CheckValue("serverGeneratedCommandList[2]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverGeneratedCommandList", iter_0, 3));
                    VerifyOrReturn(CheckValue("serverGeneratedCommandList[3]", iter_0.GetValue(), 5UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverGeneratedCommandList", iter_0, 4));
                    VerifyOrReturn(CheckValue("serverGeneratedCommandList[4]", iter_0.GetValue(), 6UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverGeneratedCommandList", iter_0, 5));
                    VerifyOrReturn(CheckValue("serverGeneratedCommandList[5]", iter_0.GetValue(), 9UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverGeneratedCommandList", iter_0, 6));
                    VerifyOrReturn(CheckValue("serverGeneratedCommandList[6]", iter_0.GetValue(), 10UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverGeneratedCommandList", iter_0, 7));
                    VerifyOrReturn(CheckValue("serverGeneratedCommandList[7]", iter_0.GetValue(), 11UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("serverGeneratedCommandList", iter_0, 8));
                }
            }
            break;
        case 479:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 480:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("structAttr.a", value.a, 5));
                VerifyOrReturn(CheckValue("structAttr.b", value.b, true));
                VerifyOrReturn(CheckValue("structAttr.c", value.c, 2));
                VerifyOrReturn(CheckValueAsString("structAttr.d", value.d, chip::ByteSpan(chip::Uint8::from_const_char("abc"), 3)));
                VerifyOrReturn(CheckValueAsString("structAttr.e", value.e, chip::CharSpan("", 0)));
                VerifyOrReturn(CheckValue("structAttr.f", value.f, 17));
                VerifyOrReturn(CheckValue("structAttr.g", value.g, 1.5f));
                VerifyOrReturn(CheckValue("structAttr.h", value.h, 3.14159265358979));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestClusterComplexTypesSuite : public TestCommand
{
public:
    TestClusterComplexTypesSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestClusterComplexTypes", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestClusterComplexTypesSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestClusterComplexTypes\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestClusterComplexTypes\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 21;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command with optional arg set to null.\n");
            chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type value;
            value.arg1.Emplace();
            value.arg1.Value().SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNullableOptionalRequest::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send command that needs timed invoke without a timeout value\n");
            chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TimedInvokeRequest::Id,
                               value, chip::NullOptional);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send command that needs timed invoke with a long timeout value\n");
            chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TimedInvokeRequest::Id,
                               value, chip::Optional<uint16_t>(10000));
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send command that needs timed invoke with a too-short timeout value\n");
            chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type value;
            ReturnErrorOnFailure(SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                             TestCluster::Commands::TimedInvokeRequest::Id, value, chip::Optional<uint16_t>(1)));
            return BusyWaitFor(100);
        }
        case 5: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Send command that does not need timed invoke with a long timeout value\n");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::Test::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 6: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Send command that does not need timed invoke with a too-short timeout value\n");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            ReturnErrorOnFailure(SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::Test::Id,
                                             value, chip::Optional<uint16_t>(1)));
            return BusyWaitFor(100);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute that needs timed write initial state\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write attribute that needs timed write without a timeout value\n");
            bool value;
            value = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id,
                                  value, chip::NullOptional);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute that needs timed write state unchanged 1\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id);
        }
        case 10: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Write attribute that needs timed write with a too-short timeout value\n");
            bool value;
            value = true;
            ReturnErrorOnFailure(WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                                TestCluster::Attributes::TimedWriteBoolean::Id, value,
                                                chip::Optional<uint16_t>(1)));
            return BusyWaitFor(100);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute that needs timed write state unchanged 2\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute that needs timed write with a long timeout value\n");
            bool value;
            value = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id,
                                  value, chip::Optional<uint16_t>(10000));
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute that needs timed write state changed\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Write attribute that needs timed write reset to default\n");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id,
                                  value, chip::Optional<uint16_t>(10000));
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute that does not need timed write initial value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 16: {
            ChipLogProgress(
                chipTool, " ***** Test Step 16 : Write attribute that does not need timed write with a too-short timeout value\n");
            bool value;
            value = true;
            ReturnErrorOnFailure(WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                                TestCluster::Attributes::Boolean::Id, value, chip::Optional<uint16_t>(1)));
            return BusyWaitFor(100);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read attribute that does not need timed write unchanged value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 18: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 18 : Write attribute that does not need timed write with a long timeout value\n");
            bool value;
            value = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value,
                                  chip::Optional<uint16_t>(10000));
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute that does not need timed write changed value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Write attribute that does not need timed write reset to default\n");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("wasPresent", value.wasPresent, true));
                VerifyOrReturn(CheckValuePresent("wasNull", value.wasNull));
                VerifyOrReturn(CheckValue("wasNull.Value()", value.wasNull.Value(), true));

                VerifyOrReturn(CheckValuePresent("originalValue", value.originalValue));
                VerifyOrReturn(CheckValueNull("originalValue.Value()", value.originalValue.Value()));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NEEDS_TIMED_INTERACTION));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("timedWriteBoolean", value, false));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NEEDS_TIMED_INTERACTION));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("timedWriteBoolean", value, false));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("timedWriteBoolean", value, false));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("timedWriteBoolean", value, true));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, false));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, false));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, true));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestConstraintsSuite : public TestCommand
{
public:
    TestConstraintsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestConstraints", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestConstraintsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestConstraints\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestConstraints\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 22;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write attribute INT32U Value\n");
            uint32_t value;
            value = 5UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute INT32U Value MinValue Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute INT32U Value MaxValue Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute INT32U Value NotValue Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute INT32U Value Back to Default Value\n");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write attribute CHAR_STRING Value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("** Test **garbage: not in length on purpose", 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute CHAR_STRING Value MinLength Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute CHAR_STRING Value MaxLength Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute CHAR_STRING Value StartsWith Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute CHAR_STRING Value EndsWith Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write attribute CHAR_STRING Value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("lowercasegarbage: not in length on purpose", 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Write attribute CHAR_STRING Value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("UPPERCASEgarbage: not in length on purpose", 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 14 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write attribute CHAR_STRING Value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("lowUPPERgarbage: not in length on purpose", 8);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute CHAR_STRING Value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("ABCDEF012Vgarbage: not in length on purpose", 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute CHAR_STRING Value isHexString Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Write attribute CHAR_STRING Value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("ABCDEF0123garbage: not in length on purpose", 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute CHAR_STRING Value isHexString Constraints\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write attribute CHAR_STRING Value Back to Default Value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint32_t>("value", value, 5UL));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("value", value, 5UL));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 6UL));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinLength("value", value.size(), 5));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 20));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintStartsWith("value", value, "**"));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintEndsWith("value", value, "**"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsUpperCase("value", value, false));
                VerifyOrReturn(CheckConstraintIsLowerCase("value", value, true));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsUpperCase("value", value, true));
                VerifyOrReturn(CheckConstraintIsLowerCase("value", value, false));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsUpperCase("value", value, false));
                VerifyOrReturn(CheckConstraintIsLowerCase("value", value, false));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsHexString("value", value, false));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsHexString("value", value, true));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestDelayCommandsSuite : public TestCommand
{
public:
    TestDelayCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestDelayCommands", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("customTimeout", 0, UINT16_MAX, &mCustomTimeout);
    }

    ~TestDelayCommandsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDelayCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDelayCommands\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mCustomTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mCustomTimeout.HasValue() ? mCustomTimeout.Value() : 100U);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestLogCommandsSuite : public TestCommand
{
public:
    TestLogCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestLogCommands", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestLogCommandsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestLogCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestLogCommands\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Log a simple message\n");
            SetIdentity(kIdentityAlpha);
            return Log("This is a simple message");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Do a simple user prompt message\n");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("This is a simple message");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestSaveAsSuite : public TestCommand
{
public:
    TestSaveAsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestSaveAs", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestSaveAsSuite()
    {
        if (readAttributeCharStringDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeCharStringDefaultValueBuffer);
            readAttributeCharStringDefaultValueBuffer = nullptr;
        }
        if (readAttributeCharStringNotDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeCharStringNotDefaultValueBuffer);
            readAttributeCharStringNotDefaultValueBuffer = nullptr;
        }
        if (readAttributeOctetStringDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeOctetStringDefaultValueBuffer);
            readAttributeOctetStringDefaultValueBuffer = nullptr;
        }
        if (readAttributeOctetStringNotDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeOctetStringNotDefaultValueBuffer);
            readAttributeOctetStringNotDefaultValueBuffer = nullptr;
        }
    }

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSaveAs\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSaveAs\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 110;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint8_t TestAddArgumentDefaultValue;
    bool readAttributeBooleanDefaultValue;
    uint8_t readAttributeBitmap8DefaultValue;
    uint16_t readAttributeBitmap16DefaultValue;
    uint32_t readAttributeBitmap32DefaultValue;
    uint64_t readAttributeBitmap64DefaultValue;
    uint8_t readAttributeInt8uDefaultValue;
    uint16_t readAttributeInt16uDefaultValue;
    uint32_t readAttributeInt32uDefaultValue;
    uint64_t readAttributeInt64uDefaultValue;
    int8_t readAttributeInt8sDefaultValue;
    int16_t readAttributeInt16sDefaultValue;
    int32_t readAttributeInt32sDefaultValue;
    int64_t readAttributeInt64sDefaultValue;
    uint8_t readAttributeEnum8DefaultValue;
    uint16_t readAttributeEnum16DefaultValue;
    uint64_t readAttributeEpochUSDefaultValue;
    uint32_t readAttributeEpochSDefaultValue;
    chip::VendorId readAttributeVendorIdDefaultValue;
    char * readAttributeCharStringDefaultValueBuffer = nullptr;
    chip::CharSpan readAttributeCharStringDefaultValue;
    char * readAttributeCharStringNotDefaultValueBuffer = nullptr;
    chip::CharSpan readAttributeCharStringNotDefaultValue;
    uint8_t * readAttributeOctetStringDefaultValueBuffer = nullptr;
    chip::ByteSpan readAttributeOctetStringDefaultValue;
    uint8_t * readAttributeOctetStringNotDefaultValueBuffer = nullptr;
    chip::ByteSpan readAttributeOctetStringNotDefaultValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Add Arguments Command\n");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = 17;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Add Arguments Command\n");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = 17;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Add Arguments Command\n");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = TestAddArgumentDefaultValue;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute BOOLEAN Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute BOOLEAN Not Default Value\n");
            bool value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute BOOLEAN Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute BOOLEAN DefaultValue\n");
            bool value;
            value = readAttributeBooleanDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute BOOLEAN False\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute BITMAP8 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write attribute BITMAP8 Not Default Value\n");
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute BITMAP8 Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute BITMAP8 Default Value\n");
            uint8_t value;
            value = readAttributeBitmap8DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute BITMAP8 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read attribute BITMAP16 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write attribute BITMAP16 Not Default Value\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute BITMAP16 Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute BITMAP16 Default Value\n");
            uint16_t value;
            value = readAttributeBitmap16DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id, value);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute BITMAP16 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute BITMAP32 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Write attribute BITMAP32 Not Default Value\n");
            uint32_t value;
            value = 1UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id, value);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute BITMAP32 Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Write attribute BITMAP32 Default Value\n");
            uint32_t value;
            value = readAttributeBitmap32DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id, value);
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read attribute BITMAP32 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read attribute BITMAP64 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : Write attribute BITMAP64 Not Default Value\n");
            uint64_t value;
            value = 1ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id, value);
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute BITMAP64 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute BITMAP64 Default Value\n");
            uint64_t value;
            value = readAttributeBitmap64DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id, value);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute BITMAP64 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read attribute INT8U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : Write attribute INT8U Not Default Value\n");
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id, value);
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read attribute INT8U Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : Write attribute INT8U Default Value\n");
            uint8_t value;
            value = readAttributeInt8uDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id, value);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read attribute INT8U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read attribute INT16U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : Write attribute INT16U Not Default Value\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id, value);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute INT16U Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute INT16U Default Value\n");
            uint16_t value;
            value = readAttributeInt16uDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id, value);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute INT16U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read attribute INT32U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : Write attribute INT32U Not Default Value\n");
            uint32_t value;
            value = 1UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read attribute INT32U Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : Write attribute INT32U Default Value\n");
            uint32_t value;
            value = readAttributeInt32uDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read attribute INT32U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read attribute INT64U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : Write attribute INT64U Not Default Value\n");
            uint64_t value;
            value = 1ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id, value);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute INT64U Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute INT64U Default Value\n");
            uint64_t value;
            value = readAttributeInt64uDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id, value);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute INT64U Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read attribute INT8S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 50: {
            ChipLogProgress(chipTool, " ***** Test Step 50 : Write attribute INT8S Not Default Value\n");
            int8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 51: {
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read attribute INT8S Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 52: {
            ChipLogProgress(chipTool, " ***** Test Step 52 : Write attribute INT8S Default Value\n");
            int8_t value;
            value = readAttributeInt8sDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 53: {
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read attribute INT8S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 54: {
            ChipLogProgress(chipTool, " ***** Test Step 54 : Read attribute INT16S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 55: {
            ChipLogProgress(chipTool, " ***** Test Step 55 : Write attribute INT16S Not Default Value\n");
            int16_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 56: {
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read attribute INT16S Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 57: {
            ChipLogProgress(chipTool, " ***** Test Step 57 : Write attribute INT16S Default Value\n");
            int16_t value;
            value = readAttributeInt16sDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 58: {
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute INT16S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 59: {
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read attribute INT32S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 60: {
            ChipLogProgress(chipTool, " ***** Test Step 60 : Write attribute INT32S Not Default Value\n");
            int32_t value;
            value = 1L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 61: {
            ChipLogProgress(chipTool, " ***** Test Step 61 : Read attribute INT32S Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 62: {
            ChipLogProgress(chipTool, " ***** Test Step 62 : Write attribute INT32S Default Value\n");
            int32_t value;
            value = readAttributeInt32sDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 63: {
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read attribute INT32S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 64: {
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT64S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 65: {
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write attribute INTS Not Default Value\n");
            int64_t value;
            value = 1LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 66: {
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read attribute INT64S Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 67: {
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write attribute INT64S Default Value\n");
            int64_t value;
            value = readAttributeInt64sDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 68: {
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read attribute INT64S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 69: {
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read attribute ENUM8 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 70: {
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write attribute ENUM8 Not Default Value\n");
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id, value);
        }
        case 71: {
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute ENUM8 Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 72: {
            ChipLogProgress(chipTool, " ***** Test Step 72 : Write attribute ENUM8 Default Value\n");
            uint8_t value;
            value = readAttributeEnum8DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id, value);
        }
        case 73: {
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read attribute ENUM8 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 74: {
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute ENUM16 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 75: {
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute ENUM16 Not Default Value\n");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id, value);
        }
        case 76: {
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute ENUM16 Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 77: {
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute ENUM16 Default Value\n");
            uint16_t value;
            value = readAttributeEnum16DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id, value);
        }
        case 78: {
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute ENUM16 Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 79: {
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read attribute EPOCH_US Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 80: {
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write attribute EPOCH_US Not Default Value\n");
            uint64_t value;
            value = 1ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id, value);
        }
        case 81: {
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read attribute EPOCH_US Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 82: {
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write attribute EPOCH_US Default Value\n");
            uint64_t value;
            value = readAttributeEpochUSDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id, value);
        }
        case 83: {
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute EPOCH_US Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 84: {
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read attribute EPOCH_S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 85: {
            ChipLogProgress(chipTool, " ***** Test Step 85 : Write attribute EPOCH_S Not Default Value\n");
            uint32_t value;
            value = 1UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id, value);
        }
        case 86: {
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read attribute EPOCH_S Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 87: {
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write attribute EPOCH_S Default Value\n");
            uint32_t value;
            value = readAttributeEpochSDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id, value);
        }
        case 88: {
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute EPOCH_S Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 89: {
            ChipLogProgress(chipTool, " ***** Test Step 89 : Read attribute vendor_id Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 90: {
            ChipLogProgress(chipTool, " ***** Test Step 90 : Write attribute vendor_id Not Default Value\n");
            chip::VendorId value;
            value = static_cast<chip::VendorId>(1);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id, value);
        }
        case 91: {
            ChipLogProgress(chipTool, " ***** Test Step 91 : Read attribute vendor_id Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 92: {
            ChipLogProgress(chipTool, " ***** Test Step 92 : Write attribute vendor_id Default Value\n");
            chip::VendorId value;
            value = readAttributeVendorIdDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id, value);
        }
        case 93: {
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read attribute vendor_id Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 94: {
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute char_string Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 95: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 95 : Read attribute char_string Default Value and compare to saved value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 96: {
            ChipLogProgress(chipTool, " ***** Test Step 96 : Write attribute char_string Not Default Value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("NotDefaultgarbage: not in length on purpose", 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 97: {
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read attribute char_string Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 98: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 98 : Read attribute char_string Not Default Value and compare to saved value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 99: {
            ChipLogProgress(chipTool, " ***** Test Step 99 : Write attribute char_string Not Default Value from saved value\n");
            chip::CharSpan value;
            value = readAttributeCharStringNotDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 100: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 100 : Read attribute char_string Not Default Value and compare to expected value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 101: {
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write attribute char_string Default Value\n");
            chip::CharSpan value;
            value = readAttributeCharStringDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 102: {
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute octet_string Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 103: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 103 : Read attribute octet_string Default Value and compare to saved value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 104: {
            ChipLogProgress(chipTool, " ***** Test Step 104 : Write attribute octet_string Not Default Value\n");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("NotDefaultgarbage: not in length on purpose"), 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 105: {
            ChipLogProgress(chipTool, " ***** Test Step 105 : Read attribute octet_string Not Default Value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 106: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 106 : Read attribute octet_string Not Default Value and compare to saved value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 107: {
            ChipLogProgress(chipTool, " ***** Test Step 107 : Write attribute octet_string Not Default Value from saved value\n");
            chip::ByteSpan value;
            value = readAttributeOctetStringNotDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 108: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 108 : Read attribute octet_string Not Default Value and compare to expected value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 109: {
            ChipLogProgress(chipTool, " ***** Test Step 109 : Write attribute octet_string Default Value\n");
            chip::ByteSpan value;
            value = readAttributeOctetStringDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, 20));
                TestAddArgumentDefaultValue = value.returnValue;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, TestAddArgumentDefaultValue));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value.returnValue", value.returnValue, TestAddArgumentDefaultValue));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, 0));
                readAttributeBooleanDefaultValue = value;
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBooleanDefaultValue));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, readAttributeBooleanDefaultValue));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, 0));
                readAttributeBitmap8DefaultValue = value;
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBitmap8DefaultValue));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, readAttributeBitmap8DefaultValue));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, 0U));
                readAttributeBitmap16DefaultValue = value;
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBitmap16DefaultValue));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, readAttributeBitmap16DefaultValue));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, 0UL));
                readAttributeBitmap32DefaultValue = value;
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBitmap32DefaultValue));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, readAttributeBitmap32DefaultValue));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, 0ULL));
                readAttributeBitmap64DefaultValue = value;
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBitmap64DefaultValue));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, readAttributeBitmap64DefaultValue));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, 0));
                readAttributeInt8uDefaultValue = value;
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt8uDefaultValue));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, readAttributeInt8uDefaultValue));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, 0U));
                readAttributeInt16uDefaultValue = value;
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt16uDefaultValue));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, readAttributeInt16uDefaultValue));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, 0UL));
                readAttributeInt32uDefaultValue = value;
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt32uDefaultValue));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, readAttributeInt32uDefaultValue));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, 0ULL));
                readAttributeInt64uDefaultValue = value;
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt64uDefaultValue));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, readAttributeInt64uDefaultValue));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, 0));
                readAttributeInt8sDefaultValue = value;
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt8sDefaultValue));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, readAttributeInt8sDefaultValue));
            }
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, 0));
                readAttributeInt16sDefaultValue = value;
            }
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt16sDefaultValue));
            }
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, readAttributeInt16sDefaultValue));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, 0L));
                readAttributeInt32sDefaultValue = value;
            }
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt32sDefaultValue));
            }
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, readAttributeInt32sDefaultValue));
            }
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, 0LL));
                readAttributeInt64sDefaultValue = value;
            }
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt64sDefaultValue));
            }
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, readAttributeInt64sDefaultValue));
            }
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, 0));
                readAttributeEnum8DefaultValue = value;
            }
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeEnum8DefaultValue));
            }
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, readAttributeEnum8DefaultValue));
            }
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, 0U));
                readAttributeEnum16DefaultValue = value;
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeEnum16DefaultValue));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, readAttributeEnum16DefaultValue));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, 0ULL));
                readAttributeEpochUSDefaultValue = value;
            }
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeEpochUSDefaultValue));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, readAttributeEpochUSDefaultValue));
            }
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, 0UL));
                readAttributeEpochSDefaultValue = value;
            }
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeEpochSDefaultValue));
            }
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, readAttributeEpochSDefaultValue));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorId", value, 0U));
                readAttributeVendorIdDefaultValue = value;
            }
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeVendorIdDefaultValue));
            }
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorId", value, readAttributeVendorIdDefaultValue));
            }
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("", 0)));
                if (readAttributeCharStringDefaultValueBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readAttributeCharStringDefaultValueBuffer);
                }
                readAttributeCharStringDefaultValueBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readAttributeCharStringDefaultValueBuffer, value.data(), value.size());
                readAttributeCharStringDefaultValue = chip::CharSpan(readAttributeCharStringDefaultValueBuffer, value.size());
            }
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, readAttributeCharStringDefaultValue));
            }
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("NotDefault", 10)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeCharStringDefaultValue));

                if (readAttributeCharStringNotDefaultValueBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readAttributeCharStringNotDefaultValueBuffer);
                }
                readAttributeCharStringNotDefaultValueBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readAttributeCharStringNotDefaultValueBuffer, value.data(), value.size());
                readAttributeCharStringNotDefaultValue = chip::CharSpan(readAttributeCharStringNotDefaultValueBuffer, value.size());
            }
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, readAttributeCharStringNotDefaultValue));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeCharStringDefaultValue));
            }
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("NotDefault", 10)));
            }
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 102:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
                if (readAttributeOctetStringDefaultValueBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readAttributeOctetStringDefaultValueBuffer);
                }
                readAttributeOctetStringDefaultValueBuffer = static_cast<uint8_t *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readAttributeOctetStringDefaultValueBuffer, value.data(), value.size());
                readAttributeOctetStringDefaultValue = chip::ByteSpan(readAttributeOctetStringDefaultValueBuffer, value.size());
            }
            break;
        case 103:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value, readAttributeOctetStringDefaultValue));
            }
            break;
        case 104:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 105:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("NotDefault"), 10)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeOctetStringDefaultValue));

                if (readAttributeOctetStringNotDefaultValueBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readAttributeOctetStringNotDefaultValueBuffer);
                }
                readAttributeOctetStringNotDefaultValueBuffer = static_cast<uint8_t *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readAttributeOctetStringNotDefaultValueBuffer, value.data(), value.size());
                readAttributeOctetStringNotDefaultValue =
                    chip::ByteSpan(readAttributeOctetStringNotDefaultValueBuffer, value.size());
            }
            break;
        case 106:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value, readAttributeOctetStringNotDefaultValue));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeOctetStringDefaultValue));
            }
            break;
        case 107:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 108:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("NotDefault"), 10)));
            }
            break;
        case 109:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestConfigVariablesSuite : public TestCommand
{
public:
    TestConfigVariablesSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestConfigVariables", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("returnValueWithArg1", 0, UINT8_MAX, &mReturnValueWithArg1);
    }

    ~TestConfigVariablesSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestConfigVariables\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestConfigVariables\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint8_t> mArg1;
    chip::Optional<uint8_t> mReturnValueWithArg1;

    uint8_t TestAddArgumentDefaultValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Add Arguments Command\n");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = 17;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Add Arguments Command\n");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = mArg1.HasValue() ? mArg1.Value() : 5;
            value.arg2 = TestAddArgumentDefaultValue;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, 20));
                TestAddArgumentDefaultValue = value.returnValue;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue,
                                          mReturnValueWithArg1.HasValue() ? mReturnValueWithArg1.Value() : 25));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestDescriptorClusterSuite : public TestCommand
{
public:
    TestDescriptorClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestDescriptorCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestDescriptorClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDescriptorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDescriptorCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Device list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Descriptor::Id, Descriptor::Attributes::DeviceList::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute Server list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Descriptor::Id, Descriptor::Attributes::ServerList::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute Client list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Descriptor::Id, Descriptor::Attributes::ClientList::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute Parts list\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Descriptor::Id, Descriptor::Attributes::PartsList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("deviceList", iter_0, 0));
                    VerifyOrReturn(CheckValue("deviceList[0].type", iter_0.GetValue().type, 22UL));
                    VerifyOrReturn(CheckValue("deviceList[0].revision", iter_0.GetValue().revision, 1U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("deviceList", iter_0, 1));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ClusterId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 0));
                    VerifyOrReturn(CheckValue("serverList[0]", iter_0.GetValue(), 3UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 1));
                    VerifyOrReturn(CheckValue("serverList[1]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 2));
                    VerifyOrReturn(CheckValue("serverList[2]", iter_0.GetValue(), 29UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 3));
                    VerifyOrReturn(CheckValue("serverList[3]", iter_0.GetValue(), 30UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 4));
                    VerifyOrReturn(CheckValue("serverList[4]", iter_0.GetValue(), 31UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 5));
                    VerifyOrReturn(CheckValue("serverList[5]", iter_0.GetValue(), 40UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 6));
                    VerifyOrReturn(CheckValue("serverList[6]", iter_0.GetValue(), 42UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 7));
                    VerifyOrReturn(CheckValue("serverList[7]", iter_0.GetValue(), 43UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 8));
                    VerifyOrReturn(CheckValue("serverList[8]", iter_0.GetValue(), 44UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 9));
                    VerifyOrReturn(CheckValue("serverList[9]", iter_0.GetValue(), 45UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 10));
                    VerifyOrReturn(CheckValue("serverList[10]", iter_0.GetValue(), 46UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 11));
                    VerifyOrReturn(CheckValue("serverList[11]", iter_0.GetValue(), 48UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 12));
                    VerifyOrReturn(CheckValue("serverList[12]", iter_0.GetValue(), 49UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 13));
                    VerifyOrReturn(CheckValue("serverList[13]", iter_0.GetValue(), 50UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 14));
                    VerifyOrReturn(CheckValue("serverList[14]", iter_0.GetValue(), 51UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 15));
                    VerifyOrReturn(CheckValue("serverList[15]", iter_0.GetValue(), 52UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 16));
                    VerifyOrReturn(CheckValue("serverList[16]", iter_0.GetValue(), 53UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 17));
                    VerifyOrReturn(CheckValue("serverList[17]", iter_0.GetValue(), 54UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 18));
                    VerifyOrReturn(CheckValue("serverList[18]", iter_0.GetValue(), 55UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 19));
                    VerifyOrReturn(CheckValue("serverList[19]", iter_0.GetValue(), 60UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 20));
                    VerifyOrReturn(CheckValue("serverList[20]", iter_0.GetValue(), 62UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 21));
                    VerifyOrReturn(CheckValue("serverList[21]", iter_0.GetValue(), 63UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 22));
                    VerifyOrReturn(CheckValue("serverList[22]", iter_0.GetValue(), 64UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 23));
                    VerifyOrReturn(CheckValue("serverList[23]", iter_0.GetValue(), 65UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 24));
                    VerifyOrReturn(CheckValue("serverList[24]", iter_0.GetValue(), 1029UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("serverList", iter_0, 25));
                }
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ClusterId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientList", iter_0, 0));
                    VerifyOrReturn(CheckValue("clientList[0]", iter_0.GetValue(), 41UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("clientList", iter_0, 1));
                }
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::EndpointId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("partsList", iter_0, 0));
                    VerifyOrReturn(CheckValue("partsList[0]", iter_0.GetValue(), 1U));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("partsList", iter_0, 1));
                    VerifyOrReturn(CheckValue("partsList[1]", iter_0.GetValue(), 2U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("partsList", iter_0, 2));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestBasicInformationSuite : public TestCommand
{
public:
    TestBasicInformationSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestBasicInformation", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestBasicInformationSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestBasicInformation\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestBasicInformation\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read location\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write location\n");
            chip::CharSpan value;
            value = chip::Span<const char>("USgarbage: not in length on purpose", 2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read back location\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Restore initial location value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("XXgarbage: not in length on purpose", 2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read AttributeList value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("location", value, chip::CharSpan("XX", 2)));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("location", value, chip::CharSpan("US", 2)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 0));
                    VerifyOrReturn(CheckValue("attributeList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 1));
                    VerifyOrReturn(CheckValue("attributeList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 2));
                    VerifyOrReturn(CheckValue("attributeList[2]", iter_0.GetValue(), 2UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 3));
                    VerifyOrReturn(CheckValue("attributeList[3]", iter_0.GetValue(), 3UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 4));
                    VerifyOrReturn(CheckValue("attributeList[4]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 5));
                    VerifyOrReturn(CheckValue("attributeList[5]", iter_0.GetValue(), 5UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 6));
                    VerifyOrReturn(CheckValue("attributeList[6]", iter_0.GetValue(), 6UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 7));
                    VerifyOrReturn(CheckValue("attributeList[7]", iter_0.GetValue(), 7UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 8));
                    VerifyOrReturn(CheckValue("attributeList[8]", iter_0.GetValue(), 8UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 9));
                    VerifyOrReturn(CheckValue("attributeList[9]", iter_0.GetValue(), 9UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 10));
                    VerifyOrReturn(CheckValue("attributeList[10]", iter_0.GetValue(), 10UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 11));
                    VerifyOrReturn(CheckValue("attributeList[11]", iter_0.GetValue(), 11UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 12));
                    VerifyOrReturn(CheckValue("attributeList[12]", iter_0.GetValue(), 12UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 13));
                    VerifyOrReturn(CheckValue("attributeList[13]", iter_0.GetValue(), 13UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 14));
                    VerifyOrReturn(CheckValue("attributeList[14]", iter_0.GetValue(), 14UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 15));
                    VerifyOrReturn(CheckValue("attributeList[15]", iter_0.GetValue(), 15UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 16));
                    VerifyOrReturn(CheckValue("attributeList[16]", iter_0.GetValue(), 16UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 17));
                    VerifyOrReturn(CheckValue("attributeList[17]", iter_0.GetValue(), 17UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 18));
                    VerifyOrReturn(CheckValue("attributeList[18]", iter_0.GetValue(), 18UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 19));
                    VerifyOrReturn(CheckValue("attributeList[19]", iter_0.GetValue(), 65528UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 20));
                    VerifyOrReturn(CheckValue("attributeList[20]", iter_0.GetValue(), 65529UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 21));
                    VerifyOrReturn(CheckValue("attributeList[21]", iter_0.GetValue(), 65531UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 22));
                    VerifyOrReturn(CheckValue("attributeList[22]", iter_0.GetValue(), 65533UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("attributeList", iter_0, 23));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestIdentifyClusterSuite : public TestCommand
{
public:
    TestIdentifyClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestIdentifyCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestIdentifyClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestIdentifyCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestIdentifyCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Identify command and expect success response\n");
            chip::app::Clusters::Identify::Commands::Identify::Type value;
            value.identifyTime = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), Identify::Id, Identify::Commands::Identify::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestOperationalCredentialsClusterSuite : public TestCommand
{
public:
    TestOperationalCredentialsClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestOperationalCredentialsCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestOperationalCredentialsClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestOperationalCredentialsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestOperationalCredentialsCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::FabricIndex ourFabricIndex;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read number of supported fabrics\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::SupportedFabrics::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read number of commissioned fabrics\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::CommissionedFabrics::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read current fabric index\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::CurrentFabricIndex::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Remove nonexistent fabric\n");
            chip::app::Clusters::OperationalCredentials::Commands::RemoveFabric::Type value;
            value.fabricIndex = 243;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                               OperationalCredentials::Commands::RemoveFabric::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read fabric list before setting label\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Set the fabric label\n");
            chip::app::Clusters::OperationalCredentials::Commands::UpdateFabricLabel::Type value;
            value.label = chip::Span<const char>("Batcavegarbage: not in length on purpose", 7);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                               OperationalCredentials::Commands::UpdateFabricLabel::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read fabric list after setting label\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 4));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::FabricIndex value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue<chip::FabricIndex>("value", value, 1));
                ourFabricIndex = value;
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusCode", value.statusCode, 11));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValue("fabrics[0].fabricIndex", iter_0.GetValue().fabricIndex, ourFabricIndex));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusCode", value.statusCode, 0));
                VerifyOrReturn(CheckValuePresent("fabricIndex", value.fabricIndex));
                VerifyOrReturn(CheckValue("fabricIndex.Value()", value.fabricIndex.Value(), ourFabricIndex));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValue("fabrics[0].fabricIndex", iter_0.GetValue().fabricIndex, ourFabricIndex));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("Batcave", 7)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestModeSelectClusterSuite : public TestCommand
{
public:
    TestModeSelectClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestModeSelectCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestModeSelectClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestModeSelectCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestModeSelectCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read CurrentMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::CurrentMode::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read OnMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::OnMode::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read StartUpMode\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::StartUpMode::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read Description\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::Description::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read SupportedModes\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::SupportedModes::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Change to Supported Mode\n");
            chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type value;
            value.newMode = 4;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Commands::ChangeToMode::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Verify Current Mode Change\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::CurrentMode::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Change to Unsupported Mode\n");
            chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type value;
            value.newMode = 2;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Commands::ChangeToMode::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentMode", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onMode", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("startUpMode", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("description", value, chip::CharSpan("Coffee", 6)));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("supportedModes", iter_0, 0));
                    VerifyOrReturn(
                        CheckValueAsString("supportedModes[0].label", iter_0.GetValue().label, chip::CharSpan("Black", 5)));
                    VerifyOrReturn(CheckValue("supportedModes[0].mode", iter_0.GetValue().mode, 0));
                    VerifyOrReturn(CheckValue("supportedModes[0].semanticTag", iter_0.GetValue().semanticTag, 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("supportedModes", iter_0, 1));
                    VerifyOrReturn(
                        CheckValueAsString("supportedModes[1].label", iter_0.GetValue().label, chip::CharSpan("Cappuccino", 10)));
                    VerifyOrReturn(CheckValue("supportedModes[1].mode", iter_0.GetValue().mode, 4));
                    VerifyOrReturn(CheckValue("supportedModes[1].semanticTag", iter_0.GetValue().semanticTag, 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("supportedModes", iter_0, 2));
                    VerifyOrReturn(
                        CheckValueAsString("supportedModes[2].label", iter_0.GetValue().label, chip::CharSpan("Espresso", 8)));
                    VerifyOrReturn(CheckValue("supportedModes[2].mode", iter_0.GetValue().mode, 7));
                    VerifyOrReturn(CheckValue("supportedModes[2].semanticTag", iter_0.GetValue().semanticTag, 0UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("supportedModes", iter_0, 3));
                }
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentMode", value, 4));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestSystemCommandsSuite : public TestCommand
{
public:
    TestSystemCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestSystemCommands", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestSystemCommandsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSystemCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSystemCommands\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Stop the accessory\n");
            SetIdentity(kIdentityAlpha);
            return Stop();
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Start the accessory with a given discriminator\n");
            SetIdentity(kIdentityAlpha);
            return Start(1111);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reboot the accessory with an other given discriminator\n");
            SetIdentity(kIdentityAlpha);
            return Reboot(2222);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Factory Reset the accessory\n");
            SetIdentity(kIdentityAlpha);
            return FactoryReset();
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SWDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWDIAG_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWDIAG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads a list of ThreadMetrics struct non-global attribute from DUT.\n");
            VerifyOrdo(!ShouldSkip("A_THREADMETRICS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::ThreadMetrics::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapFree non-global attribute value from DUT\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapFree::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHeapUsed non-global attribute value from DUT\n");
            VerifyOrdo(!ShouldSkip("A_CURRENTHEAPUSED"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapUsed::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads CurrentHeapHighWaterMark non-global attribute value from DUT\n");
            VerifyOrdo(!ShouldSkip("A_CURRENTHEAPHIGHWATERMARK"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            break;
        case 2:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 3:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 4:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SWDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWDIAG_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWDIAG_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SWDIAG_3_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWDIAG_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWDIAG_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sends ResetWatermarks to DUT\n");
            VerifyOrdo(!ShouldSkip("CR_RESETWATERMARKS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::SoftwareDiagnostics::Commands::ResetWatermarks::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                               SoftwareDiagnostics::Commands::ResetWatermarks::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapUsed attribute value from DUT\n");
            VerifyOrdo(!ShouldSkip("A_CURRENTHEAPUSED"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapUsed::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHeapHighWaterMark attribute value from DUT\n");
            VerifyOrdo(!ShouldSkip("A_CURRENTHEAPHIGHWATERMARK"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 3:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestSubscribe_OnOffSuite : public TestCommand
{
public:
    TestSubscribe_OnOffSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestSubscribe_OnOff", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestSubscribe_OnOffSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSubscribe_OnOff\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSubscribe_OnOff\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Set OnOff Attribute to false\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Subscribe OnOff Attribute\n");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id, 2, 5);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn On the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check for attribute report\n");
            return WaitForReport();
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn Off the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check for attribute report\n");
            return WaitForReport();
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, false));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, true));
            }
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, false));
            }
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class DL_UsersAndCredentialsSuite : public TestCommand
{
public:
    DL_UsersAndCredentialsSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("DL_UsersAndCredentials", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~DL_UsersAndCredentialsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: DL_UsersAndCredentials\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: DL_UsersAndCredentials\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 102;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t NumberOfTotalUsersSupported;
    uint16_t NumberOfPINUsersSupported;
    uint16_t NumberOfRFIDUsersSupported;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read available user slot and verify response fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Get number of supported users and verify default value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfTotalUsersSupported::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read fails for user with index 0\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Read fails for user with index greater than Number Of Users Supported\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Create new user with default parameters\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read the user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Set user at the occupied index fails with appropriate response\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Modify userName for existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNonNull();
            value.userName.Value() = chip::Span<const char>("new_usergarbage: not in length on purpose", 8);
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read the modified user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Modify userUniqueId for existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNonNull();
            value.userUniqueId.Value() = 305441741UL;
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read the modified user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Modify userStatus for existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNonNull();
            value.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(3);
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read the modified user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Modify userType for existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNonNull();
            value.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(6);
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read the modified user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Modify credentialRule for existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNonNull();
            value.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(2);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read the modified user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Modify all fields for existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNonNull();
            value.userName.Value() = chip::Span<const char>("test_usergarbage: not in length on purpose", 9);
            value.userUniqueId.SetNonNull();
            value.userUniqueId.Value() = 466460832UL;
            value.userStatus.SetNonNull();
            value.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(1);
            value.userType.SetNonNull();
            value.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(0);
            value.credentialRule.SetNonNull();
            value.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read the modified user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Add another user with non-default fields\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 2U;
            value.userName.SetNonNull();
            value.userName.Value() = chip::Span<const char>("test_user2garbage: not in length on purpose", 10);
            value.userUniqueId.SetNonNull();
            value.userUniqueId.Value() = 12648430UL;
            value.userStatus.SetNonNull();
            value.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(1);
            value.userType.SetNonNull();
            value.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(1);
            value.credentialRule.SetNonNull();
            value.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(2);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read the new user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Create user in the last slot\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = NumberOfTotalUsersSupported;
            value.userName.SetNonNull();
            value.userName.Value() = chip::Span<const char>("last_usergarbage: not in length on purpose", 9);
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read the last user back and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = NumberOfTotalUsersSupported;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : User creation in the 0 slot fails\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 0U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : User creation in the out-of-bounds slot fails\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : Clear first user\n");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read cleared user and verify it is available\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : Create new user in the cleared slot\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read the user in the previously cleared slot and verify its fields\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : Clear user with index 0 fails\n");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : Clear user with out-of-bounds index fails\n");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : Clear all users\n");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 65534U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read first cleared user and verify it is available\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read last cleared user and verify it is available\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = NumberOfTotalUsersSupported;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : Get number of supported PIN credentials and verify default value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::NumberOfPINUsersSupported::Id);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : Check that PIN credential does not exist\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : Reading PIN credential with index 0 fails\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reading PIN credential with out-of-bounds index fails\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : Create new PIN credential and user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : Verify created user\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Verify created PIN credential\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : Create new PIN credential and user with index 0 fails\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 0U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : Create new PIN credential and user with out-of-bounds index fails\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : Get number of supported RFID credentials and verify default value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfRFIDUsersSupported::Id);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : Reading RFID credential with index 0 fails\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reading RFID credential with out-of-bounds index fails\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : Check that RFID credential does not exist\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : Create new RFID credential and add it to existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_123456garbage: not in length on purpose"), 16);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 1U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : Verify modified user\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 50: {
            ChipLogProgress(chipTool, " ***** Test Step 50 : Verify created credential\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 51: {
            ChipLogProgress(chipTool, " ***** Test Step 51 : Create new RFID credential and user with index 0 fails\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 0U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("new_rfid_data_fieldgarbage: not in length on purpose"), 19);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 52: {
            ChipLogProgress(chipTool, " ***** Test Step 52 : Create new RFID credential and user with out-of-bounds index fails\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("new_rfid_data_fieldgarbage: not in length on purpose"), 19);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 53: {
            ChipLogProgress(chipTool, " ***** Test Step 53 : Create new PIN credential and try to add it to existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 1U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 54: {
            ChipLogProgress(chipTool, " ***** Test Step 54 : Create new credential and try to add it to 0 user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 55: {
            ChipLogProgress(chipTool, " ***** Test Step 55 : Create new credential and try to add it to out-of-bounds user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 56: {
            ChipLogProgress(chipTool, " ***** Test Step 56 : Create new PIN with too short data\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("12345garbage: not in length on purpose"), 5);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 57: {
            ChipLogProgress(chipTool, " ***** Test Step 57 : Create new PIN with too long data\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456789garbage: not in length on purpose"), 9);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 58: {
            ChipLogProgress(chipTool, " ***** Test Step 58 : Create new RFID with too short data\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("rfid_datagarbage: not in length on purpose"), 9);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 59: {
            ChipLogProgress(chipTool, " ***** Test Step 59 : Create new PIN with Programming user type fails\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNonNull();
            value.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(3);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 60: {
            ChipLogProgress(chipTool, " ***** Test Step 60 : Create new RFID with too short data\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(
                chip::Uint8::from_const_char("very_long_rfid_data_to_test_boundariesgarbage: not in length on purpose"), 38);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 61: {
            ChipLogProgress(chipTool, " ***** Test Step 61 : Create new PIN credential with data the would cause duplicate\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 4U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 62: {
            ChipLogProgress(chipTool, " ***** Test Step 62 : Create new RFID credential with data the would cause duplicate\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 4U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_123456garbage: not in length on purpose"), 16);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 63: {
            ChipLogProgress(chipTool, " ***** Test Step 63 : Modify credentialData of existing PIN credential\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 1U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 64: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 64 : Verify that credential was changed by creating new credential with old data\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 65: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 65 : Verify that credential was changed by creating new credential with new data\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 4U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 66: {
            ChipLogProgress(chipTool, " ***** Test Step 66 : Clear first PIN credential\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 67: {
            ChipLogProgress(chipTool, " ***** Test Step 67 : Read back the credential and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 68: {
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read the user back and make sure PIN credential is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 69: {
            ChipLogProgress(chipTool, " ***** Test Step 69 : Clear the second PIN credential\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 3U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 70: {
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read back the credential and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 71: {
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read the user back and make sure related user is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 72: {
            ChipLogProgress(chipTool, " ***** Test Step 72 : Create new RFID credential with user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 1U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_12345garbage: not in length on purpose"), 15);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 73: {
            ChipLogProgress(chipTool, " ***** Test Step 73 : Clear all the RFID credentials\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.Value().credentialIndex = 65534U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 74: {
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read back the fist RFID credential and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 75: {
            ChipLogProgress(chipTool, " ***** Test Step 75 : Read back the second RFID credential and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 76: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 76 : Read the user related with first RFID back and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 77: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 77 : Read the user related with second RFID back and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 78: {
            ChipLogProgress(chipTool, " ***** Test Step 78 : Create new PIN credential with user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 79: {
            ChipLogProgress(chipTool, " ***** Test Step 79 : Create new RFID credential with user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_1234garbage: not in length on purpose"), 14);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 80: {
            ChipLogProgress(chipTool, " ***** Test Step 80 : Create another RFID credential with user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 6U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_9876garbage: not in length on purpose"), 14);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 81: {
            ChipLogProgress(chipTool, " ***** Test Step 81 : Clear all the credentials\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 82: {
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read back the first PIN credential and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 83: {
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read back the first RFID credential and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 84: {
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read back the second PIN credential and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 6U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 85: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 85 : Read the user related with first PIN back and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 86: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 86 : Read the user related with first RFID back and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 87: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 87 : Read the user related with second PIN back and make sure it is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 3U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 88: {
            ChipLogProgress(chipTool, " ***** Test Step 88 : Create new Programming PIN credential with invalid index\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 89: {
            ChipLogProgress(chipTool, " ***** Test Step 89 : Create new Programming PIN credential with valid index\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 0U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 90: {
            ChipLogProgress(chipTool, " ***** Test Step 90 : Verify created user\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 91: {
            ChipLogProgress(chipTool, " ***** Test Step 91 : Verify created programming PIN credential\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 92: {
            ChipLogProgress(chipTool, " ***** Test Step 92 : Modify the Programming PIN credential\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 0U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("654321garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 93: {
            ChipLogProgress(chipTool, " ***** Test Step 93 : Clearing Programming PIN fails\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.Value().credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 94: {
            ChipLogProgress(chipTool, " ***** Test Step 94 : Clearing Programming PIN with invalid index fails\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.Value().credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 95: {
            ChipLogProgress(chipTool, " ***** Test Step 95 : Clearing PIN credential with zero index fails\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 96: {
            ChipLogProgress(chipTool, " ***** Test Step 96 : Clearing PIN credential with out-of-bound index fails\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 97: {
            ChipLogProgress(chipTool, " ***** Test Step 97 : Clearing RFID credential with zero index fails\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.Value().credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 98: {
            ChipLogProgress(chipTool, " ***** Test Step 98 : Clearing RFID credential with out-of-bound index fails\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.Value().credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 99: {
            ChipLogProgress(chipTool, " ***** Test Step 99 : Clear the Programming PIN user\n");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 100: {
            ChipLogProgress(chipTool, " ***** Test Step 100 : Make sure Programming PIN user is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 101: {
            ChipLogProgress(chipTool, " ***** Test Step 101 : Make sure programming PIN credential is deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfTotalUsersSupported", value, 10U));
                NumberOfTotalUsersSupported = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));
                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));
                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));
                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 305441741UL));
                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));
                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 305441741UL));
                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 3));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));
                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 305441741UL));
                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 3));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 6));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));
                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 305441741UL));
                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 3));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 6));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 2));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("test_user", 9)));
                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 466460832UL));
                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 1));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("test_user2", 10)));
                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 12648430UL));
                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 2));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, NumberOfTotalUsersSupported));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("last_user", 9)));
                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNull("nextUserIndex", value.nextUserIndex));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));
                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, NumberOfTotalUsersSupported));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNull("nextUserIndex", value.nextUserIndex));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfPINUsersSupported", value, 10U));
                NumberOfPINUsersSupported = value;
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));
                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentials", value.credentials));
                {
                    auto iter_1 = value.credentials.Value().begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 1));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 1U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 1));
                }

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, true));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfRFIDUsersSupported", value, 10U));
                NumberOfRFIDUsersSupported = value;
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));
                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentials", value.credentials));
                {
                    auto iter_1 = value.credentials.Value().begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 1));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 1U));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 1));
                    VerifyOrReturn(CheckValue("credentials.Value()[1].credentialType", iter_1.GetValue().credentialType, 2));
                    VerifyOrReturn(CheckValue("credentials.Value()[1].credentialIndex", iter_1.GetValue().credentialIndex, 2U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 2));
                }

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, true));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 3));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 2));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 5U));
            }
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 2));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 5U));
            }
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 2U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 2));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 5U));
            }
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));
                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentials", value.credentials));
                {
                    auto iter_1 = value.credentials.Value().begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 2));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 2U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 1));
                }

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 2U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 2U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 3U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 7U));
            }
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 7U));
            }
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 3U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 4U));
            }
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));
                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));
                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));
                VerifyOrReturn(CheckValueNonNull("credentials", value.credentials));
                {
                    auto iter_1 = value.credentials.Value().begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 0U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 1));
                }

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));
                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, true));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));
                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));
                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class DL_LockUnlockSuite : public TestCommand
{
public:
    DL_LockUnlockSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("DL_LockUnlock", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~DL_LockUnlockSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: DL_LockUnlock\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: DL_LockUnlock\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 11;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Create new PIN credential and lock/unlock user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Try to unlock the door with invalid PIN\n");
            chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::UnlockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Verify that lock state attribute value is set to Locked\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Try to unlock the door with valid PIN\n");
            chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::UnlockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Verify that lock state attribute value is set to Unlocked\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Try to lock the door with invalid PIN\n");
            chip::app::Clusters::DoorLock::Commands::LockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::LockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Verify that lock state attribute value is set to Unlocked\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Try to unlock the door with valid PIN\n");
            chip::app::Clusters::DoorLock::Commands::LockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::LockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Verify that lock state attribute value is set to Locked\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Clean the created credential\n");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 1));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 2));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 2));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 1));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class DL_SchedulesSuite : public TestCommand
{
public:
    DL_SchedulesSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("DL_Schedules", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~DL_SchedulesSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: DL_Schedules\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: DL_Schedules\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 84;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t NumberOfTotalUsersSupported;
    uint8_t NumberOfWeekDaySchedulesSupportedPerUser;
    uint8_t NumberOfYearDaySchedulesSupportedPerUser;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Create new PIN credential and schedule user\n");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Get number of supported users\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfTotalUsersSupported::Id);
        }
        case 3: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Get Max number of Week Day schedules for user and verify default value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfWeekDaySchedulesSupportedPerUser::Id);
        }
        case 4: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Get Max number of Year Day schedules for user and verify default value\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfYearDaySchedulesSupportedPerUser::Id);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Create Week Day schedule with 0 index\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 0;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Create Week Day schedule with out-of-bounds index\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Create Week Day schedule with 0 user index\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 0U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Create Week Day schedule with out-of-bounds user index\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Create Week Day schedule for non-existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 2U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Create Week Day schedule with 0 days mask\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(0);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Create Week Day schedule for Sunday and Monday\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(3);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Create Week Day schedule for Sunday Wednesday and Saturday\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(73);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Create Week Day schedule with invalid start hour\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 24;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Create Week Day schedule with invalid start minute\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 60;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Create Week Day schedule with invalid end hour\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 24;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Create Week Day schedule with invalid end minute\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 60;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Create Week Day schedule with start hour later that end hour\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 19;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 18: {
            ChipLogProgress(
                chipTool,
                " ***** Test Step 18 : Create Week Day schedule with start minute later that end minute when hours are equal\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 50;
            value.endHour      = 15;
            value.endMinute    = 49;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Make sure that previous operations did not create a schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Get Week Day schedule with 0 index\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 0;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Get Week Day schedule with out-of-bounds index\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Get Week Day schedule with 0 user index\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : Get Week Day schedule with out-of-bounds user index\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : Get Week Day schedule with non-existing user index\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 25: {
            ChipLogProgress(chipTool, " ***** Test Step 25 : Create Year Day schedule with 0 index\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 0;
            value.userIndex      = 1U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 26: {
            ChipLogProgress(chipTool, " ***** Test Step 26 : Create Year Day schedule with out-of-bounds index\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
            value.userIndex      = 1U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 27: {
            ChipLogProgress(chipTool, " ***** Test Step 27 : Create Year Day schedule with 0 user index\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 0U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 28: {
            ChipLogProgress(chipTool, " ***** Test Step 28 : Create Year Day schedule with out-of-bounds user index\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 29: {
            ChipLogProgress(chipTool, " ***** Test Step 29 : Create Year Day schedule for non-existing user\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 2U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 30: {
            ChipLogProgress(chipTool, " ***** Test Step 30 : Create Year Day schedule with start hour later that end hour\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 1U;
            value.localStartTime = 12345689UL;
            value.localEndTime   = 12345688UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 31: {
            ChipLogProgress(chipTool, " ***** Test Step 31 : Make sure that previous operations did not create a schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 32: {
            ChipLogProgress(chipTool, " ***** Test Step 32 : Get Year Day schedule with 0 index\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 0;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 33: {
            ChipLogProgress(chipTool, " ***** Test Step 33 : Get Year Day schedule with out-of-bounds index\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 34: {
            ChipLogProgress(chipTool, " ***** Test Step 34 : Get Year Day schedule with 0 user index\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 35: {
            ChipLogProgress(chipTool, " ***** Test Step 35 : Get Year Day schedule with out-of-bounds user index\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 36: {
            ChipLogProgress(chipTool, " ***** Test Step 36 : Get Year Day schedule with non-existing user index\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 37: {
            ChipLogProgress(chipTool, " ***** Test Step 37 : Create Week Day schedule with valid parameters\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 38: {
            ChipLogProgress(chipTool, " ***** Test Step 38 : Verify created schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 39: {
            ChipLogProgress(chipTool, " ***** Test Step 39 : Create Year Day schedule with valid parameters\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 1U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 40: {
            ChipLogProgress(chipTool, " ***** Test Step 40 : Verify created schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 41: {
            ChipLogProgress(chipTool, " ***** Test Step 41 : Clear Week Day schedule with 0 index\n");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 0;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 42: {
            ChipLogProgress(chipTool, " ***** Test Step 42 : Clear Week Day schedule with out-of-bounds index\n");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 43: {
            ChipLogProgress(chipTool, " ***** Test Step 43 : Clear Week Day schedule with 0 user index\n");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 44: {
            ChipLogProgress(chipTool, " ***** Test Step 44 : Clear Week Day schedule with out-of-bounds user index\n");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 45: {
            ChipLogProgress(chipTool, " ***** Test Step 45 : Clear Week Day schedule with non-existing user\n");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 46: {
            ChipLogProgress(chipTool, " ***** Test Step 46 : Clear Year Day schedule with 0 index\n");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 0;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 47: {
            ChipLogProgress(chipTool, " ***** Test Step 47 : Clear Year Day schedule with out-of-bounds index\n");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 48: {
            ChipLogProgress(chipTool, " ***** Test Step 48 : Clear Year Day schedule with 0 user index\n");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 49: {
            ChipLogProgress(chipTool, " ***** Test Step 49 : Clear Year Day schedule with out-of-bounds user index\n");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 50: {
            ChipLogProgress(chipTool, " ***** Test Step 50 : Clear Year Day schedule with non-existing user\n");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 51: {
            ChipLogProgress(chipTool, " ***** Test Step 51 : Make sure that week day schedule was not deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 52: {
            ChipLogProgress(chipTool, " ***** Test Step 52 : Make sure that year day schedule was not deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 53: {
            ChipLogProgress(chipTool, " ***** Test Step 53 : Create another Week Day schedule with valid parameters\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 2;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(2);
            value.startHour    = 0;
            value.startMinute  = 0;
            value.endHour      = 23;
            value.endMinute    = 59;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 54: {
            ChipLogProgress(chipTool, " ***** Test Step 54 : Verify created week day schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 55: {
            ChipLogProgress(chipTool, " ***** Test Step 55 : Create another Year Day schedule with valid parameters\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 2;
            value.userIndex      = 1U;
            value.localStartTime = 9000UL;
            value.localEndTime   = 888888888UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 56: {
            ChipLogProgress(chipTool, " ***** Test Step 56 : Verify created year day schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 57: {
            ChipLogProgress(chipTool, " ***** Test Step 57 : Clear a single week day schedule for the first user\n");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 58: {
            ChipLogProgress(chipTool, " ***** Test Step 58 : Verify cleared week day schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 59: {
            ChipLogProgress(chipTool, " ***** Test Step 59 : Clear all remaining week day schedules for the first user\n");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 254;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 60: {
            ChipLogProgress(chipTool, " ***** Test Step 60 : Verify cleared week schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 61: {
            ChipLogProgress(chipTool, " ***** Test Step 61 : Make sure that first year day schedule was not deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 62: {
            ChipLogProgress(chipTool, " ***** Test Step 62 : Make sure that second year day schedule was not deleted\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 63: {
            ChipLogProgress(chipTool, " ***** Test Step 63 : Create another Week Day schedule with valid parameters\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(2);
            value.startHour    = 0;
            value.startMinute  = 0;
            value.endHour      = 23;
            value.endMinute    = 59;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 64: {
            ChipLogProgress(chipTool, " ***** Test Step 64 : Clear a single year day schedule for the first user\n");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 65: {
            ChipLogProgress(chipTool, " ***** Test Step 65 : Verify cleared year day schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 66: {
            ChipLogProgress(chipTool, " ***** Test Step 66 : Clear all remaining year schedules for the first user\n");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 254;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 67: {
            ChipLogProgress(chipTool, " ***** Test Step 67 : Verify that second year day schedule was cleared\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 68: {
            ChipLogProgress(chipTool, " ***** Test Step 68 : Verify created week day schedule\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 69: {
            ChipLogProgress(chipTool, " ***** Test Step 69 : Clear all remaining week day schedules for the first user\n");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 254;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 70: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 70 : Create new user without credential so we can add more schedules to it\n");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 2U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 71: {
            ChipLogProgress(chipTool, " ***** Test Step 71 : Create Week Day schedule with valid parameters for first user\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 0;
            value.startMinute  = 0;
            value.endHour      = 23;
            value.endMinute    = 59;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 72: {
            ChipLogProgress(chipTool, " ***** Test Step 72 : Verify created week day schedule for first user\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 73: {
            ChipLogProgress(chipTool, " ***** Test Step 73 : Create Year Day schedule for first user\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 4;
            value.userIndex      = 1U;
            value.localStartTime = 9000UL;
            value.localEndTime   = 888888888UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 74: {
            ChipLogProgress(chipTool, " ***** Test Step 74 : Verify created year day schedule for first\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 4;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 75: {
            ChipLogProgress(chipTool, " ***** Test Step 75 : Create Week Day schedule with valid parameters for second user\n");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 4;
            value.userIndex    = 2U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(64);
            value.startHour    = 23;
            value.startMinute  = 0;
            value.endHour      = 23;
            value.endMinute    = 59;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 76: {
            ChipLogProgress(chipTool, " ***** Test Step 76 : Verify created week day schedule for first user\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 4;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 77: {
            ChipLogProgress(chipTool, " ***** Test Step 77 : Create Year Day schedule for second user\n");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 1U;
            value.localStartTime = 55555UL;
            value.localEndTime   = 7777777UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 78: {
            ChipLogProgress(chipTool, " ***** Test Step 78 : Verify created year day schedule for first\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 79: {
            ChipLogProgress(chipTool, " ***** Test Step 79 : Cleanup\n");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 65534U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 80: {
            ChipLogProgress(chipTool, " ***** Test Step 80 : Make sure clearing first user also cleared week day schedules\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 81: {
            ChipLogProgress(chipTool, " ***** Test Step 81 : Make sure clearing first user also cleared year day schedules\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 4;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 82: {
            ChipLogProgress(chipTool, " ***** Test Step 82 : Make sure clearing second user also cleared week day schedules\n");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 4;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 83: {
            ChipLogProgress(chipTool, " ***** Test Step 83 : Make sure clearing second user also cleared year day schedules\n");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));
                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfTotalUsersSupported", value, 10U));
                NumberOfTotalUsersSupported = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfWeekDaySchedulesSupportedPerUser", value, 10));
                NumberOfWeekDaySchedulesSupportedPerUser = value;
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfYearDaySchedulesSupportedPerUser", value, 10));
                NumberOfYearDaySchedulesSupportedPerUser = value;
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 0));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex,
                                          static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 0U));
                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, static_cast<uint8_t>(NumberOfTotalUsersSupported + 1)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 0));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex,
                                          static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 0U));
                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, static_cast<uint8_t>(NumberOfTotalUsersSupported + 1)));
                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 1));
                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 15));
                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 16));
                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 18));
                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 0));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 12345UL));
                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 12345689UL));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 1));
                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 15));
                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 16));
                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 18));
                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 0));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 12345UL));
                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 12345689UL));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 2));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 2));
                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 0));
                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 0));
                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 23));
                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 59));
            }
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 2));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 9000UL));
                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 888888888UL));
            }
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 2));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 12345UL));
                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 12345689UL));
            }
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 2));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 9000UL));
                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 888888888UL));
            }
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 2));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 2));
                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 0));
                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 0));
                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 23));
                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 59));
            }
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 1));
                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 0));
                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 0));
                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 23));
                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 59));
            }
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 4));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 9000UL));
                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 888888888UL));
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 4));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 64));
                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 23));
                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 0));
                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 23));
                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 59));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 55555UL));
                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 7777777UL));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 4));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 4));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));
                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestGroupMessagingSuite : public TestCommand
{
public:
    TestGroupMessagingSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestGroupMessaging", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupMessagingSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupMessaging\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupMessaging\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 13;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Add Group 1 (endpoint 1)\n");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 257U;
            value.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Add Group 2 (endpoint 0)\n");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 258U;
            value.groupName = chip::Span<const char>("Group #2garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : KeySet Write 1\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 417U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(1);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xafgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 1110000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbfgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 1110001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcfgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 1110002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : KeySet Write 2\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 418U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(1);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdfgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 2220000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xefgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 2220001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xffgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 2220002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write Group Keys\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].fabricIndex   = 1;
                listHolder_0->mList[0].groupId       = 257U;
                listHolder_0->mList[0].groupKeySetID = 417U;

                listHolder_0->mList[1].fabricIndex   = 1;
                listHolder_0->mList[1].groupId       = 258U;
                listHolder_0->mList[1].groupKeySetID = 418U;

                value = chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                  GroupKeyManagement::Attributes::GroupKeyMap::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Install ACLs for test\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].fabricIndex = 1;
                listHolder_0->mList[0].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();

                listHolder_0->mList[1].fabricIndex = 1;
                listHolder_0->mList[1].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(3);
                listHolder_0->mList[1].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(3);
                listHolder_0->mList[1].subjects.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<uint64_t>(2);
                    listFreer.add(listHolder_3);
                    listHolder_3->mList[0]                  = 257ULL;
                    listHolder_3->mList[1]                  = 258ULL;
                    listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 2);
                }
                listHolder_0->mList[1].targets.SetNull();

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Group Write Attribute\n");
            chip::CharSpan value;
            value = chip::Span<const char>("USgarbage: not in length on purpose", 2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read back Attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Restore initial location value\n");
            chip::CharSpan value;
            value = chip::Span<const char>("XXgarbage: not in length on purpose", 2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read back Attribute\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Turn On the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : Check on/off attribute value is true after on command for endpoint 1\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 257U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 258U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("location", value, chip::CharSpan("US", 2)));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("location", value, chip::CharSpan("XX", 2)));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestGroupsClusterSuite : public TestCommand
{
public:
    TestGroupsClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestGroupsCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupsClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupsCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 19;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : View Group 0 (invalid)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : View Group 1 (not found)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Add Group 1 (new)\n");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 1U;
            value.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : View Group 1 (new)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : View Group 2 (not found)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 4369U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Get Group Membership 1 (all)\n");
            ListFreer listFreer;
            chip::app::Clusters::Groups::Commands::GetGroupMembership::Type value;

            value.groupList = chip::app::DataModel::List<uint16_t>();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::GetGroupMembership::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : View Group 3 (not found)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 32767U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : View Group 1 (existing)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Remove Group 0 (invalid)\n");
            chip::app::Clusters::Groups::Commands::RemoveGroup::Type value;
            value.groupId = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::RemoveGroup::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Remove Group 4 (not found)\n");
            chip::app::Clusters::Groups::Commands::RemoveGroup::Type value;
            value.groupId = 4U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::RemoveGroup::Id, value);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : View Group 1 (not removed)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : View Group 2 (removed)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 4369U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Get Group Membership 3\n");
            ListFreer listFreer;
            chip::app::Clusters::Groups::Commands::GetGroupMembership::Type value;

            {
                auto * listHolder_0 = new ListHolder<uint16_t>(4);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1U;
                listHolder_0->mList[1] = 2U;
                listHolder_0->mList[2] = 4369U;
                listHolder_0->mList[3] = 3U;
                value.groupList        = chip::app::DataModel::List<uint16_t>(listHolder_0->mList, 4);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::GetGroupMembership::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Remove All\n");
            chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::RemoveAllGroups::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : View Group 1 (removed)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : View Group 2 (still removed)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 4369U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : View Group 3 (removed)\n");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 32767U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Get Group Membership 4\n");
            ListFreer listFreer;
            chip::app::Clusters::Groups::Commands::GetGroupMembership::Type value;

            {
                auto * listHolder_0 = new ListHolder<uint16_t>(5);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1U;
                listHolder_0->mList[1] = 2U;
                listHolder_0->mList[2] = 4369U;
                listHolder_0->mList[3] = 3U;
                listHolder_0->mList[4] = 32767U;
                value.groupList        = chip::app::DataModel::List<uint16_t>(listHolder_0->mList, 5);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::GetGroupMembership::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 135));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 0U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
                VerifyOrReturn(CheckValueAsString("groupName", value.groupName, chip::CharSpan("Group #1", 8)));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 4369U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("capacity", value.capacity, 255));
                {
                    auto iter_0 = value.groupList.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.groupList)>("groupList", iter_0, 0));
                    VerifyOrReturn(CheckValue("groupList[0]", iter_0.GetValue(), 1U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.groupList)>("groupList", iter_0, 1));
                }
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 32767U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
                VerifyOrReturn(CheckValueAsString("groupName", value.groupName, chip::CharSpan("Group #1", 8)));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::RemoveGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 135));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 0U));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::RemoveGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 4U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
                VerifyOrReturn(CheckValueAsString("groupName", value.groupName, chip::CharSpan("Group #1", 8)));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 4369U));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("capacity", value.capacity, 255));
                {
                    auto iter_0 = value.groupList.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.groupList)>("groupList", iter_0, 0));
                    VerifyOrReturn(CheckValue("groupList[0]", iter_0.GetValue(), 1U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.groupList)>("groupList", iter_0, 1));
                }
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 4369U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 32767U));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("capacity", value.capacity, 255));
                {
                    auto iter_0 = value.groupList.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.groupList)>("groupList", iter_0, 0));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestGroupKeyManagementClusterSuite : public TestCommand
{
public:
    TestGroupKeyManagementClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupKeyManagementCluster", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupKeyManagementClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupKeyManagementCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupKeyManagementCluster\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read maxGroupsPerFabric\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                 GroupKeyManagement::Attributes::MaxGroupsPerFabric::Id);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read maxGroupKeysPerFabric\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                 GroupKeyManagement::Attributes::MaxGroupKeysPerFabric::Id);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Add Group 1\n");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 257U;
            value.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Add Group 2\n");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 258U;
            value.groupName = chip::Span<const char>("Group #2garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : KeySet Write 1\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 417U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(0);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xafgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 1110000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbfgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 1110001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcfgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 1110002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : KeySet Write 2\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 418U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(1);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdfgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 2110000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xefgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 2110001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xffgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 2110002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : KeySet Read\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type value;
            value.groupKeySetID = 417U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id, GroupKeyManagement::Commands::KeySetRead::Id,
                               value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write Group Keys\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].fabricIndex   = 1;
                listHolder_0->mList[0].groupId       = 257U;
                listHolder_0->mList[0].groupKeySetID = 417U;

                listHolder_0->mList[1].fabricIndex   = 1;
                listHolder_0->mList[1].groupId       = 258U;
                listHolder_0->mList[1].groupKeySetID = 418U;

                value = chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                  GroupKeyManagement::Attributes::GroupKeyMap::Id, value);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read Group Keys\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                 GroupKeyManagement::Attributes::GroupKeyMap::Id);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read GroupTable\n");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                 GroupKeyManagement::Attributes::GroupTable::Id);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : KeySet Remove 1\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRemove::Type value;
            value.groupKeySetID = 417U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetRemove::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : KeySet Read (removed)\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type value;
            value.groupKeySetID = 417U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id, GroupKeyManagement::Commands::KeySetRead::Id,
                               value);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : KeySet Read (not removed)\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type value;
            value.groupKeySetID = 418U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id, GroupKeyManagement::Commands::KeySetRead::Id,
                               value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Remove All\n");
            chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::RemoveAllGroups::Id, value);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : KeySet Remove 2\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRemove::Type value;
            value.groupKeySetID = 418U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetRemove::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : KeySet Read (also removed)\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type value;
            value.groupKeySetID = 418U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id, GroupKeyManagement::Commands::KeySetRead::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value", value, 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxGroupKeysPerFabric", value, 2U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 257U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 258U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("groupKeySet.groupKeySetID", value.groupKeySet.groupKeySetID, 417U));
                VerifyOrReturn(CheckValue("groupKeySet.groupKeySecurityPolicy", value.groupKeySet.groupKeySecurityPolicy, 0));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey0", value.groupKeySet.epochKey0));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime0", value.groupKeySet.epochStartTime0));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime0.Value()", value.groupKeySet.epochStartTime0.Value(), 1110000ULL));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey1", value.groupKeySet.epochKey1));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime1", value.groupKeySet.epochStartTime1));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime1.Value()", value.groupKeySet.epochStartTime1.Value(), 1110001ULL));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey2", value.groupKeySet.epochKey2));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime2", value.groupKeySet.epochStartTime2));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime2.Value()", value.groupKeySet.epochStartTime2.Value(), 1110002ULL));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("groupKeyMap", iter_0, 0));
                    VerifyOrReturn(CheckValue("groupKeyMap[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckValue("groupKeyMap[0].groupId", iter_0.GetValue().groupId, 257U));
                    VerifyOrReturn(CheckValue("groupKeyMap[0].groupKeySetID", iter_0.GetValue().groupKeySetID, 417U));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("groupKeyMap", iter_0, 1));
                    VerifyOrReturn(CheckValue("groupKeyMap[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckValue("groupKeyMap[1].groupId", iter_0.GetValue().groupId, 258U));
                    VerifyOrReturn(CheckValue("groupKeyMap[1].groupKeySetID", iter_0.GetValue().groupKeySetID, 418U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("groupKeyMap", iter_0, 2));
                }
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("groupTable", iter_0, 0));
                    VerifyOrReturn(CheckValue("groupTable[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckValue("groupTable[0].groupId", iter_0.GetValue().groupId, 257U));
                    VerifyOrReturn(CheckValuePresent("groupTable[0].groupName", iter_0.GetValue().groupName));
                    VerifyOrReturn(CheckValueAsString("groupTable[0].groupName.Value()", iter_0.GetValue().groupName.Value(),
                                                      chip::CharSpan("Group #1", 8)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("groupTable", iter_0, 1));
                    VerifyOrReturn(CheckValue("groupTable[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckValue("groupTable[1].groupId", iter_0.GetValue().groupId, 258U));
                    VerifyOrReturn(CheckValuePresent("groupTable[1].groupName", iter_0.GetValue().groupName));
                    VerifyOrReturn(CheckValueAsString("groupTable[1].groupName.Value()", iter_0.GetValue().groupName.Value(),
                                                      chip::CharSpan("Group #2", 8)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("groupTable", iter_0, 2));
                }
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("groupKeySet.groupKeySetID", value.groupKeySet.groupKeySetID, 418U));
                VerifyOrReturn(CheckValue("groupKeySet.groupKeySecurityPolicy", value.groupKeySet.groupKeySecurityPolicy, 1));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey0", value.groupKeySet.epochKey0));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime0", value.groupKeySet.epochStartTime0));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime0.Value()", value.groupKeySet.epochStartTime0.Value(), 2110000ULL));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey1", value.groupKeySet.epochKey1));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime1", value.groupKeySet.epochStartTime1));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime1.Value()", value.groupKeySet.epochStartTime1.Value(), 2110001ULL));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey2", value.groupKeySet.epochKey2));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime2", value.groupKeySet.epochStartTime2));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime2.Value()", value.groupKeySet.epochStartTime2.Value(), 2110002ULL));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestDiscoverySuite : public TestCommand
{
public:
    TestDiscoverySuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestDiscovery", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("vendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("productId", 0, UINT16_MAX, &mProductId);
        AddArgument("deviceType", 0, UINT16_MAX, &mDeviceType);
    }

    ~TestDiscoverySuite()
    {
        if (deviceInstanceNameBeforeRebootBuffer != nullptr)
        {
            chip::Platform::MemoryFree(deviceInstanceNameBeforeRebootBuffer);
            deviceInstanceNameBeforeRebootBuffer = nullptr;
        }
    }

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDiscovery\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDiscovery\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 25;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<uint16_t> mVendorId;
    chip::Optional<uint16_t> mProductId;
    chip::Optional<uint16_t> mDeviceType;

    char * deviceInstanceNameBeforeRebootBuffer = nullptr;
    chip::CharSpan deviceInstanceNameBeforeReboot;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reboot target device\n");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : GetUniqueDiscriminator());
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Open Commissioning Window\n");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 120U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait Commissionable advertisement\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionableAdvertisement();
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check Instance Name\n");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check Long Discriminator _L\n");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByLongDiscriminator(mDiscriminator.HasValue() ? mDiscriminator.Value()
                                                                                   : GetUniqueDiscriminator());
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check Short Discriminator (_S)\n");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByShortDiscriminator(mDiscriminator.HasValue() ? mDiscriminator.Value()
                                                                                    : GetUniqueDiscriminator());
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check Commissioning Mode (_CM)\n");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByCommissioningMode();
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check Vendor ID (_V)\n");
            VerifyOrdo(!ShouldSkip("VENDOR_SUBTYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByVendorId(mVendorId.HasValue() ? mVendorId.Value() : 65521U);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : TXT key for discriminator (D)\n");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : TXT key for Vendor ID and Product ID (VP)\n");
            VerifyOrdo(!ShouldSkip("VP_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : TXT key for Vendor ID and Product ID (VP)\n");
            VerifyOrdo(!ShouldSkip("VP_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Optional TXT key for MRP Retry Interval Idle (CRI)\n");
            VerifyOrdo(!ShouldSkip("CRI_COMM_DISCOVERY_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Optional TXT key for MRP Retry Interval Active (CRA)\n");
            VerifyOrdo(!ShouldSkip("CRA_COMM_DISCOVERY_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : TXT key for commissioning mode (CM)\n");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Optional TXT key for device name (DN)\n");
            VerifyOrdo(!ShouldSkip("DN_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Optional TXT key for rotating device identifier (RI)\n");
            VerifyOrdo(!ShouldSkip("RI_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Optional TXT key for pairing hint (PH)\n");
            VerifyOrdo(!ShouldSkip("PH_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Optional TXT key for pairing instructions (PI)\n");
            VerifyOrdo(!ShouldSkip("PI_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Check IPs\n");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Reboot target device\n");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : GetUniqueDiscriminator());
        }
        case 21: {
            ChipLogProgress(chipTool, " ***** Test Step 21 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 22: {
            ChipLogProgress(chipTool, " ***** Test Step 22 : Open Commissioning Window\n");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 120U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 23: {
            ChipLogProgress(chipTool, " ***** Test Step 23 : Wait Commissionable advertisement\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionableAdvertisement();
        }
        case 24: {
            ChipLogProgress(chipTool, " ***** Test Step 24 : Check Instance Name\n");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintIsUpperCase("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintIsHexString("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintMinLength("value.instanceName", value.instanceName.size(), 16));
                VerifyOrReturn(CheckConstraintMaxLength("value.instanceName", value.instanceName.size(), 16));
                if (deviceInstanceNameBeforeRebootBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(deviceInstanceNameBeforeRebootBuffer);
                }
                deviceInstanceNameBeforeRebootBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.instanceName.size()));
                memcpy(deviceInstanceNameBeforeRebootBuffer, value.instanceName.data(), value.instanceName.size());
                deviceInstanceNameBeforeReboot = chip::CharSpan(deviceInstanceNameBeforeRebootBuffer, value.instanceName.size());
            }
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("longDiscriminator", value.longDiscriminator,
                                          mDiscriminator.HasValue() ? mDiscriminator.Value() : GetUniqueDiscriminator()));
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value.longDiscriminator", value.longDiscriminator, 0U));
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value.longDiscriminator", value.longDiscriminator, 4096U));
            }
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("vendorId", value.vendorId, mVendorId.HasValue() ? mVendorId.Value() : 65521U));
            }
            shouldContinue = true;
            break;
        case 11:
            if (status.mStatus == Status::UnsupportedAttribute || status.mStatus == Status::UnsupportedCommand)
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("productId", value.productId, mProductId.HasValue() ? mProductId.Value() : 32769U));
            }
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValuePresent("value.mrpRetryIntervalIdle", value.mrpRetryIntervalIdle));
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("value.mrpRetryIntervalIdle.Value()",
                                                                 value.mrpRetryIntervalIdle.Value(), 3600000UL));
            }
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValuePresent("value.mrpRetryIntervalActive", value.mrpRetryIntervalActive));
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("value.mrpRetryIntervalActive.Value()",
                                                                 value.mrpRetryIntervalActive.Value(), 3600000UL));
            }
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("commissioningMode", value.commissioningMode, 1));
            }
            shouldContinue = true;
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxLength("value.deviceName", value.deviceName.size(), 32));
            }
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxValue<uint64_t>("value.rotatingIdLen", value.rotatingIdLen, 100ULL));
            }
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxLength("value.pairingInstruction", value.pairingInstruction.size(), 128));
            }
            shouldContinue = true;
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value.numIPs", value.numIPs, 1));
            }
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintIsUpperCase("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintIsHexString("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintMinLength("value.instanceName", value.instanceName.size(), 16));
                VerifyOrReturn(CheckConstraintMaxLength("value.instanceName", value.instanceName.size(), 16));
                VerifyOrReturn(CheckConstraintNotValue("value.instanceName", value.instanceName, deviceInstanceNameBeforeReboot));
            }
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_1_5Suite : public TestCommand
{
public:
    Test_TC_DD_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            SetIdentity(kIdentityAlpha);
            return Log("Verify that the onboarding payload for NFC tags SHALL use NDEF URI Record Type Definition as defined by "
                       "NFC Forum in URI Record Type Definition RTD URI");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_1_6Suite : public TestCommand
{
public:
    Test_TC_DD_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_6", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_6\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            SetIdentity(kIdentityAlpha);
            return Log("Scan the DUTs QR code using a QR code reader");
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1 verification\n");
            SetIdentity(kIdentityAlpha);
            return Log(
                "Verify the QR code gets scanned successfully and the QR code must be of sufficient size and contrast respective "
                "to surface material as to be readable with standard readers such as smartphones in normal lighting conditions");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step 2 verificaiton\n");
            SetIdentity(kIdentityAlpha);
            return Log("Verify QR code version is 1 or higher");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_1_7Suite : public TestCommand
{
public:
    Test_TC_DD_1_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_7", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_7\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition\n");
            SetIdentity(kIdentityAlpha);
            return Log("Verify manual pairing code is printed on the device or in additional provided materials");
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1\n");
            SetIdentity(kIdentityAlpha);
            return Log("Verify that the Manual Pairing Code should be printed using a minimum font size of 6 points typically "
                       "producing a typeface height of 2.1 mm");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_1_8Suite : public TestCommand
{
public:
    Test_TC_DD_1_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_8", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_8Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_8\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            SetIdentity(kIdentityAlpha);
            return Log("Scan the device QR code using DUT");
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1 verification\n");
            SetIdentity(kIdentityAlpha);
            return Log(
                "Verify the DUT is able to scan and parse the QR code successfully to onboard the device onto the CHIP network");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_1_9Suite : public TestCommand
{
public:
    Test_TC_DD_1_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_9", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_9\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition\n");
            SetIdentity(kIdentityAlpha);
            return Log("Verify that the manual pairing code is printed on the device or in additional provided materials");
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1\n");
            SetIdentity(kIdentityAlpha);
            return Log(
                "Provide the 11 digit or 21 digit pairing code from the Device in text speech or any format supported by DUT");
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step 1 verification\n");
            SetIdentity(kIdentityAlpha);
            return Log("Verify that the manual pairing code can be provided to DUT and parsed to onboard the device onto the CHIP "
                       "network");
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_1_10Suite : public TestCommand
{
public:
    Test_TC_DD_1_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_10", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_10Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_10\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_2_1Suite : public TestCommand
{
public:
    Test_TC_DD_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_2_2Suite : public TestCommand
{
public:
    Test_TC_DD_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_3_1Suite : public TestCommand
{
public:
    Test_TC_DD_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_3_2Suite : public TestCommand
{
public:
    Test_TC_DD_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_3_5Suite : public TestCommand
{
public:
    Test_TC_DD_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_3_6Suite : public TestCommand
{
public:
    Test_TC_DD_3_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_6", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_6\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_3_9Suite : public TestCommand
{
public:
    Test_TC_DD_3_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_9", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_9\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_3_10Suite : public TestCommand
{
public:
    Test_TC_DD_3_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_10", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_10Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_10\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DD_4_1Suite : public TestCommand
{
public:
    Test_TC_DD_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_4_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_4_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestGroupDemoCommandSuite : public TestCommand
{
public:
    TestGroupDemoCommandSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestGroupDemoCommand", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupDemoCommandSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupDemoCommand\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupDemoCommand\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 21;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn On the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn Off the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 4: {
            ChipLogProgress(chipTool, " ***** Test Step 4 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 5: {
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn On the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 6: {
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 7: {
            ChipLogProgress(chipTool, " ***** Test Step 7 : Turn Off the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 8: {
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 9: {
            ChipLogProgress(chipTool, " ***** Test Step 9 : Turn On the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 10: {
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 11: {
            ChipLogProgress(chipTool, " ***** Test Step 11 : Turn Off the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 12: {
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 13: {
            ChipLogProgress(chipTool, " ***** Test Step 13 : Turn On the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 14: {
            ChipLogProgress(chipTool, " ***** Test Step 14 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 15: {
            ChipLogProgress(chipTool, " ***** Test Step 15 : Turn Off the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 16: {
            ChipLogProgress(chipTool, " ***** Test Step 16 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 17: {
            ChipLogProgress(chipTool, " ***** Test Step 17 : Turn On the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 18: {
            ChipLogProgress(chipTool, " ***** Test Step 18 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 19: {
            ChipLogProgress(chipTool, " ***** Test Step 19 : Turn Off the light to see attribute change\n");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 20: {
            ChipLogProgress(chipTool, " ***** Test Step 20 : Wait 100ms\n");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class TestGroupDemoConfigSuite : public TestCommand
{
public:
    TestGroupDemoConfigSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestGroupDemoConfig", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupDemoConfigSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupDemoConfig\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupDemoConfig\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            ChipLogProgress(chipTool, " ***** Test Step 1 : Add Group 1 - endpoint 1\n");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 257U;
            value.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 2: {
            ChipLogProgress(chipTool, " ***** Test Step 2 : KeySet Write 1\n");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 417U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(0);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xafgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 1110000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbfgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 1110001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcfgarbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 1110002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 3: {
            ChipLogProgress(chipTool, " ***** Test Step 3 : Map Group Key Set to group ID on a given fabric\n");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].fabricIndex   = 1;
                listHolder_0->mList[0].groupId       = 257U;
                listHolder_0->mList[0].groupKeySetID = 417U;

                value = chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 1);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                  GroupKeyManagement::Attributes::GroupKeyMap::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
                VerifyOrReturn(CheckValue("groupId", value.groupId, 257U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_1_1Suite : public TestCommand
{
public:
    Test_TC_BDX_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_1_2Suite : public TestCommand
{
public:
    Test_TC_BDX_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_1_3Suite : public TestCommand
{
public:
    Test_TC_BDX_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_1_5Suite : public TestCommand
{
public:
    Test_TC_BDX_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_1_6Suite : public TestCommand
{
public:
    Test_TC_BDX_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_6", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_6\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_2_1Suite : public TestCommand
{
public:
    Test_TC_BDX_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_2_2Suite : public TestCommand
{
public:
    Test_TC_BDX_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_2_3Suite : public TestCommand
{
public:
    Test_TC_BDX_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_2_4Suite : public TestCommand
{
public:
    Test_TC_BDX_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BDX_2_5Suite : public TestCommand
{
public:
    Test_TC_BDX_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BR_1Suite : public TestCommand
{
public:
    Test_TC_BR_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BR_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BR_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BR_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BR_2Suite : public TestCommand
{
public:
    Test_TC_BR_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BR_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BR_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BR_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BR_3Suite : public TestCommand
{
public:
    Test_TC_BR_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BR_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BR_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BR_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BRAC_2_1Suite : public TestCommand
{
public:
    Test_TC_BRAC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BRAC_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BRAC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BRAC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BRAC_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_BRAC_2_2Suite : public TestCommand
{
public:
    Test_TC_BRAC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BRAC_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BRAC_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BRAC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BRAC_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DM_1_2Suite : public TestCommand
{
public:
    Test_TC_DM_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DM_2_3Suite : public TestCommand
{
public:
    Test_TC_DM_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_2_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_2_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DM_3_2Suite : public TestCommand
{
public:
    Test_TC_DM_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_3_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DIAG_LOG_1_1Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DIAG_LOG_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DIAG_LOG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_LOG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_LOG_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DIAG_LOG_1_2Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DIAG_LOG_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DIAG_LOG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_LOG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_LOG_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DIAG_LOG_1_3Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DIAG_LOG_1_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DIAG_LOG_1_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_LOG_1_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_LOG_1_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_DESC_1_1Suite : public TestCommand
{
public:
    Test_TC_DESC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DESC_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DESC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DESC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DESC_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_ETHDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_ETHDIAG_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ETHDIAG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ETHDIAG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ETHDIAG_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_GC_1_1Suite : public TestCommand
{
public:
    Test_TC_GC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_GC_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GC_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_GC_1_2Suite : public TestCommand
{
public:
    Test_TC_GC_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_GC_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GC_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GC_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GC_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_GC_1_3Suite : public TestCommand
{
public:
    Test_TC_GC_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_GC_1_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GC_1_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GC_1_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GC_1_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_GENDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_GENDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_GENDIAG_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GENDIAG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GENDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GENDIAG_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_GENDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_GENDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_GENDIAG_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GENDIAG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GENDIAG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GENDIAG_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_I_1_1Suite : public TestCommand
{
public:
    Test_TC_I_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_I_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_I_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_I_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_I_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_I_2_1Suite : public TestCommand
{
public:
    Test_TC_I_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_I_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_I_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_I_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_I_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_I_2_2Suite : public TestCommand
{
public:
    Test_TC_I_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_I_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_I_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_I_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_I_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_I_2_3Suite : public TestCommand
{
public:
    Test_TC_I_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_I_2_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_I_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_I_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_I_2_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_ILL_2_1Suite : public TestCommand
{
public:
    Test_TC_ILL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_ILL_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ILL_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ILL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ILL_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_1_1Suite : public TestCommand
{
public:
    Test_TC_IDM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_1_2Suite : public TestCommand
{
public:
    Test_TC_IDM_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_2_1Suite : public TestCommand
{
public:
    Test_TC_IDM_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_2_2Suite : public TestCommand
{
public:
    Test_TC_IDM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_3_1Suite : public TestCommand
{
public:
    Test_TC_IDM_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_3_2Suite : public TestCommand
{
public:
    Test_TC_IDM_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_3_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_3_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_4_1Suite : public TestCommand
{
public:
    Test_TC_IDM_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_4_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_4_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_4_2Suite : public TestCommand
{
public:
    Test_TC_IDM_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_4_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_4_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_4_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_4_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_5_1Suite : public TestCommand
{
public:
    Test_TC_IDM_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_5_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_5_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_5_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_5_2Suite : public TestCommand
{
public:
    Test_TC_IDM_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_5_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_5_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_5_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_6_1Suite : public TestCommand
{
public:
    Test_TC_IDM_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_6_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_6_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_6_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_IDM_6_2Suite : public TestCommand
{
public:
    Test_TC_IDM_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_6_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_6_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_6_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_3_12Suite : public TestCommand
{
public:
    Test_TC_MC_3_12Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_12", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_12Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_12\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_12\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_4_1Suite : public TestCommand
{
public:
    Test_TC_MC_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_4_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_4_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_8_2Suite : public TestCommand
{
public:
    Test_TC_MC_8_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_8_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_8_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_8_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_8_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_9_2Suite : public TestCommand
{
public:
    Test_TC_MC_9_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_9_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_9_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_9_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_9_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_10_1Suite : public TestCommand
{
public:
    Test_TC_MC_10_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_10_2Suite : public TestCommand
{
public:
    Test_TC_MC_10_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_10_3Suite : public TestCommand
{
public:
    Test_TC_MC_10_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_10_4Suite : public TestCommand
{
public:
    Test_TC_MC_10_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_10_5Suite : public TestCommand
{
public:
    Test_TC_MC_10_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MC_10_6Suite : public TestCommand
{
public:
    Test_TC_MC_10_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_6", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_6\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_1Suite : public TestCommand
{
public:
    Test_TC_MF_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_2Suite : public TestCommand
{
public:
    Test_TC_MF_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_3Suite : public TestCommand
{
public:
    Test_TC_MF_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_4Suite : public TestCommand
{
public:
    Test_TC_MF_1_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_5Suite : public TestCommand
{
public:
    Test_TC_MF_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_6Suite : public TestCommand
{
public:
    Test_TC_MF_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_6", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_6\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_7Suite : public TestCommand
{
public:
    Test_TC_MF_1_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_7", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_7\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_8Suite : public TestCommand
{
public:
    Test_TC_MF_1_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_8", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_8Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_8\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_9Suite : public TestCommand
{
public:
    Test_TC_MF_1_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_9", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_9\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_10Suite : public TestCommand
{
public:
    Test_TC_MF_1_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_10", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_10Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_10\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_11Suite : public TestCommand
{
public:
    Test_TC_MF_1_11Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_11", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_11Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_11\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_11\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_12Suite : public TestCommand
{
public:
    Test_TC_MF_1_12Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_12", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_12Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_12\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_12\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_13Suite : public TestCommand
{
public:
    Test_TC_MF_1_13Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_13", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_13Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_13\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_13\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_14Suite : public TestCommand
{
public:
    Test_TC_MF_1_14Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_14", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_14Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_14\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_14\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_15Suite : public TestCommand
{
public:
    Test_TC_MF_1_15Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_15", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_15Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_15\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_15\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_16Suite : public TestCommand
{
public:
    Test_TC_MF_1_16Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_16", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_16Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_16\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_16\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_17Suite : public TestCommand
{
public:
    Test_TC_MF_1_17Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_17", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_17Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_17\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_17\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_18Suite : public TestCommand
{
public:
    Test_TC_MF_1_18Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_18", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_18Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_18\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_18\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_19Suite : public TestCommand
{
public:
    Test_TC_MF_1_19Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_19", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_19Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_19\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_19\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_20Suite : public TestCommand
{
public:
    Test_TC_MF_1_20Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_20", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_20Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_20\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_20\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_21Suite : public TestCommand
{
public:
    Test_TC_MF_1_21Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_21", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_21Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_21\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_21\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_22Suite : public TestCommand
{
public:
    Test_TC_MF_1_22Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_22", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_22Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_22\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_22\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_23Suite : public TestCommand
{
public:
    Test_TC_MF_1_23Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_23", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_23Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_23\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_23\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MF_1_24Suite : public TestCommand
{
public:
    Test_TC_MF_1_24Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_24", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_24Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_24\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_24\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MOD_1_1Suite : public TestCommand
{
public:
    Test_TC_MOD_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MOD_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MOD_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MOD_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MOD_1_2Suite : public TestCommand
{
public:
    Test_TC_MOD_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MOD_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MOD_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MOD_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_MOD_2_1Suite : public TestCommand
{
public:
    Test_TC_MOD_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MOD_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MOD_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MOD_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_1_1Suite : public TestCommand
{
public:
    Test_TC_SU_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_2_1Suite : public TestCommand
{
public:
    Test_TC_SU_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_2_2Suite : public TestCommand
{
public:
    Test_TC_SU_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_2_3Suite : public TestCommand
{
public:
    Test_TC_SU_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_2_4Suite : public TestCommand
{
public:
    Test_TC_SU_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_2_5Suite : public TestCommand
{
public:
    Test_TC_SU_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_2_6Suite : public TestCommand
{
public:
    Test_TC_SU_2_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_6", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_6\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_2_7Suite : public TestCommand
{
public:
    Test_TC_SU_2_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_7", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_7\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_3_1Suite : public TestCommand
{
public:
    Test_TC_SU_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_3_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_3_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_3_2Suite : public TestCommand
{
public:
    Test_TC_SU_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_3_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_3_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_3_3Suite : public TestCommand
{
public:
    Test_TC_SU_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_3_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_3_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_3_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SU_3_4Suite : public TestCommand
{
public:
    Test_TC_SU_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_3_4", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_3_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_3_4\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PSCFG_1_1Suite : public TestCommand
{
public:
    Test_TC_PSCFG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PSCFG_1_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PSCFG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PSCFG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PSCFG_1_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_PSCFG_2_1Suite : public TestCommand
{
public:
    Test_TC_PSCFG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PSCFG_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PSCFG_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PSCFG_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PSCFG_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SC_4_5Suite : public TestCommand
{
public:
    Test_TC_SC_4_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_5", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_5\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SC_4_6Suite : public TestCommand
{
public:
    Test_TC_SC_4_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_6", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_6\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SC_4_7Suite : public TestCommand
{
public:
    Test_TC_SC_4_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_7", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_7\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SC_4_8Suite : public TestCommand
{
public:
    Test_TC_SC_4_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_8", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_8Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_8\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SC_4_9Suite : public TestCommand
{
public:
    Test_TC_SC_4_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_9", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_9\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_SWDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWDIAG_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWDIAG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WIFIDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WIFIDIAG_1_2", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WIFIDIAG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_1_2\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WIFIDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WIFIDIAG_2_1", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WIFIDIAG_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_2_1\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

class Test_TC_WNCV_2_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_3", credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_3\n");
            InteractionModel::Shutdown();
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        CHIP_ERROR err = DoTestStep(mTestIndex++);
        if (CHIP_NO_ERROR != err)
        {
            Exit(chip::ErrorStr(err));
        }
    }

private:
    std::atomic_uint16_t mTestIndex = 0;
    const uint16_t mTestCount       = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }
};

void registerCommandsTests(Commands & commands, CredentialIssuerCommands * credsIssuerConfig)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
        make_unique<TestList>(),
        make_unique<ManualTestList>(),
        make_unique<Test_TC_BI_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BI_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BI_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BOOL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BOOL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_8_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_EMR_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_ILL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_11Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_7_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_7_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_8_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_9_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_PS_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PRS_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PRS_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWTCH_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWTCH_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_TH_NW_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_4Suite>(credsIssuerConfig),
        make_unique<TV_TargetNavigatorClusterSuite>(credsIssuerConfig),
        make_unique<TV_AudioOutputClusterSuite>(credsIssuerConfig),
        make_unique<TV_ApplicationLauncherClusterSuite>(credsIssuerConfig),
        make_unique<TV_KeypadInputClusterSuite>(credsIssuerConfig),
        make_unique<TV_AccountLoginClusterSuite>(credsIssuerConfig),
        make_unique<TV_WakeOnLanClusterSuite>(credsIssuerConfig),
        make_unique<TV_ApplicationBasicClusterSuite>(credsIssuerConfig),
        make_unique<TV_MediaPlaybackClusterSuite>(credsIssuerConfig),
        make_unique<TV_ChannelClusterSuite>(credsIssuerConfig),
        make_unique<TV_LowPowerClusterSuite>(credsIssuerConfig),
        make_unique<TV_ContentLauncherClusterSuite>(credsIssuerConfig),
        make_unique<TV_MediaInputClusterSuite>(credsIssuerConfig),
        make_unique<TestClusterSuite>(credsIssuerConfig),
        make_unique<TestClusterComplexTypesSuite>(credsIssuerConfig),
        make_unique<TestConstraintsSuite>(credsIssuerConfig),
        make_unique<TestDelayCommandsSuite>(credsIssuerConfig),
        make_unique<TestLogCommandsSuite>(credsIssuerConfig),
        make_unique<TestSaveAsSuite>(credsIssuerConfig),
        make_unique<TestConfigVariablesSuite>(credsIssuerConfig),
        make_unique<TestDescriptorClusterSuite>(credsIssuerConfig),
        make_unique<TestBasicInformationSuite>(credsIssuerConfig),
        make_unique<TestIdentifyClusterSuite>(credsIssuerConfig),
        make_unique<TestOperationalCredentialsClusterSuite>(credsIssuerConfig),
        make_unique<TestModeSelectClusterSuite>(credsIssuerConfig),
        make_unique<TestSystemCommandsSuite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_3_1Suite>(credsIssuerConfig),
        make_unique<TestSubscribe_OnOffSuite>(credsIssuerConfig),
        make_unique<DL_UsersAndCredentialsSuite>(credsIssuerConfig),
        make_unique<DL_LockUnlockSuite>(credsIssuerConfig),
        make_unique<DL_SchedulesSuite>(credsIssuerConfig),
        make_unique<TestGroupMessagingSuite>(credsIssuerConfig),
        make_unique<TestGroupsClusterSuite>(credsIssuerConfig),
        make_unique<TestGroupKeyManagementClusterSuite>(credsIssuerConfig),
        make_unique<TestDiscoverySuite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_4_1Suite>(credsIssuerConfig),
        make_unique<TestGroupDemoCommandSuite>(credsIssuerConfig),
        make_unique<TestGroupDemoConfigSuite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DESC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_GENDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_GENDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_ILL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_12Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_8_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_9_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_11Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_12Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_13Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_14Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_15Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_16Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_17Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_18Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_19Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_20Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_21Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_22Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_23Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_24Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_PSCFG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PSCFG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_3Suite>(credsIssuerConfig),
    };

    commands.Register(clusterName, clusterCommands);
}
