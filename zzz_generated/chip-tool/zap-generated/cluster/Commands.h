/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <cstdint>
#include <string>
#include <type_traits>

#include <app-common/zap-generated/cluster-objects.h>
#include <app/data-model/DecodableList.h>
#include <app/data-model/Nullable.h>
#include <commands/clusters/ModelCommand.h>
#include <commands/common/CommandInvoker.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/support/BytesToHex.h>
#include <lib/support/Span.h>
#include <lib/support/TypeTraits.h>
#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

// Value logging functions.  The non-generated ones depend on the
// generated ones, so are placed here.
namespace {

CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::detail::Structs::LabelStruct::DecodableType & value);

CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Scenes::Structs::SceneExtensionFieldSet::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::PowerProfileRecord::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::ScheduledPhase::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::TransferredPhase::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AccessControl::Structs::Target::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::ThreadInterfaceScanResult::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::WiFiInterfaceScanResult::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Structs::SoftwareFaultStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType & value);
CHIP_ERROR
LogValue(const char * label, size_t indent,
         const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeySet::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ModeSelect::Structs::SemanticTag::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::IasAce::Structs::IasAceZoneStatusResult::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Channel::Structs::LineupInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::Dimension::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::AdditionalInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::Parameter::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentSearch::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::StyleInformation::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::BrandingInformation::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ApplicationLauncher::Structs::ApplicationLauncherApplication::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEP::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApplication::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NestedStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NestedStructList::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::DoubleNestedStructList::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType & value);

void LogAttributePath(const chip::app::ConcreteDataAttributePath & path)
{
    ChipLogProgress(chipTool, "Endpoint: %" PRIu16 " Cluster: " ChipLogFormatMEI " Attribute " ChipLogFormatMEI, path.mEndpointId,
                    ChipLogValueMEI(path.mClusterId), ChipLogValueMEI(path.mAttributeId));
}

void LogEventPath(const chip::app::ConcreteEventPath & path)
{
    ChipLogProgress(chipTool, "Endpoint: %" PRIu16 " Cluster: " ChipLogFormatMEI " Event " ChipLogFormatMEI, path.mEndpointId,
                    ChipLogValueMEI(path.mClusterId), ChipLogValueMEI(path.mEventId));
}

void LogEventHeader(const chip::app::EventHeader & header)
{
    LogEventPath(header.mPath);

    ChipLogProgress(chipTool, "\t Event number: %" PRIu64, header.mEventNumber);

    if (header.mPriorityLevel == chip::app::PriorityLevel::Info)
    {
        ChipLogProgress(chipTool, "\t Priority: Info");
    }
    else if (header.mPriorityLevel == chip::app::PriorityLevel::Critical)
    {
        ChipLogProgress(chipTool, "\t Priority: Critical");
    }
    else if (header.mPriorityLevel == chip::app::PriorityLevel::Debug)
    {
        ChipLogProgress(chipTool, "\t Priority: Debug");
    }
    else
    {
        ChipLogProgress(chipTool, "\t Priority: Unknown");
    }

    ChipLogProgress(chipTool, "\t Timestamp: %" PRIu64, header.mTimestamp.mValue);
}

CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Events::StateChanged::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Events::ActionFailed::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::Clusters::Basic::Events::StartUp::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::Clusters::Basic::Events::ShutDown::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::Clusters::Basic::Events::Leave::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Basic::Events::ReachableChanged::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::StateTransition::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::VersionApplied::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::DownloadError::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Events::HardwareFaultChange::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Events::RadioFaultChange::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Events::NetworkFaultChange::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Events::BootReason::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Events::SoftwareFault::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Events::ConnectionStatus::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::WiFiNetworkDiagnostics::Events::Disconnection::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::WiFiNetworkDiagnostics::Events::AssociationFailure::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::WiFiNetworkDiagnostics::Events::ConnectionStatus::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::SwitchLatched::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::InitialPress::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::Clusters::Switch::Events::LongPress::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::ShortRelease::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::LongRelease::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::MultiPressOngoing::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::MultiPressComplete::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BooleanState::Events::StateChange::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::DoorLockAlarm::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::DoorStateChange::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::LockOperation::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::LockOperationError::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::LockUserChange::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SupplyVoltageLow::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SupplyVoltageHigh::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::PowerMissingPhase::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SystemPressureLow::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SystemPressureHigh::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::DryRunning::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::MotorTemperatureHigh::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::PumpMotorFatalFailure::DecodableType & value);
CHIP_ERROR
LogValue(const char * label, size_t indent,
         const chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicTemperatureHigh::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::PumpBlocked::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SensorFailure::DecodableType & value);
CHIP_ERROR
LogValue(const char * label, size_t indent,
         const chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicNonFatalFailure::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicFatalFailure::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::GeneralFault::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::Leakage::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::AirDetection::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::TurbineOperation::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType & value);

#if CHIP_PROGRESS_LOGGING
std::string IndentStr(size_t indent)
{
    std::string str;
    for (size_t i = 0; i < indent; ++i)
    {
        str.append("  ");
    }
    return str;
}
#endif // CHIP_PROGRESS_LOGGING

template <typename X,
          typename std::enable_if_t<
              std::is_integral<X>::value && !std::is_same<std::remove_cv_t<std::remove_reference_t<X>>, bool>::value, int> = 0>
CHIP_ERROR LogValue(const char * label, size_t indent, X value)
{
    ChipLogProgress(chipTool, "%s%s: %s", IndentStr(indent).c_str(), label, std::to_string(value).c_str());
    return CHIP_NO_ERROR;
}

template <typename X, typename std::enable_if_t<std::is_floating_point<X>::value, int> = 0>
CHIP_ERROR LogValue(const char * label, size_t indent, X value)
{
    ChipLogProgress(chipTool, "%s%s: %s", IndentStr(indent).c_str(), label, std::to_string(value).c_str());
    return CHIP_NO_ERROR;
}

CHIP_ERROR LogValue(const char * label, size_t indent, bool value)
{
    ChipLogProgress(chipTool, "%s%s: %s", IndentStr(indent).c_str(), label, value ? "TRUE" : "FALSE");
    return CHIP_NO_ERROR;
}

template <typename X, typename std::enable_if_t<std::is_enum<X>::value, int> = 0>
CHIP_ERROR LogValue(const char * label, size_t indent, X value)
{
    return LogValue(label, indent, chip::to_underlying(value));
}

CHIP_ERROR LogValue(const char * label, size_t indent, chip::CharSpan value)
{
    ChipLogProgress(chipTool, "%s%s: %.*s", IndentStr(indent).c_str(), label, static_cast<int>(value.size()), value.data());
    return CHIP_NO_ERROR;
}

CHIP_ERROR LogValue(const char * label, size_t indent, chip::ByteSpan value)
{
    char buffer[CHIP_CONFIG_LOG_MESSAGE_MAX_SIZE];
    if (CHIP_NO_ERROR ==
        chip::Encoding::BytesToUppercaseHexString(value.data(), value.size(), &buffer[0], CHIP_CONFIG_LOG_MESSAGE_MAX_SIZE))
    {
        ChipLogProgress(chipTool, "%s%s: %s", IndentStr(indent).c_str(), label, buffer);
    }
    else
    {
        ChipLogProgress(chipTool, "%s%s: %zu", IndentStr(indent).c_str(), label, value.size());
    }
    return CHIP_NO_ERROR;
}

template <typename X>
CHIP_ERROR LogValue(const char * label, size_t indent, chip::BitFlags<X> value)
{
    return LogValue(label, indent, value.Raw());
}

template <typename T>
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::DataModel::DecodableList<T> & value)
{
    size_t count   = 0;
    CHIP_ERROR err = value.ComputeSize(&count);
    if (err != CHIP_NO_ERROR)
    {
        return err;
    }
    ChipLogProgress(chipTool, "%s%s: %zu entries", IndentStr(indent).c_str(), label, count);

    auto iter = value.begin();
    size_t i  = 0;
    while (iter.Next())
    {
        ++i;
        std::string itemLabel = std::string("[") + std::to_string(i) + "]";
        ReturnErrorOnFailure(LogValue(itemLabel.c_str(), indent + 1, iter.GetValue()));
    }
    if (iter.GetStatus() != CHIP_NO_ERROR)
    {
        ChipLogProgress(chipTool, "%sList truncated due to invalid value", IndentStr(indent + 1).c_str());
    }
    return iter.GetStatus();
}

template <typename T>
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::DataModel::Nullable<T> & value)
{
    if (!value.IsNull())
    {
        return LogValue(label, indent, value.Value());
    }
    ChipLogProgress(chipTool, "%s%s: null", IndentStr(indent).c_str(), label);
    return CHIP_NO_ERROR;
}

template <typename T>
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::Optional<T> & value)
{
    if (value.HasValue())
    {
        return LogValue(label, indent, value.Value());
    }

    return CHIP_NO_ERROR;
}

// We output helpers for all structs here, including ones we might not actually
// be logging.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::detail::Structs::LabelStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Label", indent + 1, value.label);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Label'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}

CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Scenes::Structs::SceneExtensionFieldSet::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ClusterId", indent + 1, value.clusterId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ClusterId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Length", indent + 1, value.length);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Length'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::PowerProfileRecord::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("PowerProfileId", indent + 1, value.powerProfileId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PowerProfileId'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EnergyPhaseId", indent + 1, value.energyPhaseId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EnergyPhaseId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PowerProfileRemoteControl", indent + 1, value.powerProfileRemoteControl);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PowerProfileRemoteControl'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PowerProfileState", indent + 1, value.powerProfileState);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PowerProfileState'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::ScheduledPhase::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("EnergyPhaseId", indent + 1, value.energyPhaseId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EnergyPhaseId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ScheduledTime", indent + 1, value.scheduledTime);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ScheduledTime'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::TransferredPhase::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("EnergyPhaseId", indent + 1, value.energyPhaseId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EnergyPhaseId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MacroPhaseId", indent + 1, value.macroPhaseId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MacroPhaseId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ExpectedDuration", indent + 1, value.expectedDuration);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExpectedDuration'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PeakPower", indent + 1, value.peakPower);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PeakPower'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Energy", indent + 1, value.energy);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Energy'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MaxActivationDelay", indent + 1, value.maxActivationDelay);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MaxActivationDelay'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Revision", indent + 1, value.revision);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Revision'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AccessControl::Structs::Target::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Cluster", indent + 1, value.cluster);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Cluster'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Endpoint", indent + 1, value.endpoint);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Endpoint'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("DeviceType", indent + 1, value.deviceType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'DeviceType'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Privilege", indent + 1, value.privilege);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Privilege'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("AuthMode", indent + 1, value.authMode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'AuthMode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Subjects", indent + 1, value.subjects);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Subjects'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Targets", indent + 1, value.targets);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Targets'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Data", indent + 1, value.data);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Data'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ActionID", indent + 1, value.actionID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ActionID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EndpointListID", indent + 1, value.endpointListID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EndpointListID'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SupportedCommands", indent + 1, value.supportedCommands);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'SupportedCommands'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Status", indent + 1, value.status);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Status'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("EndpointListID", indent + 1, value.endpointListID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EndpointListID'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Endpoints", indent + 1, value.endpoints);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Endpoints'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ProviderNodeID", indent + 1, value.providerNodeID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ProviderNodeID'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Endpoint", indent + 1, value.endpoint);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Endpoint'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FailSafeExpiryLengthMs", indent + 1, value.failSafeExpiryLengthMs);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FailSafeExpiryLengthMs'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("NetworkID", indent + 1, value.networkID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NetworkID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Connected", indent + 1, value.connected);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Connected'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::ThreadInterfaceScanResult::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("PanId", indent + 1, value.panId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PanId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ExtendedPanId", indent + 1, value.extendedPanId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExtendedPanId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NetworkName", indent + 1, value.networkName);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NetworkName'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Channel", indent + 1, value.channel);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Channel'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Version", indent + 1, value.version);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Version'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ExtendedAddress", indent + 1, value.extendedAddress);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExtendedAddress'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Rssi", indent + 1, value.rssi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Rssi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Lqi", indent + 1, value.lqi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Lqi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::WiFiInterfaceScanResult::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Security", indent + 1, value.security);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Security'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Ssid", indent + 1, value.ssid);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Ssid'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Bssid", indent + 1, value.bssid);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Bssid'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Channel", indent + 1, value.channel);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Channel'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("WiFiBand", indent + 1, value.wiFiBand);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'WiFiBand'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Rssi", indent + 1, value.rssi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Rssi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FabricConnected", indent + 1, value.fabricConnected);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricConnected'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OffPremiseServicesReachableIPv4", indent + 1, value.offPremiseServicesReachableIPv4);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OffPremiseServicesReachableIPv4'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OffPremiseServicesReachableIPv6", indent + 1, value.offPremiseServicesReachableIPv6);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OffPremiseServicesReachableIPv6'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("HardwareAddress", indent + 1, value.hardwareAddress);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'HardwareAddress'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Structs::SoftwareFaultStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Id", indent + 1, value.id);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Id'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FaultRecording", indent + 1, value.faultRecording);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FaultRecording'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Id", indent + 1, value.id);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Id'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("StackFreeCurrent", indent + 1, value.stackFreeCurrent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'StackFreeCurrent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("StackFreeMinimum", indent + 1, value.stackFreeMinimum);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'StackFreeMinimum'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("StackSize", indent + 1, value.stackSize);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'StackSize'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ExtAddress", indent + 1, value.extAddress);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExtAddress'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Age", indent + 1, value.age);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Age'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Rloc16", indent + 1, value.rloc16);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Rloc16'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LinkFrameCounter", indent + 1, value.linkFrameCounter);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LinkFrameCounter'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MleFrameCounter", indent + 1, value.mleFrameCounter);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MleFrameCounter'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Lqi", indent + 1, value.lqi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Lqi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("AverageRssi", indent + 1, value.averageRssi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'AverageRssi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LastRssi", indent + 1, value.lastRssi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LastRssi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FrameErrorRate", indent + 1, value.frameErrorRate);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FrameErrorRate'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MessageErrorRate", indent + 1, value.messageErrorRate);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MessageErrorRate'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("RxOnWhenIdle", indent + 1, value.rxOnWhenIdle);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'RxOnWhenIdle'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FullThreadDevice", indent + 1, value.fullThreadDevice);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FullThreadDevice'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FullNetworkData", indent + 1, value.fullNetworkData);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FullNetworkData'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("IsChild", indent + 1, value.isChild);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'IsChild'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR
LogValue(const char * label, size_t indent,
         const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ActiveTimestampPresent", indent + 1, value.activeTimestampPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ActiveTimestampPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PendingTimestampPresent", indent + 1, value.pendingTimestampPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PendingTimestampPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MasterKeyPresent", indent + 1, value.masterKeyPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MasterKeyPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NetworkNamePresent", indent + 1, value.networkNamePresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NetworkNamePresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ExtendedPanIdPresent", indent + 1, value.extendedPanIdPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExtendedPanIdPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MeshLocalPrefixPresent", indent + 1, value.meshLocalPrefixPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MeshLocalPrefixPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("DelayPresent", indent + 1, value.delayPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'DelayPresent'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PanIdPresent", indent + 1, value.panIdPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PanIdPresent'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ChannelPresent", indent + 1, value.channelPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ChannelPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PskcPresent", indent + 1, value.pskcPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PskcPresent'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SecurityPolicyPresent", indent + 1, value.securityPolicyPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'SecurityPolicyPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ChannelMaskPresent", indent + 1, value.channelMaskPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ChannelMaskPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ExtAddress", indent + 1, value.extAddress);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExtAddress'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Rloc16", indent + 1, value.rloc16);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Rloc16'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("RouterId", indent + 1, value.routerId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'RouterId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NextHop", indent + 1, value.nextHop);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NextHop'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PathCost", indent + 1, value.pathCost);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PathCost'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LQIIn", indent + 1, value.LQIIn);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LQIIn'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LQIOut", indent + 1, value.LQIOut);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LQIOut'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Age", indent + 1, value.age);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Age'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Allocated", indent + 1, value.allocated);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Allocated'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LinkEstablished", indent + 1, value.linkEstablished);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LinkEstablished'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("RotationTime", indent + 1, value.rotationTime);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'RotationTime'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Flags", indent + 1, value.flags);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Flags'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("RootPublicKey", indent + 1, value.rootPublicKey);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'RootPublicKey'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("VendorId", indent + 1, value.vendorId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'VendorId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FabricId", indent + 1, value.fabricId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NodeId", indent + 1, value.nodeId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NodeId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Label", indent + 1, value.label);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Label'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Noc", indent + 1, value.noc);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Noc'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupId", indent + 1, value.groupId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Endpoints", indent + 1, value.endpoints);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Endpoints'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupName", indent + 1, value.groupName);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupName'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupId", indent + 1, value.groupId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupKeySetID", indent + 1, value.groupKeySetID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupKeySetID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeySet::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("GroupKeySetID", indent + 1, value.groupKeySetID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupKeySetID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SecurityPolicy", indent + 1, value.securityPolicy);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'SecurityPolicy'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EpochKey0", indent + 1, value.epochKey0);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EpochKey0'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EpochStartTime0", indent + 1, value.epochStartTime0);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EpochStartTime0'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EpochKey1", indent + 1, value.epochKey1);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EpochKey1'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EpochStartTime1", indent + 1, value.epochStartTime1);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EpochStartTime1'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EpochKey2", indent + 1, value.epochKey2);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EpochKey2'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EpochStartTime2", indent + 1, value.epochStartTime2);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EpochStartTime2'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Label", indent + 1, value.label);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Label'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Mode", indent + 1, value.mode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Mode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SemanticTag", indent + 1, value.semanticTag);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'SemanticTag'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ModeSelect::Structs::SemanticTag::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("MfgCode", indent + 1, value.mfgCode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MfgCode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("CredentialType", indent + 1, value.credentialType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'CredentialType'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("CredentialIndex", indent + 1, value.credentialIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'CredentialIndex'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::IasAce::Structs::IasAceZoneStatusResult::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ZoneId", indent + 1, value.zoneId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ZoneId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ZoneStatus", indent + 1, value.zoneStatus);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ZoneStatus'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("MajorNumber", indent + 1, value.majorNumber);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MajorNumber'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MinorNumber", indent + 1, value.minorNumber);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MinorNumber'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("CallSign", indent + 1, value.callSign);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'CallSign'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("AffiliateCallSign", indent + 1, value.affiliateCallSign);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'AffiliateCallSign'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Channel::Structs::LineupInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("OperatorName", indent + 1, value.operatorName);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OperatorName'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LineupName", indent + 1, value.lineupName);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LineupName'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PostalCode", indent + 1, value.postalCode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PostalCode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LineupInfoType", indent + 1, value.lineupInfoType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LineupInfoType'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Identifier", indent + 1, value.identifier);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Identifier'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("UpdatedAt", indent + 1, value.updatedAt);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'UpdatedAt'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Position", indent + 1, value.position);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Position'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Index", indent + 1, value.index);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Index'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("InputType", indent + 1, value.inputType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'InputType'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Description", indent + 1, value.description);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Description'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::Dimension::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Width", indent + 1, value.width);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Width'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Height", indent + 1, value.height);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Height'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Metric", indent + 1, value.metric);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Metric'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::AdditionalInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::Parameter::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ExternalIDList", indent + 1, value.externalIDList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExternalIDList'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentSearch::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ParameterList", indent + 1, value.parameterList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ParameterList'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::StyleInformation::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ImageUrl", indent + 1, value.imageUrl);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ImageUrl'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Color", indent + 1, value.color);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Color'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Size", indent + 1, value.size);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Size'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::BrandingInformation::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ProviderName", indent + 1, value.providerName);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ProviderName'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Background", indent + 1, value.background);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Background'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Logo", indent + 1, value.logo);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Logo'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ProgressBar", indent + 1, value.progressBar);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ProgressBar'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Splash", indent + 1, value.splash);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Splash'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("WaterMark", indent + 1, value.waterMark);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'WaterMark'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Index", indent + 1, value.index);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Index'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OutputType", indent + 1, value.outputType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OutputType'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ApplicationLauncher::Structs::ApplicationLauncherApplication::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("CatalogVendorId", indent + 1, value.catalogVendorId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'CatalogVendorId'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ApplicationId", indent + 1, value.applicationId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ApplicationId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEP::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Application", indent + 1, value.application);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Application'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Endpoint", indent + 1, value.endpoint);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Endpoint'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApplication::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("CatalogVendorId", indent + 1, value.catalogVendorId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'CatalogVendorId'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ApplicationId", indent + 1, value.applicationId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ApplicationId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("A", indent + 1, value.a);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'A'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("B", indent + 1, value.b);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'B'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("C", indent + 1, value.c);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'C'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("D", indent + 1, value.d);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'D'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("E", indent + 1, value.e);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'E'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("F", indent + 1, value.f);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'F'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("G", indent + 1, value.g);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'G'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("H", indent + 1, value.h);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'H'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("NullableInt", indent + 1, value.nullableInt);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableInt'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OptionalInt", indent + 1, value.optionalInt);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OptionalInt'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableOptionalInt", indent + 1, value.nullableOptionalInt);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableOptionalInt'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableString", indent + 1, value.nullableString);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableString'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OptionalString", indent + 1, value.optionalString);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OptionalString'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableOptionalString", indent + 1, value.nullableOptionalString);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableOptionalString'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableStruct", indent + 1, value.nullableStruct);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableStruct'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OptionalStruct", indent + 1, value.optionalStruct);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OptionalStruct'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableOptionalStruct", indent + 1, value.nullableOptionalStruct);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableOptionalStruct'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableList", indent + 1, value.nullableList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableList'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OptionalList", indent + 1, value.optionalList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OptionalList'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableOptionalList", indent + 1, value.nullableOptionalList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableOptionalList'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NestedStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("A", indent + 1, value.a);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'A'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("B", indent + 1, value.b);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'B'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("C", indent + 1, value.c);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'C'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NestedStructList::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("A", indent + 1, value.a);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'A'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("B", indent + 1, value.b);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'B'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("C", indent + 1, value.c);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'C'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("D", indent + 1, value.d);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'D'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("E", indent + 1, value.e);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'E'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("F", indent + 1, value.f);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'F'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("G", indent + 1, value.g);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'G'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::DoubleNestedStructList::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("A", indent + 1, value.a);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'A'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OperationalCert", indent + 1, value.operationalCert);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OperationalCert'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
#pragma GCC diagnostic pop

// We output helpers for all events here, including ones we might not actually
// be logging.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Events::StateChanged::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ActionID", indent + 1, value.actionID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'ActionID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("InvokeID", indent + 1, value.invokeID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'InvokeID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NewState", indent + 1, value.newState);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'NewState'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Events::ActionFailed::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ActionID", indent + 1, value.actionID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'ActionID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("InvokeID", indent + 1, value.invokeID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'InvokeID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NewState", indent + 1, value.newState);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'NewState'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Error", indent + 1, value.error);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Error'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::Clusters::Basic::Events::StartUp::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("SoftwareVersion", indent + 1, value.softwareVersion);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'SoftwareVersion'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::Clusters::Basic::Events::ShutDown::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::Clusters::Basic::Events::Leave::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Basic::Events::ReachableChanged::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ReachableNewValue", indent + 1, value.reachableNewValue);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'ReachableNewValue'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::StateTransition::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("PreviousState", indent + 1, value.previousState);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'PreviousState'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NewState", indent + 1, value.newState);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'NewState'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Reason", indent + 1, value.reason);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Reason'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("TargetSoftwareVersion", indent + 1, value.targetSoftwareVersion);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'TargetSoftwareVersion'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::VersionApplied::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("SoftwareVersion", indent + 1, value.softwareVersion);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'SoftwareVersion'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ProductID", indent + 1, value.productID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'ProductID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::DownloadError::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("SoftwareVersion", indent + 1, value.softwareVersion);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'SoftwareVersion'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("BytesDownloaded", indent + 1, value.bytesDownloaded);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'BytesDownloaded'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ProgressPercent", indent + 1, value.progressPercent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'ProgressPercent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PlatformCode", indent + 1, value.platformCode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'PlatformCode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Events::HardwareFaultChange::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Current", indent + 1, value.current);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Current'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Previous", indent + 1, value.previous);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Previous'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Events::RadioFaultChange::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Current", indent + 1, value.current);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Current'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Previous", indent + 1, value.previous);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Previous'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Events::NetworkFaultChange::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Current", indent + 1, value.current);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Current'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Previous", indent + 1, value.previous);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Previous'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Events::BootReason::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("BootReason", indent + 1, value.bootReason);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'BootReason'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Events::SoftwareFault::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("SoftwareFault", indent + 1, value.softwareFault);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'SoftwareFault'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Events::ConnectionStatus::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ConnectionStatus", indent + 1, value.connectionStatus);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'ConnectionStatus'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::WiFiNetworkDiagnostics::Events::Disconnection::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ReasonCode", indent + 1, value.reasonCode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'ReasonCode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::WiFiNetworkDiagnostics::Events::AssociationFailure::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("AssociationFailure", indent + 1, value.associationFailure);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'AssociationFailure'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Status", indent + 1, value.status);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Status'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::WiFiNetworkDiagnostics::Events::ConnectionStatus::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ConnectionStatus", indent + 1, value.connectionStatus);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'ConnectionStatus'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::SwitchLatched::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("NewPosition", indent + 1, value.newPosition);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'NewPosition'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::InitialPress::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("NewPosition", indent + 1, value.newPosition);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'NewPosition'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::Clusters::Switch::Events::LongPress::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("NewPosition", indent + 1, value.newPosition);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'NewPosition'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::ShortRelease::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("PreviousPosition", indent + 1, value.previousPosition);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'PreviousPosition'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::LongRelease::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("PreviousPosition", indent + 1, value.previousPosition);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'PreviousPosition'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::MultiPressOngoing::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("NewPosition", indent + 1, value.newPosition);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'NewPosition'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("CurrentNumberOfPressesCounted", indent + 1, value.currentNumberOfPressesCounted);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'CurrentNumberOfPressesCounted'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Switch::Events::MultiPressComplete::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("NewPosition", indent + 1, value.newPosition);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'NewPosition'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("TotalNumberOfPressesCounted", indent + 1, value.totalNumberOfPressesCounted);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'TotalNumberOfPressesCounted'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BooleanState::Events::StateChange::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("StateValue", indent + 1, value.stateValue);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'StateValue'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::DoorLockAlarm::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("AlarmCode", indent + 1, value.alarmCode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'AlarmCode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::DoorStateChange::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("DoorState", indent + 1, value.doorState);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'DoorState'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::LockOperation::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("LockOperationType", indent + 1, value.lockOperationType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'LockOperationType'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OperationSource", indent + 1, value.operationSource);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'OperationSource'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("UserIndex", indent + 1, value.userIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'UserIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SourceNode", indent + 1, value.sourceNode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'SourceNode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Credentials", indent + 1, value.credentials);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Credentials'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::LockOperationError::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("LockOperationType", indent + 1, value.lockOperationType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'LockOperationType'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OperationSource", indent + 1, value.operationSource);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'OperationSource'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OperationError", indent + 1, value.operationError);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'OperationError'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("UserIndex", indent + 1, value.userIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'UserIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SourceNode", indent + 1, value.sourceNode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'SourceNode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Credentials", indent + 1, value.credentials);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Credentials'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::DoorLock::Events::LockUserChange::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("LockDataType", indent + 1, value.lockDataType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'LockDataType'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("DataOperationType", indent + 1, value.dataOperationType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'DataOperationType'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OperationSource", indent + 1, value.operationSource);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'OperationSource'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("UserIndex", indent + 1, value.userIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'UserIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SourceNode", indent + 1, value.sourceNode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'SourceNode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("DataIndex", indent + 1, value.dataIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'DataIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SupplyVoltageLow::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SupplyVoltageHigh::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::PowerMissingPhase::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SystemPressureLow::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SystemPressureHigh::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::DryRunning::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::MotorTemperatureHigh::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::PumpMotorFatalFailure::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR
LogValue(const char * label, size_t indent,
         const chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicTemperatureHigh::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::PumpBlocked::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::SensorFailure::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR
LogValue(const char * label, size_t indent,
         const chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicNonFatalFailure::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicFatalFailure::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::GeneralFault::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::Leakage::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::AirDetection::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PumpConfigurationAndControl::Events::TurbineOperation::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Arg1", indent + 1, value.arg1);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Arg1'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Arg2", indent + 1, value.arg2);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Arg2'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Arg3", indent + 1, value.arg3);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Arg3'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Arg4", indent + 1, value.arg4);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Arg4'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Arg5", indent + 1, value.arg5);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Arg5'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Arg6", indent + 1, value.arg6);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sEvent truncated due to invalid value for 'Arg6'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
#pragma GCC diagnostic pop
} // anonymous namespace

static void OnDefaultSuccessResponse(void * context)
{
    ChipLogProgress(chipTool, "Default Success Response");

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnDefaultFailure(void * context, EmberAfStatus status)
{
    ChipLogProgress(chipTool, "Default Failure Response: 0x%02x", chip::to_underlying(status));

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
}

static void OnDefaultSuccess(void * context, const chip::app::DataModel::NullObjectType & data)
{
    OnDefaultSuccessResponse(context);
};

template <typename T>
static void OnGeneralAttributeResponse(void * context, const char * label, T value)
{
    CHIP_ERROR err = LogValue(label, 0, value);

    auto * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnAccountLoginGetSetupPINResponseSuccess(
    void * context, const chip::app::Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetSetupPINResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("setupPIN", 1, data.setupPIN);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnApplicationLauncherLauncherResponseSuccess(
    void * context, const chip::app::Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received LauncherResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("data", 1, data.data);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnChannelChangeChannelResponseSuccess(void * context,
                                      const chip::app::Clusters::Channel::Commands::ChangeChannelResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ChangeChannelResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("channelMatch", 1, data.channelMatch);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorType", 1, data.errorType);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnContentLauncherLaunchResponseSuccess(void * context,
                                       const chip::app::Clusters::ContentLauncher::Commands::LaunchResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received LaunchResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("data", 1, data.data);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDiagnosticLogsRetrieveLogsResponseSuccess(
    void * context, const chip::app::Clusters::DiagnosticLogs::Commands::RetrieveLogsResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RetrieveLogsResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("content", 1, data.content);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("timeStamp", 1, data.timeStamp);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("timeSinceBoot", 1, data.timeSinceBoot);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockGetCredentialStatusResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetCredentialStatusResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("credentialExists", 1, data.credentialExists);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userIndex", 1, data.userIndex);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("nextCredentialIndex", 1, data.nextCredentialIndex);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockGetUserResponseSuccess(void * context,
                                             const chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetUserResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userIndex", 1, data.userIndex);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userName", 1, data.userName);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userUniqueId", 1, data.userUniqueId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userStatus", 1, data.userStatus);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userType", 1, data.userType);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("credentialRule", 1, data.credentialRule);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("credentials", 1, data.credentials);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("creatorFabricIndex", 1, data.creatorFabricIndex);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("lastModifiedFabricIndex", 1, data.lastModifiedFabricIndex);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("nextUserIndex", 1, data.nextUserIndex);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnDoorLockSetCredentialResponseSuccess(void * context,
                                       const chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetCredentialResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userIndex", 1, data.userIndex);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("nextCredentialIndex", 1, data.nextCredentialIndex);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGeneralCommissioningArmFailSafeResponseSuccess(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ArmFailSafeResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGeneralCommissioningCommissioningCompleteResponseSuccess(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received CommissioningCompleteResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGeneralCommissioningSetRegulatoryConfigResponseSuccess(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::SetRegulatoryConfigResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetRegulatoryConfigResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGroupKeyManagementKeySetReadAllIndicesResponseSuccess(
    void * context, const chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadAllIndicesResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received KeySetReadAllIndicesResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupKeySetIDs", 1, data.groupKeySetIDs);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGroupKeyManagementKeySetReadResponseSuccess(
    void * context, const chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received KeySetReadResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupKeySet", 1, data.groupKeySet);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGroupsAddGroupResponseSuccess(void * context,
                                            const chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received AddGroupResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGroupsGetGroupMembershipResponseSuccess(
    void * context, const chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetGroupMembershipResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("capacity", 1, data.capacity);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupList", 1, data.groupList);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnGroupsRemoveGroupResponseSuccess(void * context,
                                   const chip::app::Clusters::Groups::Commands::RemoveGroupResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RemoveGroupResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGroupsViewGroupResponseSuccess(void * context,
                                             const chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ViewGroupResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupName", 1, data.groupName);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnIdentifyIdentifyQueryResponseSuccess(void * context,
                                       const chip::app::Clusters::Identify::Commands::IdentifyQueryResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received IdentifyQueryResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("timeout", 1, data.timeout);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnKeypadInputSendKeyResponseSuccess(void * context,
                                    const chip::app::Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SendKeyResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnMediaPlaybackPlaybackResponseSuccess(void * context,
                                       const chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received PlaybackResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningConnectNetworkResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::ConnectNetworkResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ConnectNetworkResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("networkingStatus", 1, data.networkingStatus);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorValue", 1, data.errorValue);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningNetworkConfigResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received NetworkConfigResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("networkingStatus", 1, data.networkingStatus);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningScanNetworksResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::ScanNetworksResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ScanNetworksResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("networkingStatus", 1, data.networkingStatus);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("wiFiScanResults", 1, data.wiFiScanResults);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("threadScanResults", 1, data.threadScanResults);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOtaSoftwareUpdateProviderApplyUpdateResponseSuccess(
    void * context, const chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ApplyUpdateResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("action", 1, data.action);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("delayedActionTime", 1, data.delayedActionTime);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOtaSoftwareUpdateProviderQueryImageResponseSuccess(
    void * context, const chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::QueryImageResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received QueryImageResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("delayedActionTime", 1, data.delayedActionTime);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("imageURI", 1, data.imageURI);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("softwareVersion", 1, data.softwareVersion);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("softwareVersionString", 1, data.softwareVersionString);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("updateToken", 1, data.updateToken);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userConsentNeeded", 1, data.userConsentNeeded);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("metadataForRequestor", 1, data.metadataForRequestor);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOperationalCredentialsAttestationResponseSuccess(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::AttestationResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received AttestationResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("attestationElements", 1, data.attestationElements);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("signature", 1, data.signature);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOperationalCredentialsCertificateChainResponseSuccess(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::CertificateChainResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received CertificateChainResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("certificate", 1, data.certificate);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOperationalCredentialsNOCResponseSuccess(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received NOCResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("statusCode", 1, data.statusCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("fabricIndex", 1, data.fabricIndex);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOperationalCredentialsOpCSRResponseSuccess(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::OpCSRResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received OpCSRResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("NOCSRElements", 1, data.NOCSRElements);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("attestationSignature", 1, data.attestationSignature);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnScenesAddSceneResponseSuccess(void * context,
                                            const chip::app::Clusters::Scenes::Commands::AddSceneResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received AddSceneResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneId", 1, data.sceneId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnScenesGetSceneMembershipResponseSuccess(
    void * context, const chip::app::Clusters::Scenes::Commands::GetSceneMembershipResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetSceneMembershipResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("capacity", 1, data.capacity);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneCount", 1, data.sceneCount);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneList", 1, data.sceneList);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnScenesRemoveAllScenesResponseSuccess(void * context,
                                       const chip::app::Clusters::Scenes::Commands::RemoveAllScenesResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RemoveAllScenesResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnScenesRemoveSceneResponseSuccess(void * context,
                                   const chip::app::Clusters::Scenes::Commands::RemoveSceneResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RemoveSceneResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneId", 1, data.sceneId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnScenesStoreSceneResponseSuccess(void * context,
                                              const chip::app::Clusters::Scenes::Commands::StoreSceneResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received StoreSceneResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneId", 1, data.sceneId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnScenesViewSceneResponseSuccess(void * context,
                                             const chip::app::Clusters::Scenes::Commands::ViewSceneResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ViewSceneResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneId", 1, data.sceneId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("transitionTime", 1, data.transitionTime);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneName", 1, data.sceneName);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("extensionFieldSets", 1, data.extensionFieldSets);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTargetNavigatorNavigateTargetResponseSuccess(
    void * context, const chip::app::Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received NavigateTargetResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("data", 1, data.data);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnTestClusterBooleanResponseSuccess(void * context,
                                    const chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received BooleanResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("value", 1, data.value);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterSimpleStructResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::SimpleStructResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SimpleStructResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("arg1", 1, data.arg1);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestAddArgumentsResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestAddArgumentsResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("returnValue", 1, data.returnValue);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestEmitTestEventResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestEmitTestEventResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestEmitTestEventResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("value", 1, data.value);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnTestClusterTestEnumsResponseSuccess(void * context,
                                      const chip::app::Clusters::TestCluster::Commands::TestEnumsResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestEnumsResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("arg1", 1, data.arg1);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("arg2", 1, data.arg2);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestListInt8UReverseResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestListInt8UReverseResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("arg1", 1, data.arg1);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestNullableOptionalResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestNullableOptionalResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("wasPresent", 1, data.wasPresent);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("wasNull", 1, data.wasNull);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("value", 1, data.value);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("originalValue", 1, data.originalValue);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestSpecificResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestSpecificResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestSpecificResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("returnValue", 1, data.returnValue);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnThermostatGetRelayStatusLogResponseSuccess(
    void * context, const chip::app::Clusters::Thermostat::Commands::GetRelayStatusLogResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetRelayStatusLogResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("timeOfDay", 1, data.timeOfDay);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("relayStatus", 1, data.relayStatus);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("localTemperature", 1, data.localTemperature);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("humidityInPercentage", 1, data.humidityInPercentage);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("setpoint", 1, data.setpoint);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("unreadEntries", 1, data.unreadEntries);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnThermostatGetWeeklyScheduleResponseSuccess(
    void * context, const chip::app::Clusters::Thermostat::Commands::GetWeeklyScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetWeeklyScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("numberOfTransitionsForSequence", 1, data.numberOfTransitionsForSequence);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("dayOfWeekForSequence", 1, data.dayOfWeekForSequence);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("modeForSequence", 1, data.modeForSequence);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("payload", 1, data.payload);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

/*----------------------------------------------------------------------------*\
| Cluster Name                                                        |   ID   |
|---------------------------------------------------------------------+--------|
| AccessControl                                                       | 0x001F |
| AccountLogin                                                        | 0x050E |
| AdministratorCommissioning                                          | 0x003C |
| ApplicationBasic                                                    | 0x050D |
| ApplicationLauncher                                                 | 0x050C |
| AudioOutput                                                         | 0x050B |
| BarrierControl                                                      | 0x0103 |
| Basic                                                               | 0x0028 |
| BinaryInputBasic                                                    | 0x000F |
| Binding                                                             | 0x001E |
| BooleanState                                                        | 0x0045 |
| BridgedActions                                                      | 0x0025 |
| BridgedDeviceBasic                                                  | 0x0039 |
| Channel                                                             | 0x0504 |
| ColorControl                                                        | 0x0300 |
| ContentLauncher                                                     | 0x050A |
| Descriptor                                                          | 0x001D |
| DiagnosticLogs                                                      | 0x0032 |
| DoorLock                                                            | 0x0101 |
| ElectricalMeasurement                                               | 0x0B04 |
| EthernetNetworkDiagnostics                                          | 0x0037 |
| FixedLabel                                                          | 0x0040 |
| FlowMeasurement                                                     | 0x0404 |
| GeneralCommissioning                                                | 0x0030 |
| GeneralDiagnostics                                                  | 0x0033 |
| GroupKeyManagement                                                  | 0x003F |
| Groups                                                              | 0x0004 |
| Identify                                                            | 0x0003 |
| IlluminanceMeasurement                                              | 0x0400 |
| KeypadInput                                                         | 0x0509 |
| LevelControl                                                        | 0x0008 |
| LocalizationConfiguration                                           | 0x002B |
| LowPower                                                            | 0x0508 |
| MediaInput                                                          | 0x0507 |
| MediaPlayback                                                       | 0x0506 |
| ModeSelect                                                          | 0x0050 |
| NetworkCommissioning                                                | 0x0031 |
| OtaSoftwareUpdateProvider                                           | 0x0029 |
| OtaSoftwareUpdateRequestor                                          | 0x002A |
| OccupancySensing                                                    | 0x0406 |
| OnOff                                                               | 0x0006 |
| OnOffSwitchConfiguration                                            | 0x0007 |
| OperationalCredentials                                              | 0x003E |
| PowerSource                                                         | 0x002F |
| PowerSourceConfiguration                                            | 0x002E |
| PressureMeasurement                                                 | 0x0403 |
| PumpConfigurationAndControl                                         | 0x0200 |
| RelativeHumidityMeasurement                                         | 0x0405 |
| Scenes                                                              | 0x0005 |
| SoftwareDiagnostics                                                 | 0x0034 |
| Switch                                                              | 0x003B |
| TargetNavigator                                                     | 0x0505 |
| TemperatureMeasurement                                              | 0x0402 |
| TestCluster                                                         | 0x050F |
| Thermostat                                                          | 0x0201 |
| ThermostatUserInterfaceConfiguration                                | 0x0204 |
| ThreadNetworkDiagnostics                                            | 0x0035 |
| UserLabel                                                           | 0x0041 |
| WakeOnLan                                                           | 0x0503 |
| WiFiNetworkDiagnostics                                              | 0x0036 |
| WindowCovering                                                      | 0x0102 |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
| Cluster AccessControl                                               | 0x001F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Acl                                                               | 0x0000 |
| * Extension                                                         | 0x0001 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventAccessControlWildcard : public ModelCommand
{
public:
    ReadEventAccessControlWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventAccessControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000001F, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventAccessControlWildcard : public ModelCommand
{
public:
    ReportEventAccessControlWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventAccessControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000001F, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadAccessControlWildcard : public ModelCommand
{
public:
    ReadAccessControlWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001F, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportAccessControlWildcard : public ModelCommand
{
public:
    ReportAccessControlWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001F, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Acl
 */
class ReadAccessControlAcl : public ModelCommand
{
public:
    ReadAccessControlAcl() : ModelCommand("read")
    {
        AddArgument("attr-name", "acl");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAcl() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001F, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccessControl.Acl report", 0, value);
    }
};

class ReportAccessControlAcl : public ModelCommand
{
public:
    ReportAccessControlAcl() : ModelCommand("report")
    {
        AddArgument("attr-name", "acl");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlAcl() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001F, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccessControl.Acl report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Extension
 */
class ReadAccessControlExtension : public ModelCommand
{
public:
    ReadAccessControlExtension() : ModelCommand("read")
    {
        AddArgument("attr-name", "extension");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlExtension() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001F, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccessControl.Extension report", 0, value);
    }
};

class ReportAccessControlExtension : public ModelCommand
{
public:
    ReportAccessControlExtension() : ModelCommand("report")
    {
        AddArgument("attr-name", "extension");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlExtension() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001F, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccessControl.Extension report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAccessControlAttributeList : public ModelCommand
{
public:
    ReadAccessControlAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001F, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccessControl.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadAccessControlClusterRevision : public ModelCommand
{
public:
    ReadAccessControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001F, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccessControl.ClusterRevision report", 0, value);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster AccountLogin                                                | 0x050E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GetSetupPINRequest                                                |   0x00 |
| * LoginRequest                                                      |   0x02 |
| * LogoutRequest                                                     |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command GetSetupPINRequest
 */
class AccountLoginGetSetupPINRequest : public ModelCommand
{
public:
    AccountLoginGetSetupPINRequest() : ModelCommand("get-setup-pinrequest")
    {
        AddArgument("TempAccountIdentifier", &mRequest.tempAccountIdentifier);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnAccountLoginGetSetupPINResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::AccountLogin::Commands::GetSetupPINRequest::Type mRequest;
};

/*
 * Command LoginRequest
 */
class AccountLoginLoginRequest : public ModelCommand
{
public:
    AccountLoginLoginRequest() : ModelCommand("login-request")
    {
        AddArgument("TempAccountIdentifier", &mRequest.tempAccountIdentifier);
        AddArgument("SetupPIN", &mRequest.setupPIN);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::AccountLogin::Commands::LoginRequest::Type mRequest;
};

/*
 * Command LogoutRequest
 */
class AccountLoginLogoutRequest : public ModelCommand
{
public:
    AccountLoginLogoutRequest() : ModelCommand("logout-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::AccountLogin::Commands::LogoutRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventAccountLoginWildcard : public ModelCommand
{
public:
    ReadEventAccountLoginWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventAccountLoginWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000050E, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventAccountLoginWildcard : public ModelCommand
{
public:
    ReportEventAccountLoginWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventAccountLoginWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000050E, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadAccountLoginWildcard : public ModelCommand
{
public:
    ReadAccountLoginWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050E, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportAccountLoginWildcard : public ModelCommand
{
public:
    ReportAccountLoginWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccountLoginWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050E, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAccountLoginAttributeList : public ModelCommand
{
public:
    ReadAccountLoginAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050E, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccountLogin.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadAccountLoginClusterRevision : public ModelCommand
{
public:
    ReadAccountLoginClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050E, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccountLogin.ClusterRevision report", 0, value);
    }
};

class ReportAccountLoginClusterRevision : public ModelCommand
{
public:
    ReportAccountLoginClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccountLoginClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050E, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AccountLogin.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AdministratorCommissioning                                  | 0x003C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * OpenBasicCommissioningWindow                                      |   0x01 |
| * OpenCommissioningWindow                                           |   0x00 |
| * RevokeCommissioning                                               |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * WindowStatus                                                      | 0x0000 |
| * AdminFabricIndex                                                  | 0x0001 |
| * AdminVendorId                                                     | 0x0002 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command OpenBasicCommissioningWindow
 */
class AdministratorCommissioningOpenBasicCommissioningWindow : public ModelCommand
{
public:
    AdministratorCommissioningOpenBasicCommissioningWindow() : ModelCommand("open-basic-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mRequest.commissioningTimeout);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type mRequest;
};

/*
 * Command OpenCommissioningWindow
 */
class AdministratorCommissioningOpenCommissioningWindow : public ModelCommand
{
public:
    AdministratorCommissioningOpenCommissioningWindow() : ModelCommand("open-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mRequest.commissioningTimeout);
        AddArgument("PAKEVerifier", &mRequest.PAKEVerifier);
        AddArgument("Discriminator", 0, UINT16_MAX, &mRequest.discriminator);
        AddArgument("Iterations", 0, UINT32_MAX, &mRequest.iterations);
        AddArgument("Salt", &mRequest.salt);
        AddArgument("PasscodeID", 0, UINT16_MAX, &mRequest.passcodeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type mRequest;
};

/*
 * Command RevokeCommissioning
 */
class AdministratorCommissioningRevokeCommissioning : public ModelCommand
{
public:
    AdministratorCommissioningRevokeCommissioning() : ModelCommand("revoke-commissioning") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventAdministratorCommissioningWildcard : public ModelCommand
{
public:
    ReadEventAdministratorCommissioningWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventAdministratorCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003C, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventAdministratorCommissioningWildcard : public ModelCommand
{
public:
    ReportEventAdministratorCommissioningWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventAdministratorCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003C, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadAdministratorCommissioningWildcard : public ModelCommand
{
public:
    ReadAdministratorCommissioningWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003C, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportAdministratorCommissioningWildcard : public ModelCommand
{
public:
    ReportAdministratorCommissioningWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003C, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WindowStatus
 */
class ReadAdministratorCommissioningWindowStatus : public ModelCommand
{
public:
    ReadAdministratorCommissioningWindowStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "window-status");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningWindowStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003C, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AdministratorCommissioning.WindowStatus report", 0, value);
    }
};

/*
 * Attribute AdminFabricIndex
 */
class ReadAdministratorCommissioningAdminFabricIndex : public ModelCommand
{
public:
    ReadAdministratorCommissioningAdminFabricIndex() : ModelCommand("read")
    {
        AddArgument("attr-name", "admin-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAdminFabricIndex() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003C, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::FabricIndex value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AdministratorCommissioning.AdminFabricIndex report", 0, value);
    }
};

/*
 * Attribute AdminVendorId
 */
class ReadAdministratorCommissioningAdminVendorId : public ModelCommand
{
public:
    ReadAdministratorCommissioningAdminVendorId() : ModelCommand("read")
    {
        AddArgument("attr-name", "admin-vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAdminVendorId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003C, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AdministratorCommissioning.AdminVendorId report", 0, value);
    }
};

/*
 * Attribute AttributeList
 */
class ReadAdministratorCommissioningAttributeList : public ModelCommand
{
public:
    ReadAdministratorCommissioningAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003C, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AdministratorCommissioning.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadAdministratorCommissioningClusterRevision : public ModelCommand
{
public:
    ReadAdministratorCommissioningClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003C, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AdministratorCommissioning.ClusterRevision report", 0, value);
    }
};

class ReportAdministratorCommissioningClusterRevision : public ModelCommand
{
public:
    ReportAdministratorCommissioningClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003C, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AdministratorCommissioning.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationBasic                                            | 0x050D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * VendorName                                                        | 0x0000 |
| * VendorId                                                          | 0x0001 |
| * ApplicationName                                                   | 0x0002 |
| * ProductId                                                         | 0x0003 |
| * ApplicationApp                                                    | 0x0004 |
| * ApplicationStatus                                                 | 0x0005 |
| * ApplicationVersion                                                | 0x0006 |
| * AllowedVendorList                                                 | 0x0007 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventApplicationBasicWildcard : public ModelCommand
{
public:
    ReadEventApplicationBasicWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventApplicationBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000050D, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventApplicationBasicWildcard : public ModelCommand
{
public:
    ReportEventApplicationBasicWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventApplicationBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000050D, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadApplicationBasicWildcard : public ModelCommand
{
public:
    ReadApplicationBasicWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicWildcard : public ModelCommand
{
public:
    ReportApplicationBasicWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050D, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorName
 */
class ReadApplicationBasicVendorName : public ModelCommand
{
public:
    ReadApplicationBasicVendorName() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.VendorName report", 0, value);
    }
};

class ReportApplicationBasicVendorName : public ModelCommand
{
public:
    ReportApplicationBasicVendorName() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicVendorName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050D, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.VendorName report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorId
 */
class ReadApplicationBasicVendorId : public ModelCommand
{
public:
    ReadApplicationBasicVendorId() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.VendorId report", 0, value);
    }
};

class ReportApplicationBasicVendorId : public ModelCommand
{
public:
    ReportApplicationBasicVendorId() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicVendorId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050D, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.VendorId report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationName
 */
class ReadApplicationBasicApplicationName : public ModelCommand
{
public:
    ReadApplicationBasicApplicationName() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ApplicationName report", 0, value);
    }
};

class ReportApplicationBasicApplicationName : public ModelCommand
{
public:
    ReportApplicationBasicApplicationName() : ModelCommand("report")
    {
        AddArgument("attr-name", "application-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050D, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ApplicationName report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductId
 */
class ReadApplicationBasicProductId : public ModelCommand
{
public:
    ReadApplicationBasicProductId() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicProductId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ProductId report", 0, value);
    }
};

class ReportApplicationBasicProductId : public ModelCommand
{
public:
    ReportApplicationBasicProductId() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicProductId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050D, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ProductId report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationStatus
 */
class ReadApplicationBasicApplicationStatus : public ModelCommand
{
public:
    ReadApplicationBasicApplicationStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-status");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ApplicationStatus report", 0, value);
    }
};

class ReportApplicationBasicApplicationStatus : public ModelCommand
{
public:
    ReportApplicationBasicApplicationStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "application-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050D, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ApplicationStatus report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationVersion
 */
class ReadApplicationBasicApplicationVersion : public ModelCommand
{
public:
    ReadApplicationBasicApplicationVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-version");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ApplicationVersion report", 0, value);
    }
};

class ReportApplicationBasicApplicationVersion : public ModelCommand
{
public:
    ReportApplicationBasicApplicationVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "application-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050D, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ApplicationVersion report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AllowedVendorList
 */
class ReadApplicationBasicAllowedVendorList : public ModelCommand
{
public:
    ReadApplicationBasicAllowedVendorList() : ModelCommand("read")
    {
        AddArgument("attr-name", "allowed-vendor-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAllowedVendorList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::VendorId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.AllowedVendorList report", 0, value);
    }
};

/*
 * Attribute AttributeList
 */
class ReadApplicationBasicAttributeList : public ModelCommand
{
public:
    ReadApplicationBasicAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationBasicClusterRevision : public ModelCommand
{
public:
    ReadApplicationBasicClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050D, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ClusterRevision report", 0, value);
    }
};

class ReportApplicationBasicClusterRevision : public ModelCommand
{
public:
    ReportApplicationBasicClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050D, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationBasic.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationLauncher                                         | 0x050C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * HideAppRequest                                                    |   0x02 |
| * LaunchAppRequest                                                  |   0x00 |
| * StopAppRequest                                                    |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ApplicationLauncherList                                           | 0x0000 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command HideAppRequest
 */
class ApplicationLauncherHideAppRequest : public ModelCommand
{
public:
    ApplicationLauncherHideAppRequest() : ModelCommand("hide-app-request")
    {
        // application Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnApplicationLauncherLauncherResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ApplicationLauncher::Commands::HideAppRequest::Type mRequest;
};

/*
 * Command LaunchAppRequest
 */
class ApplicationLauncherLaunchAppRequest : public ModelCommand
{
public:
    ApplicationLauncherLaunchAppRequest() : ModelCommand("launch-app-request")
    {
        AddArgument("Data", &mRequest.data);
        // application Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnApplicationLauncherLauncherResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ApplicationLauncher::Commands::LaunchAppRequest::Type mRequest;
};

/*
 * Command StopAppRequest
 */
class ApplicationLauncherStopAppRequest : public ModelCommand
{
public:
    ApplicationLauncherStopAppRequest() : ModelCommand("stop-app-request")
    {
        // application Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnApplicationLauncherLauncherResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ApplicationLauncher::Commands::StopAppRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventApplicationLauncherWildcard : public ModelCommand
{
public:
    ReadEventApplicationLauncherWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventApplicationLauncherWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000050C, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventApplicationLauncherWildcard : public ModelCommand
{
public:
    ReportEventApplicationLauncherWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventApplicationLauncherWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000050C, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadApplicationLauncherWildcard : public ModelCommand
{
public:
    ReadApplicationLauncherWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050C, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationLauncherWildcard : public ModelCommand
{
public:
    ReportApplicationLauncherWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050C, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationLauncherList
 */
class ReadApplicationLauncherApplicationLauncherList : public ModelCommand
{
public:
    ReadApplicationLauncherApplicationLauncherList() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-launcher-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherApplicationLauncherList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050C, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationLauncher.ApplicationLauncherList report", 0, value);
    }
};

class ReportApplicationLauncherApplicationLauncherList : public ModelCommand
{
public:
    ReportApplicationLauncherApplicationLauncherList() : ModelCommand("report")
    {
        AddArgument("attr-name", "application-launcher-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherApplicationLauncherList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050C, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationLauncher.ApplicationLauncherList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadApplicationLauncherAttributeList : public ModelCommand
{
public:
    ReadApplicationLauncherAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050C, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationLauncher.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationLauncherClusterRevision : public ModelCommand
{
public:
    ReadApplicationLauncherClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050C, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationLauncher.ClusterRevision report", 0, value);
    }
};

class ReportApplicationLauncherClusterRevision : public ModelCommand
{
public:
    ReportApplicationLauncherClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050C, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ApplicationLauncher.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AudioOutput                                                 | 0x050B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * RenameOutputRequest                                               |   0x01 |
| * SelectOutputRequest                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AudioOutputList                                                   | 0x0000 |
| * CurrentAudioOutput                                                | 0x0001 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RenameOutputRequest
 */
class AudioOutputRenameOutputRequest : public ModelCommand
{
public:
    AudioOutputRenameOutputRequest() : ModelCommand("rename-output-request")
    {
        AddArgument("Index", 0, UINT8_MAX, &mRequest.index);
        AddArgument("Name", &mRequest.name);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::AudioOutput::Commands::RenameOutputRequest::Type mRequest;
};

/*
 * Command SelectOutputRequest
 */
class AudioOutputSelectOutputRequest : public ModelCommand
{
public:
    AudioOutputSelectOutputRequest() : ModelCommand("select-output-request")
    {
        AddArgument("Index", 0, UINT8_MAX, &mRequest.index);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::AudioOutput::Commands::SelectOutputRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventAudioOutputWildcard : public ModelCommand
{
public:
    ReadEventAudioOutputWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventAudioOutputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000050B, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventAudioOutputWildcard : public ModelCommand
{
public:
    ReportEventAudioOutputWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventAudioOutputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000050B, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadAudioOutputWildcard : public ModelCommand
{
public:
    ReadAudioOutputWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050B, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportAudioOutputWildcard : public ModelCommand
{
public:
    ReportAudioOutputWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050B, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AudioOutputList
 */
class ReadAudioOutputAudioOutputList : public ModelCommand
{
public:
    ReadAudioOutputAudioOutputList() : ModelCommand("read")
    {
        AddArgument("attr-name", "audio-output-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputAudioOutputList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050B, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AudioOutput.AudioOutputList report", 0, value);
    }
};

class ReportAudioOutputAudioOutputList : public ModelCommand
{
public:
    ReportAudioOutputAudioOutputList() : ModelCommand("report")
    {
        AddArgument("attr-name", "audio-output-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputAudioOutputList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050B, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AudioOutput.AudioOutputList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentAudioOutput
 */
class ReadAudioOutputCurrentAudioOutput : public ModelCommand
{
public:
    ReadAudioOutputCurrentAudioOutput() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-audio-output");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputCurrentAudioOutput() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050B, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AudioOutput.CurrentAudioOutput report", 0, value);
    }
};

class ReportAudioOutputCurrentAudioOutput : public ModelCommand
{
public:
    ReportAudioOutputCurrentAudioOutput() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-audio-output");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputCurrentAudioOutput() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050B, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AudioOutput.CurrentAudioOutput report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAudioOutputAttributeList : public ModelCommand
{
public:
    ReadAudioOutputAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050B, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AudioOutput.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadAudioOutputClusterRevision : public ModelCommand
{
public:
    ReadAudioOutputClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050B, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AudioOutput.ClusterRevision report", 0, value);
    }
};

class ReportAudioOutputClusterRevision : public ModelCommand
{
public:
    ReportAudioOutputClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050B, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("AudioOutput.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BarrierControl                                              | 0x0103 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * BarrierControlGoToPercent                                         |   0x00 |
| * BarrierControlStop                                                |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * BarrierMovingState                                                | 0x0001 |
| * BarrierSafetyStatus                                               | 0x0002 |
| * BarrierCapabilities                                               | 0x0003 |
| * BarrierPosition                                                   | 0x000A |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command BarrierControlGoToPercent
 */
class BarrierControlBarrierControlGoToPercent : public ModelCommand
{
public:
    BarrierControlBarrierControlGoToPercent() : ModelCommand("barrier-control-go-to-percent")
    {
        AddArgument("PercentOpen", 0, UINT8_MAX, &mRequest.percentOpen);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BarrierControl::Commands::BarrierControlGoToPercent::Type mRequest;
};

/*
 * Command BarrierControlStop
 */
class BarrierControlBarrierControlStop : public ModelCommand
{
public:
    BarrierControlBarrierControlStop() : ModelCommand("barrier-control-stop") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BarrierControl::Commands::BarrierControlStop::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventBarrierControlWildcard : public ModelCommand
{
public:
    ReadEventBarrierControlWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventBarrierControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000103, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventBarrierControlWildcard : public ModelCommand
{
public:
    ReportEventBarrierControlWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventBarrierControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000103, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadBarrierControlWildcard : public ModelCommand
{
public:
    ReadBarrierControlWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000103, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlWildcard : public ModelCommand
{
public:
    ReportBarrierControlWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000103, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierMovingState
 */
class ReadBarrierControlBarrierMovingState : public ModelCommand
{
public:
    ReadBarrierControlBarrierMovingState() : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-moving-state");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierMovingState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000103, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.BarrierMovingState report", 0, value);
    }
};

class ReportBarrierControlBarrierMovingState : public ModelCommand
{
public:
    ReportBarrierControlBarrierMovingState() : ModelCommand("report")
    {
        AddArgument("attr-name", "barrier-moving-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierMovingState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000103, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.BarrierMovingState report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierSafetyStatus
 */
class ReadBarrierControlBarrierSafetyStatus : public ModelCommand
{
public:
    ReadBarrierControlBarrierSafetyStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierSafetyStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000103, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.BarrierSafetyStatus report", 0, value);
    }
};

class ReportBarrierControlBarrierSafetyStatus : public ModelCommand
{
public:
    ReportBarrierControlBarrierSafetyStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "barrier-safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierSafetyStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000103, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.BarrierSafetyStatus report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierCapabilities
 */
class ReadBarrierControlBarrierCapabilities : public ModelCommand
{
public:
    ReadBarrierControlBarrierCapabilities() : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierCapabilities() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000103, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.BarrierCapabilities report", 0, value);
    }
};

class ReportBarrierControlBarrierCapabilities : public ModelCommand
{
public:
    ReportBarrierControlBarrierCapabilities() : ModelCommand("report")
    {
        AddArgument("attr-name", "barrier-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierCapabilities() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000103, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.BarrierCapabilities report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierPosition
 */
class ReadBarrierControlBarrierPosition : public ModelCommand
{
public:
    ReadBarrierControlBarrierPosition() : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-position");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierPosition() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000103, 0x0000000A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.BarrierPosition report", 0, value);
    }
};

class ReportBarrierControlBarrierPosition : public ModelCommand
{
public:
    ReportBarrierControlBarrierPosition() : ModelCommand("report")
    {
        AddArgument("attr-name", "barrier-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierPosition() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000103, 0x0000000A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.BarrierPosition report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBarrierControlAttributeList : public ModelCommand
{
public:
    ReadBarrierControlAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000103, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadBarrierControlClusterRevision : public ModelCommand
{
public:
    ReadBarrierControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000103, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.ClusterRevision report", 0, value);
    }
};

class ReportBarrierControlClusterRevision : public ModelCommand
{
public:
    ReportBarrierControlClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000103, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BarrierControl.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Basic                                                       | 0x0028 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MfgSpecificPing                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * InteractionModelVersion                                           | 0x0000 |
| * VendorName                                                        | 0x0001 |
| * VendorID                                                          | 0x0002 |
| * ProductName                                                       | 0x0003 |
| * ProductID                                                         | 0x0004 |
| * NodeLabel                                                         | 0x0005 |
| * Location                                                          | 0x0006 |
| * HardwareVersion                                                   | 0x0007 |
| * HardwareVersionString                                             | 0x0008 |
| * SoftwareVersion                                                   | 0x0009 |
| * SoftwareVersionString                                             | 0x000A |
| * ManufacturingDate                                                 | 0x000B |
| * PartNumber                                                        | 0x000C |
| * ProductURL                                                        | 0x000D |
| * ProductLabel                                                      | 0x000E |
| * SerialNumber                                                      | 0x000F |
| * LocalConfigDisabled                                               | 0x0010 |
| * Reachable                                                         | 0x0011 |
| * UniqueID                                                          | 0x0012 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StartUp                                                           | 0x0000 |
| * ShutDown                                                          | 0x0001 |
| * Leave                                                             | 0x0002 |
| * ReachableChanged                                                  | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Command MfgSpecificPing
 */
class BasicMfgSpecificPing : public ModelCommand
{
public:
    BasicMfgSpecificPing() : ModelCommand("mfg-specific-ping") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Basic::Commands::MfgSpecificPing::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventBasicWildcard : public ModelCommand
{
public:
    ReadEventBasicWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000028, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventBasicWildcard : public ModelCommand
{
public:
    ReportEventBasicWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000028, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event StartUp
 */
class ReadBasicStartUp : public ModelCommand
{
public:
    ReadBasicStartUp() : ModelCommand("read-event")
    {
        AddArgument("event-name", "start-up");
        ModelCommand::AddArguments();
    }

    ~ReadBasicStartUp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000028, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Basic::Events::StartUp::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.StartUp report", 0, value);
    }
};

class ReportBasicStartUp : public ModelCommand
{
public:
    ReportBasicStartUp() : ModelCommand("report-event")
    {
        AddArgument("event-name", "start-up");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicStartUp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000028, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Basic::Events::StartUp::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.StartUp report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ShutDown
 */
class ReadBasicShutDown : public ModelCommand
{
public:
    ReadBasicShutDown() : ModelCommand("read-event")
    {
        AddArgument("event-name", "shut-down");
        ModelCommand::AddArguments();
    }

    ~ReadBasicShutDown() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000028, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Basic::Events::ShutDown::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ShutDown report", 0, value);
    }
};

class ReportBasicShutDown : public ModelCommand
{
public:
    ReportBasicShutDown() : ModelCommand("report-event")
    {
        AddArgument("event-name", "shut-down");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicShutDown() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000028, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Basic::Events::ShutDown::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ShutDown report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event Leave
 */
class ReadBasicLeave : public ModelCommand
{
public:
    ReadBasicLeave() : ModelCommand("read-event")
    {
        AddArgument("event-name", "leave");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLeave() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000028, 0x00000002);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Basic::Events::Leave::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.Leave report", 0, value);
    }
};

class ReportBasicLeave : public ModelCommand
{
public:
    ReportBasicLeave() : ModelCommand("report-event")
    {
        AddArgument("event-name", "leave");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicLeave() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000028, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Basic::Events::Leave::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.Leave report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ReachableChanged
 */
class ReadBasicReachableChanged : public ModelCommand
{
public:
    ReadBasicReachableChanged() : ModelCommand("read-event")
    {
        AddArgument("event-name", "reachable-changed");
        ModelCommand::AddArguments();
    }

    ~ReadBasicReachableChanged() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000028, 0x00000003);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Basic::Events::ReachableChanged::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ReachableChanged report", 0, value);
    }
};

class ReportBasicReachableChanged : public ModelCommand
{
public:
    ReportBasicReachableChanged() : ModelCommand("report-event")
    {
        AddArgument("event-name", "reachable-changed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicReachableChanged() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000028, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Basic::Events::ReachableChanged::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ReachableChanged report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadBasicWildcard : public ModelCommand
{
public:
    ReadBasicWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportBasicWildcard : public ModelCommand
{
public:
    ReportBasicWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InteractionModelVersion
 */
class ReadBasicInteractionModelVersion : public ModelCommand
{
public:
    ReadBasicInteractionModelVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "interaction-model-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicInteractionModelVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.InteractionModelVersion report", 0, value);
    }
};

class ReportBasicInteractionModelVersion : public ModelCommand
{
public:
    ReportBasicInteractionModelVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "interaction-model-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicInteractionModelVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.InteractionModelVersion report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorName
 */
class ReadBasicVendorName : public ModelCommand
{
public:
    ReadBasicVendorName() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.VendorName report", 0, value);
    }
};

class ReportBasicVendorName : public ModelCommand
{
public:
    ReportBasicVendorName() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicVendorName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.VendorName report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadBasicVendorID : public ModelCommand
{
public:
    ReadBasicVendorID() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorID() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::VendorId value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.VendorID report", 0, value);
    }
};

class ReportBasicVendorID : public ModelCommand
{
public:
    ReportBasicVendorID() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicVendorID() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::VendorId value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.VendorID report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductName
 */
class ReadBasicProductName : public ModelCommand
{
public:
    ReadBasicProductName() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ProductName report", 0, value);
    }
};

class ReportBasicProductName : public ModelCommand
{
public:
    ReportBasicProductName() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ProductName report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductID
 */
class ReadBasicProductID : public ModelCommand
{
public:
    ReadBasicProductID() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductID() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ProductID report", 0, value);
    }
};

class ReportBasicProductID : public ModelCommand
{
public:
    ReportBasicProductID() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductID() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ProductID report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NodeLabel
 */
class ReadBasicNodeLabel : public ModelCommand
{
public:
    ReadBasicNodeLabel() : ModelCommand("read")
    {
        AddArgument("attr-name", "node-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicNodeLabel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.NodeLabel report", 0, value);
    }
};

class WriteBasicNodeLabel : public ModelCommand
{
public:
    WriteBasicNodeLabel() : ModelCommand("write")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicNodeLabel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000028, 0x00000005, mValue);
    }

private:
    chip::CharSpan mValue;
};

class ReportBasicNodeLabel : public ModelCommand
{
public:
    ReportBasicNodeLabel() : ModelCommand("report")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicNodeLabel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.NodeLabel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Location
 */
class ReadBasicLocation : public ModelCommand
{
public:
    ReadBasicLocation() : ModelCommand("read")
    {
        AddArgument("attr-name", "location");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.Location report", 0, value);
    }
};

class WriteBasicLocation : public ModelCommand
{
public:
    WriteBasicLocation() : ModelCommand("write")
    {
        AddArgument("attr-name", "location");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000028, 0x00000006, mValue);
    }

private:
    chip::CharSpan mValue;
};

class ReportBasicLocation : public ModelCommand
{
public:
    ReportBasicLocation() : ModelCommand("report")
    {
        AddArgument("attr-name", "location");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicLocation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.Location report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersion
 */
class ReadBasicHardwareVersion : public ModelCommand
{
public:
    ReadBasicHardwareVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.HardwareVersion report", 0, value);
    }
};

class ReportBasicHardwareVersion : public ModelCommand
{
public:
    ReportBasicHardwareVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "hardware-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.HardwareVersion report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersionString
 */
class ReadBasicHardwareVersionString : public ModelCommand
{
public:
    ReadBasicHardwareVersionString() : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.HardwareVersionString report", 0, value);
    }
};

class ReportBasicHardwareVersionString : public ModelCommand
{
public:
    ReportBasicHardwareVersionString() : ModelCommand("report")
    {
        AddArgument("attr-name", "hardware-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.HardwareVersionString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersion
 */
class ReadBasicSoftwareVersion : public ModelCommand
{
public:
    ReadBasicSoftwareVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000009);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.SoftwareVersion report", 0, value);
    }
};

class ReportBasicSoftwareVersion : public ModelCommand
{
public:
    ReportBasicSoftwareVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "software-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000009, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.SoftwareVersion report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersionString
 */
class ReadBasicSoftwareVersionString : public ModelCommand
{
public:
    ReadBasicSoftwareVersionString() : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x0000000A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.SoftwareVersionString report", 0, value);
    }
};

class ReportBasicSoftwareVersionString : public ModelCommand
{
public:
    ReportBasicSoftwareVersionString() : ModelCommand("report")
    {
        AddArgument("attr-name", "software-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x0000000A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.SoftwareVersionString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ManufacturingDate
 */
class ReadBasicManufacturingDate : public ModelCommand
{
public:
    ReadBasicManufacturingDate() : ModelCommand("read")
    {
        AddArgument("attr-name", "manufacturing-date");
        ModelCommand::AddArguments();
    }

    ~ReadBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x0000000B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ManufacturingDate report", 0, value);
    }
};

class ReportBasicManufacturingDate : public ModelCommand
{
public:
    ReportBasicManufacturingDate() : ModelCommand("report")
    {
        AddArgument("attr-name", "manufacturing-date");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x0000000B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ManufacturingDate report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartNumber
 */
class ReadBasicPartNumber : public ModelCommand
{
public:
    ReadBasicPartNumber() : ModelCommand("read")
    {
        AddArgument("attr-name", "part-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicPartNumber() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x0000000C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.PartNumber report", 0, value);
    }
};

class ReportBasicPartNumber : public ModelCommand
{
public:
    ReportBasicPartNumber() : ModelCommand("report")
    {
        AddArgument("attr-name", "part-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicPartNumber() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x0000000C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.PartNumber report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductURL
 */
class ReadBasicProductURL : public ModelCommand
{
public:
    ReadBasicProductURL() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-url");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductURL() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x0000000D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ProductURL report", 0, value);
    }
};

class ReportBasicProductURL : public ModelCommand
{
public:
    ReportBasicProductURL() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductURL() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x0000000D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ProductURL report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductLabel
 */
class ReadBasicProductLabel : public ModelCommand
{
public:
    ReadBasicProductLabel() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductLabel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x0000000E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ProductLabel report", 0, value);
    }
};

class ReportBasicProductLabel : public ModelCommand
{
public:
    ReportBasicProductLabel() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductLabel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x0000000E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ProductLabel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SerialNumber
 */
class ReadBasicSerialNumber : public ModelCommand
{
public:
    ReadBasicSerialNumber() : ModelCommand("read")
    {
        AddArgument("attr-name", "serial-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSerialNumber() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x0000000F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.SerialNumber report", 0, value);
    }
};

class ReportBasicSerialNumber : public ModelCommand
{
public:
    ReportBasicSerialNumber() : ModelCommand("report")
    {
        AddArgument("attr-name", "serial-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSerialNumber() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x0000000F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.SerialNumber report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocalConfigDisabled
 */
class ReadBasicLocalConfigDisabled : public ModelCommand
{
public:
    ReadBasicLocalConfigDisabled() : ModelCommand("read")
    {
        AddArgument("attr-name", "local-config-disabled");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.LocalConfigDisabled report", 0, value);
    }
};

class WriteBasicLocalConfigDisabled : public ModelCommand
{
public:
    WriteBasicLocalConfigDisabled() : ModelCommand("write")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000028, 0x00000010, mValue);
    }

private:
    bool mValue;
};

class ReportBasicLocalConfigDisabled : public ModelCommand
{
public:
    ReportBasicLocalConfigDisabled() : ModelCommand("report")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.LocalConfigDisabled report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Reachable
 */
class ReadBasicReachable : public ModelCommand
{
public:
    ReadBasicReachable() : ModelCommand("read")
    {
        AddArgument("attr-name", "reachable");
        ModelCommand::AddArguments();
    }

    ~ReadBasicReachable() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.Reachable report", 0, value);
    }
};

class ReportBasicReachable : public ModelCommand
{
public:
    ReportBasicReachable() : ModelCommand("report")
    {
        AddArgument("attr-name", "reachable");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicReachable() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x00000011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.Reachable report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UniqueID
 */
class ReadBasicUniqueID : public ModelCommand
{
public:
    ReadBasicUniqueID() : ModelCommand("read")
    {
        AddArgument("attr-name", "unique-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicUniqueID() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.UniqueID report", 0, value);
    }
};

/*
 * Attribute AttributeList
 */
class ReadBasicAttributeList : public ModelCommand
{
public:
    ReadBasicAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadBasicClusterRevision : public ModelCommand
{
public:
    ReadBasicClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBasicClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000028, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ClusterRevision report", 0, value);
    }
};

class ReportBasicClusterRevision : public ModelCommand
{
public:
    ReportBasicClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000028, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Basic.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BinaryInputBasic                                            | 0x000F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OutOfService                                                      | 0x0051 |
| * PresentValue                                                      | 0x0055 |
| * StatusFlags                                                       | 0x006F |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventBinaryInputBasicWildcard : public ModelCommand
{
public:
    ReadEventBinaryInputBasicWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventBinaryInputBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000000F, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventBinaryInputBasicWildcard : public ModelCommand
{
public:
    ReportEventBinaryInputBasicWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventBinaryInputBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000000F, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadBinaryInputBasicWildcard : public ModelCommand
{
public:
    ReadBinaryInputBasicWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000000F, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportBinaryInputBasicWildcard : public ModelCommand
{
public:
    ReportBinaryInputBasicWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000000F, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OutOfService
 */
class ReadBinaryInputBasicOutOfService : public ModelCommand
{
public:
    ReadBinaryInputBasicOutOfService() : ModelCommand("read")
    {
        AddArgument("attr-name", "out-of-service");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000000F, 0x00000051);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.OutOfService report", 0, value);
    }
};

class WriteBinaryInputBasicOutOfService : public ModelCommand
{
public:
    WriteBinaryInputBasicOutOfService() : ModelCommand("write")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000000F, 0x00000051, mValue);
    }

private:
    bool mValue;
};

class ReportBinaryInputBasicOutOfService : public ModelCommand
{
public:
    ReportBinaryInputBasicOutOfService() : ModelCommand("report")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000000F, 0x00000051, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.OutOfService report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PresentValue
 */
class ReadBinaryInputBasicPresentValue : public ModelCommand
{
public:
    ReadBinaryInputBasicPresentValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "present-value");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000000F, 0x00000055);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.PresentValue report", 0, value);
    }
};

class WriteBinaryInputBasicPresentValue : public ModelCommand
{
public:
    WriteBinaryInputBasicPresentValue() : ModelCommand("write")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000000F, 0x00000055, mValue);
    }

private:
    bool mValue;
};

class ReportBinaryInputBasicPresentValue : public ModelCommand
{
public:
    ReportBinaryInputBasicPresentValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000000F, 0x00000055, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.PresentValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StatusFlags
 */
class ReadBinaryInputBasicStatusFlags : public ModelCommand
{
public:
    ReadBinaryInputBasicStatusFlags() : ModelCommand("read")
    {
        AddArgument("attr-name", "status-flags");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicStatusFlags() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000000F, 0x0000006F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.StatusFlags report", 0, value);
    }
};

class ReportBinaryInputBasicStatusFlags : public ModelCommand
{
public:
    ReportBinaryInputBasicStatusFlags() : ModelCommand("report")
    {
        AddArgument("attr-name", "status-flags");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicStatusFlags() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000000F, 0x0000006F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.StatusFlags report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBinaryInputBasicAttributeList : public ModelCommand
{
public:
    ReadBinaryInputBasicAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000000F, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadBinaryInputBasicClusterRevision : public ModelCommand
{
public:
    ReadBinaryInputBasicClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000000F, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.ClusterRevision report", 0, value);
    }
};

class ReportBinaryInputBasicClusterRevision : public ModelCommand
{
public:
    ReportBinaryInputBasicClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000000F, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BinaryInputBasic.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Binding                                                     | 0x001E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Bind                                                              |   0x00 |
| * Unbind                                                            |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Bind
 */
class BindingBind : public ModelCommand
{
public:
    BindingBind() : ModelCommand("bind")
    {
        AddArgument("NodeId", 0, UINT64_MAX, &mRequest.nodeId);
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("EndpointId", 0, UINT16_MAX, &mRequest.endpointId);
        AddArgument("ClusterId", 0, UINT32_MAX, &mRequest.clusterId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Binding::Commands::Bind::Type mRequest;
};

/*
 * Command Unbind
 */
class BindingUnbind : public ModelCommand
{
public:
    BindingUnbind() : ModelCommand("unbind")
    {
        AddArgument("NodeId", 0, UINT64_MAX, &mRequest.nodeId);
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("EndpointId", 0, UINT16_MAX, &mRequest.endpointId);
        AddArgument("ClusterId", 0, UINT32_MAX, &mRequest.clusterId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Binding::Commands::Unbind::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventBindingWildcard : public ModelCommand
{
public:
    ReadEventBindingWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventBindingWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000001E, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventBindingWildcard : public ModelCommand
{
public:
    ReportEventBindingWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventBindingWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000001E, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadBindingWildcard : public ModelCommand
{
public:
    ReadBindingWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadBindingWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001E, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportBindingWildcard : public ModelCommand
{
public:
    ReportBindingWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBindingWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001E, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBindingAttributeList : public ModelCommand
{
public:
    ReadBindingAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001E, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Binding.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadBindingClusterRevision : public ModelCommand
{
public:
    ReadBindingClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBindingClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001E, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Binding.ClusterRevision report", 0, value);
    }
};

class ReportBindingClusterRevision : public ModelCommand
{
public:
    ReportBindingClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBindingClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001E, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Binding.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BooleanState                                                | 0x0045 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * StateValue                                                        | 0x0000 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateChange                                                       | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventBooleanStateWildcard : public ModelCommand
{
public:
    ReadEventBooleanStateWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventBooleanStateWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000045, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventBooleanStateWildcard : public ModelCommand
{
public:
    ReportEventBooleanStateWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventBooleanStateWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000045, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event StateChange
 */
class ReadBooleanStateStateChange : public ModelCommand
{
public:
    ReadBooleanStateStateChange() : ModelCommand("read-event")
    {
        AddArgument("event-name", "state-change");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateStateChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000045, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::BooleanState::Events::StateChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BooleanState.StateChange report", 0, value);
    }
};

class ReportBooleanStateStateChange : public ModelCommand
{
public:
    ReportBooleanStateStateChange() : ModelCommand("report-event")
    {
        AddArgument("event-name", "state-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateStateChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000045, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::BooleanState::Events::StateChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BooleanState.StateChange report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadBooleanStateWildcard : public ModelCommand
{
public:
    ReadBooleanStateWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000045, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportBooleanStateWildcard : public ModelCommand
{
public:
    ReportBooleanStateWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000045, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StateValue
 */
class ReadBooleanStateStateValue : public ModelCommand
{
public:
    ReadBooleanStateStateValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "state-value");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateStateValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000045, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BooleanState.StateValue report", 0, value);
    }
};

class ReportBooleanStateStateValue : public ModelCommand
{
public:
    ReportBooleanStateStateValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "state-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateStateValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000045, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BooleanState.StateValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBooleanStateAttributeList : public ModelCommand
{
public:
    ReadBooleanStateAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000045, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BooleanState.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadBooleanStateClusterRevision : public ModelCommand
{
public:
    ReadBooleanStateClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000045, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BooleanState.ClusterRevision report", 0, value);
    }
};

class ReportBooleanStateClusterRevision : public ModelCommand
{
public:
    ReportBooleanStateClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000045, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BooleanState.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedActions                                              | 0x0025 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * DisableAction                                                     |   0x0A |
| * DisableActionWithDuration                                         |   0x0B |
| * EnableAction                                                      |   0x08 |
| * EnableActionWithDuration                                          |   0x09 |
| * InstantAction                                                     |   0x00 |
| * InstantActionWithTransition                                       |   0x01 |
| * PauseAction                                                       |   0x05 |
| * PauseActionWithDuration                                           |   0x06 |
| * ResumeAction                                                      |   0x07 |
| * StartAction                                                       |   0x02 |
| * StartActionWithDuration                                           |   0x03 |
| * StopAction                                                        |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActionList                                                        | 0x0000 |
| * EndpointList                                                      | 0x0001 |
| * SetupUrl                                                          | 0x0002 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateChanged                                                      | 0x0000 |
| * ActionFailed                                                      | 0x0001 |
\*----------------------------------------------------------------------------*/

/*
 * Command DisableAction
 */
class BridgedActionsDisableAction : public ModelCommand
{
public:
    BridgedActionsDisableAction() : ModelCommand("disable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::DisableAction::Type mRequest;
};

/*
 * Command DisableActionWithDuration
 */
class BridgedActionsDisableActionWithDuration : public ModelCommand
{
public:
    BridgedActionsDisableActionWithDuration() : ModelCommand("disable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mRequest.duration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::DisableActionWithDuration::Type mRequest;
};

/*
 * Command EnableAction
 */
class BridgedActionsEnableAction : public ModelCommand
{
public:
    BridgedActionsEnableAction() : ModelCommand("enable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000008) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::EnableAction::Type mRequest;
};

/*
 * Command EnableActionWithDuration
 */
class BridgedActionsEnableActionWithDuration : public ModelCommand
{
public:
    BridgedActionsEnableActionWithDuration() : ModelCommand("enable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mRequest.duration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000009) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::EnableActionWithDuration::Type mRequest;
};

/*
 * Command InstantAction
 */
class BridgedActionsInstantAction : public ModelCommand
{
public:
    BridgedActionsInstantAction() : ModelCommand("instant-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::InstantAction::Type mRequest;
};

/*
 * Command InstantActionWithTransition
 */
class BridgedActionsInstantActionWithTransition : public ModelCommand
{
public:
    BridgedActionsInstantActionWithTransition() : ModelCommand("instant-action-with-transition")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::InstantActionWithTransition::Type mRequest;
};

/*
 * Command PauseAction
 */
class BridgedActionsPauseAction : public ModelCommand
{
public:
    BridgedActionsPauseAction() : ModelCommand("pause-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000005) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::PauseAction::Type mRequest;
};

/*
 * Command PauseActionWithDuration
 */
class BridgedActionsPauseActionWithDuration : public ModelCommand
{
public:
    BridgedActionsPauseActionWithDuration() : ModelCommand("pause-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mRequest.duration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000006) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::PauseActionWithDuration::Type mRequest;
};

/*
 * Command ResumeAction
 */
class BridgedActionsResumeAction : public ModelCommand
{
public:
    BridgedActionsResumeAction() : ModelCommand("resume-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000007) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::ResumeAction::Type mRequest;
};

/*
 * Command StartAction
 */
class BridgedActionsStartAction : public ModelCommand
{
public:
    BridgedActionsStartAction() : ModelCommand("start-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::StartAction::Type mRequest;
};

/*
 * Command StartActionWithDuration
 */
class BridgedActionsStartActionWithDuration : public ModelCommand
{
public:
    BridgedActionsStartActionWithDuration() : ModelCommand("start-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mRequest.duration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::StartActionWithDuration::Type mRequest;
};

/*
 * Command StopAction
 */
class BridgedActionsStopAction : public ModelCommand
{
public:
    BridgedActionsStopAction() : ModelCommand("stop-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::StopAction::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventBridgedActionsWildcard : public ModelCommand
{
public:
    ReadEventBridgedActionsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventBridgedActionsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000025, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventBridgedActionsWildcard : public ModelCommand
{
public:
    ReportEventBridgedActionsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventBridgedActionsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000025, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event StateChanged
 */
class ReadBridgedActionsStateChanged : public ModelCommand
{
public:
    ReadBridgedActionsStateChanged() : ModelCommand("read-event")
    {
        AddArgument("event-name", "state-changed");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsStateChanged() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000025, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::BridgedActions::Events::StateChanged::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.StateChanged report", 0, value);
    }
};

class ReportBridgedActionsStateChanged : public ModelCommand
{
public:
    ReportBridgedActionsStateChanged() : ModelCommand("report-event")
    {
        AddArgument("event-name", "state-changed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsStateChanged() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000025, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::BridgedActions::Events::StateChanged::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.StateChanged report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ActionFailed
 */
class ReadBridgedActionsActionFailed : public ModelCommand
{
public:
    ReadBridgedActionsActionFailed() : ModelCommand("read-event")
    {
        AddArgument("event-name", "action-failed");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsActionFailed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000025, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::BridgedActions::Events::ActionFailed::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.ActionFailed report", 0, value);
    }
};

class ReportBridgedActionsActionFailed : public ModelCommand
{
public:
    ReportBridgedActionsActionFailed() : ModelCommand("report-event")
    {
        AddArgument("event-name", "action-failed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsActionFailed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000025, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::BridgedActions::Events::ActionFailed::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.ActionFailed report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadBridgedActionsWildcard : public ModelCommand
{
public:
    ReadBridgedActionsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000025, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedActionsWildcard : public ModelCommand
{
public:
    ReportBridgedActionsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000025, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActionList
 */
class ReadBridgedActionsActionList : public ModelCommand
{
public:
    ReadBridgedActionsActionList() : ModelCommand("read")
    {
        AddArgument("attr-name", "action-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsActionList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000025, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.ActionList report", 0, value);
    }
};

class ReportBridgedActionsActionList : public ModelCommand
{
public:
    ReportBridgedActionsActionList() : ModelCommand("report")
    {
        AddArgument("attr-name", "action-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsActionList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000025, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.ActionList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndpointList
 */
class ReadBridgedActionsEndpointList : public ModelCommand
{
public:
    ReadBridgedActionsEndpointList() : ModelCommand("read")
    {
        AddArgument("attr-name", "endpoint-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsEndpointList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000025, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.EndpointList report", 0, value);
    }
};

class ReportBridgedActionsEndpointList : public ModelCommand
{
public:
    ReportBridgedActionsEndpointList() : ModelCommand("report")
    {
        AddArgument("attr-name", "endpoint-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsEndpointList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000025, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.EndpointList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SetupUrl
 */
class ReadBridgedActionsSetupUrl : public ModelCommand
{
public:
    ReadBridgedActionsSetupUrl() : ModelCommand("read")
    {
        AddArgument("attr-name", "setup-url");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsSetupUrl() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000025, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.SetupUrl report", 0, value);
    }
};

class ReportBridgedActionsSetupUrl : public ModelCommand
{
public:
    ReportBridgedActionsSetupUrl() : ModelCommand("report")
    {
        AddArgument("attr-name", "setup-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsSetupUrl() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000025, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.SetupUrl report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBridgedActionsAttributeList : public ModelCommand
{
public:
    ReadBridgedActionsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000025, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedActionsClusterRevision : public ModelCommand
{
public:
    ReadBridgedActionsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000025, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.ClusterRevision report", 0, value);
    }
};

class ReportBridgedActionsClusterRevision : public ModelCommand
{
public:
    ReportBridgedActionsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000025, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedActions.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedDeviceBasic                                          | 0x0039 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventBridgedDeviceBasicWildcard : public ModelCommand
{
public:
    ReadEventBridgedDeviceBasicWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventBridgedDeviceBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000039, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventBridgedDeviceBasicWildcard : public ModelCommand
{
public:
    ReportEventBridgedDeviceBasicWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventBridgedDeviceBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000039, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadBridgedDeviceBasicWildcard : public ModelCommand
{
public:
    ReadBridgedDeviceBasicWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000039, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicWildcard : public ModelCommand
{
public:
    ReportBridgedDeviceBasicWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000039, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBridgedDeviceBasicAttributeList : public ModelCommand
{
public:
    ReadBridgedDeviceBasicAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000039, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedDeviceBasic.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedDeviceBasicClusterRevision : public ModelCommand
{
public:
    ReadBridgedDeviceBasicClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000039, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedDeviceBasic.ClusterRevision report", 0, value);
    }
};

class ReportBridgedDeviceBasicClusterRevision : public ModelCommand
{
public:
    ReportBridgedDeviceBasicClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000039, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("BridgedDeviceBasic.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Channel                                                     | 0x0504 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeChannelByNumberRequest                                      |   0x02 |
| * ChangeChannelRequest                                              |   0x00 |
| * SkipChannelRequest                                                |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ChannelList                                                       | 0x0000 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeChannelByNumberRequest
 */
class ChannelChangeChannelByNumberRequest : public ModelCommand
{
public:
    ChannelChangeChannelByNumberRequest() : ModelCommand("change-channel-by-number-request")
    {
        AddArgument("MajorNumber", 0, UINT16_MAX, &mRequest.majorNumber);
        AddArgument("MinorNumber", 0, UINT16_MAX, &mRequest.minorNumber);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Channel::Commands::ChangeChannelByNumberRequest::Type mRequest;
};

/*
 * Command ChangeChannelRequest
 */
class ChannelChangeChannelRequest : public ModelCommand
{
public:
    ChannelChangeChannelRequest() : ModelCommand("change-channel-request")
    {
        AddArgument("Match", &mRequest.match);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnChannelChangeChannelResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Channel::Commands::ChangeChannelRequest::Type mRequest;
};

/*
 * Command SkipChannelRequest
 */
class ChannelSkipChannelRequest : public ModelCommand
{
public:
    ChannelSkipChannelRequest() : ModelCommand("skip-channel-request")
    {
        AddArgument("Count", 0, UINT16_MAX, &mRequest.count);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Channel::Commands::SkipChannelRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventChannelWildcard : public ModelCommand
{
public:
    ReadEventChannelWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventChannelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000504, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventChannelWildcard : public ModelCommand
{
public:
    ReportEventChannelWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventChannelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000504, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadChannelWildcard : public ModelCommand
{
public:
    ReadChannelWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadChannelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000504, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportChannelWildcard : public ModelCommand
{
public:
    ReportChannelWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportChannelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000504, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelList
 */
class ReadChannelChannelList : public ModelCommand
{
public:
    ReadChannelChannelList() : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelChannelList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000504, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Channel.ChannelList report", 0, value);
    }
};

class ReportChannelChannelList : public ModelCommand
{
public:
    ReportChannelChannelList() : ModelCommand("report")
    {
        AddArgument("attr-name", "channel-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportChannelChannelList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000504, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Channel.ChannelList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadChannelAttributeList : public ModelCommand
{
public:
    ReadChannelAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000504, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Channel.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadChannelClusterRevision : public ModelCommand
{
public:
    ReadChannelClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadChannelClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000504, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Channel.ClusterRevision report", 0, value);
    }
};

class ReportChannelClusterRevision : public ModelCommand
{
public:
    ReportChannelClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportChannelClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000504, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Channel.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ColorControl                                                | 0x0300 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ColorLoopSet                                                      |   0x44 |
| * EnhancedMoveHue                                                   |   0x41 |
| * EnhancedMoveToHue                                                 |   0x40 |
| * EnhancedMoveToHueAndSaturation                                    |   0x43 |
| * EnhancedStepHue                                                   |   0x42 |
| * MoveColor                                                         |   0x08 |
| * MoveColorTemperature                                              |   0x4B |
| * MoveHue                                                           |   0x01 |
| * MoveSaturation                                                    |   0x04 |
| * MoveToColor                                                       |   0x07 |
| * MoveToColorTemperature                                            |   0x0A |
| * MoveToHue                                                         |   0x00 |
| * MoveToHueAndSaturation                                            |   0x06 |
| * MoveToSaturation                                                  |   0x03 |
| * StepColor                                                         |   0x09 |
| * StepColorTemperature                                              |   0x4C |
| * StepHue                                                           |   0x02 |
| * StepSaturation                                                    |   0x05 |
| * StopMoveStep                                                      |   0x47 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentHue                                                        | 0x0000 |
| * CurrentSaturation                                                 | 0x0001 |
| * RemainingTime                                                     | 0x0002 |
| * CurrentX                                                          | 0x0003 |
| * CurrentY                                                          | 0x0004 |
| * DriftCompensation                                                 | 0x0005 |
| * CompensationText                                                  | 0x0006 |
| * ColorTemperature                                                  | 0x0007 |
| * ColorMode                                                         | 0x0008 |
| * ColorControlOptions                                               | 0x000F |
| * NumberOfPrimaries                                                 | 0x0010 |
| * Primary1X                                                         | 0x0011 |
| * Primary1Y                                                         | 0x0012 |
| * Primary1Intensity                                                 | 0x0013 |
| * Primary2X                                                         | 0x0015 |
| * Primary2Y                                                         | 0x0016 |
| * Primary2Intensity                                                 | 0x0017 |
| * Primary3X                                                         | 0x0019 |
| * Primary3Y                                                         | 0x001A |
| * Primary3Intensity                                                 | 0x001B |
| * Primary4X                                                         | 0x0020 |
| * Primary4Y                                                         | 0x0021 |
| * Primary4Intensity                                                 | 0x0022 |
| * Primary5X                                                         | 0x0024 |
| * Primary5Y                                                         | 0x0025 |
| * Primary5Intensity                                                 | 0x0026 |
| * Primary6X                                                         | 0x0028 |
| * Primary6Y                                                         | 0x0029 |
| * Primary6Intensity                                                 | 0x002A |
| * WhitePointX                                                       | 0x0030 |
| * WhitePointY                                                       | 0x0031 |
| * ColorPointRX                                                      | 0x0032 |
| * ColorPointRY                                                      | 0x0033 |
| * ColorPointRIntensity                                              | 0x0034 |
| * ColorPointGX                                                      | 0x0036 |
| * ColorPointGY                                                      | 0x0037 |
| * ColorPointGIntensity                                              | 0x0038 |
| * ColorPointBX                                                      | 0x003A |
| * ColorPointBY                                                      | 0x003B |
| * ColorPointBIntensity                                              | 0x003C |
| * EnhancedCurrentHue                                                | 0x4000 |
| * EnhancedColorMode                                                 | 0x4001 |
| * ColorLoopActive                                                   | 0x4002 |
| * ColorLoopDirection                                                | 0x4003 |
| * ColorLoopTime                                                     | 0x4004 |
| * ColorLoopStartEnhancedHue                                         | 0x4005 |
| * ColorLoopStoredEnhancedHue                                        | 0x4006 |
| * ColorCapabilities                                                 | 0x400A |
| * ColorTempPhysicalMin                                              | 0x400B |
| * ColorTempPhysicalMax                                              | 0x400C |
| * CoupleColorTempToLevelMinMireds                                   | 0x400D |
| * StartUpColorTemperatureMireds                                     | 0x4010 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ColorLoopSet
 */
class ColorControlColorLoopSet : public ModelCommand
{
public:
    ColorControlColorLoopSet() : ModelCommand("color-loop-set")
    {
        AddArgument("UpdateFlags", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags> *>(
                        &mRequest.updateFlags));
        AddArgument("Action", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.action)> *>(&mRequest.action));
        AddArgument("Direction", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.direction)> *>(&mRequest.direction));
        AddArgument("Time", 0, UINT16_MAX, &mRequest.time);
        AddArgument("StartHue", 0, UINT16_MAX, &mRequest.startHue);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000044) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type mRequest;
};

/*
 * Command EnhancedMoveHue
 */
class ColorControlEnhancedMoveHue : public ModelCommand
{
public:
    ColorControlEnhancedMoveHue() : ModelCommand("enhanced-move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT16_MAX, &mRequest.rate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000041) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type mRequest;
};

/*
 * Command EnhancedMoveToHue
 */
class ColorControlEnhancedMoveToHue : public ModelCommand
{
public:
    ColorControlEnhancedMoveToHue() : ModelCommand("enhanced-move-to-hue")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mRequest.enhancedHue);
        AddArgument("Direction", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.direction)> *>(&mRequest.direction));
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000040) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type mRequest;
};

/*
 * Command EnhancedMoveToHueAndSaturation
 */
class ColorControlEnhancedMoveToHueAndSaturation : public ModelCommand
{
public:
    ColorControlEnhancedMoveToHueAndSaturation() : ModelCommand("enhanced-move-to-hue-and-saturation")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mRequest.enhancedHue);
        AddArgument("Saturation", 0, UINT8_MAX, &mRequest.saturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000043) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type mRequest;
};

/*
 * Command EnhancedStepHue
 */
class ColorControlEnhancedStepHue : public ModelCommand
{
public:
    ColorControlEnhancedStepHue() : ModelCommand("enhanced-step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT16_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000042) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type mRequest;
};

/*
 * Command MoveColor
 */
class ColorControlMoveColor : public ModelCommand
{
public:
    ColorControlMoveColor() : ModelCommand("move-color")
    {
        AddArgument("RateX", INT16_MIN, INT16_MAX, &mRequest.rateX);
        AddArgument("RateY", INT16_MIN, INT16_MAX, &mRequest.rateY);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000008) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveColor::Type mRequest;
};

/*
 * Command MoveColorTemperature
 */
class ColorControlMoveColorTemperature : public ModelCommand
{
public:
    ColorControlMoveColorTemperature() : ModelCommand("move-color-temperature")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT16_MAX, &mRequest.rate);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mRequest.colorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mRequest.colorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004B) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type mRequest;
};

/*
 * Command MoveHue
 */
class ColorControlMoveHue : public ModelCommand
{
public:
    ColorControlMoveHue() : ModelCommand("move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT8_MAX, &mRequest.rate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveHue::Type mRequest;
};

/*
 * Command MoveSaturation
 */
class ColorControlMoveSaturation : public ModelCommand
{
public:
    ColorControlMoveSaturation() : ModelCommand("move-saturation")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT8_MAX, &mRequest.rate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type mRequest;
};

/*
 * Command MoveToColor
 */
class ColorControlMoveToColor : public ModelCommand
{
public:
    ColorControlMoveToColor() : ModelCommand("move-to-color")
    {
        AddArgument("ColorX", 0, UINT16_MAX, &mRequest.colorX);
        AddArgument("ColorY", 0, UINT16_MAX, &mRequest.colorY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000007) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToColor::Type mRequest;
};

/*
 * Command MoveToColorTemperature
 */
class ColorControlMoveToColorTemperature : public ModelCommand
{
public:
    ColorControlMoveToColorTemperature() : ModelCommand("move-to-color-temperature")
    {
        AddArgument("ColorTemperature", 0, UINT16_MAX, &mRequest.colorTemperature);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type mRequest;
};

/*
 * Command MoveToHue
 */
class ColorControlMoveToHue : public ModelCommand
{
public:
    ColorControlMoveToHue() : ModelCommand("move-to-hue")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mRequest.hue);
        AddArgument("Direction", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.direction)> *>(&mRequest.direction));
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToHue::Type mRequest;
};

/*
 * Command MoveToHueAndSaturation
 */
class ColorControlMoveToHueAndSaturation : public ModelCommand
{
public:
    ColorControlMoveToHueAndSaturation() : ModelCommand("move-to-hue-and-saturation")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mRequest.hue);
        AddArgument("Saturation", 0, UINT8_MAX, &mRequest.saturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000006) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type mRequest;
};

/*
 * Command MoveToSaturation
 */
class ColorControlMoveToSaturation : public ModelCommand
{
public:
    ColorControlMoveToSaturation() : ModelCommand("move-to-saturation")
    {
        AddArgument("Saturation", 0, UINT8_MAX, &mRequest.saturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type mRequest;
};

/*
 * Command StepColor
 */
class ColorControlStepColor : public ModelCommand
{
public:
    ColorControlStepColor() : ModelCommand("step-color")
    {
        AddArgument("StepX", INT16_MIN, INT16_MAX, &mRequest.stepX);
        AddArgument("StepY", INT16_MIN, INT16_MAX, &mRequest.stepY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000009) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StepColor::Type mRequest;
};

/*
 * Command StepColorTemperature
 */
class ColorControlStepColorTemperature : public ModelCommand
{
public:
    ColorControlStepColorTemperature() : ModelCommand("step-color-temperature")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT16_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mRequest.colorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mRequest.colorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004C) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type mRequest;
};

/*
 * Command StepHue
 */
class ColorControlStepHue : public ModelCommand
{
public:
    ColorControlStepHue() : ModelCommand("step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT8_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StepHue::Type mRequest;
};

/*
 * Command StepSaturation
 */
class ColorControlStepSaturation : public ModelCommand
{
public:
    ColorControlStepSaturation() : ModelCommand("step-saturation")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT8_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000005) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StepSaturation::Type mRequest;
};

/*
 * Command StopMoveStep
 */
class ColorControlStopMoveStep : public ModelCommand
{
public:
    ColorControlStopMoveStep() : ModelCommand("stop-move-step")
    {
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000047) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventColorControlWildcard : public ModelCommand
{
public:
    ReadEventColorControlWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventColorControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000300, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventColorControlWildcard : public ModelCommand
{
public:
    ReportEventColorControlWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventColorControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000300, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadColorControlWildcard : public ModelCommand
{
public:
    ReadColorControlWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlWildcard : public ModelCommand
{
public:
    ReportColorControlWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHue
 */
class ReadColorControlCurrentHue : public ModelCommand
{
public:
    ReadColorControlCurrentHue() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentHue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CurrentHue report", 0, value);
    }
};

class ReportColorControlCurrentHue : public ModelCommand
{
public:
    ReportColorControlCurrentHue() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentHue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CurrentHue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentSaturation
 */
class ReadColorControlCurrentSaturation : public ModelCommand
{
public:
    ReadColorControlCurrentSaturation() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-saturation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentSaturation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CurrentSaturation report", 0, value);
    }
};

class ReportColorControlCurrentSaturation : public ModelCommand
{
public:
    ReportColorControlCurrentSaturation() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-saturation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentSaturation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CurrentSaturation report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadColorControlRemainingTime : public ModelCommand
{
public:
    ReadColorControlRemainingTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlRemainingTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.RemainingTime report", 0, value);
    }
};

class ReportColorControlRemainingTime : public ModelCommand
{
public:
    ReportColorControlRemainingTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlRemainingTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.RemainingTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentX
 */
class ReadColorControlCurrentX : public ModelCommand
{
public:
    ReadColorControlCurrentX() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CurrentX report", 0, value);
    }
};

class ReportColorControlCurrentX : public ModelCommand
{
public:
    ReportColorControlCurrentX() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CurrentX report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentY
 */
class ReadColorControlCurrentY : public ModelCommand
{
public:
    ReadColorControlCurrentY() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CurrentY report", 0, value);
    }
};

class ReportColorControlCurrentY : public ModelCommand
{
public:
    ReportColorControlCurrentY() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CurrentY report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DriftCompensation
 */
class ReadColorControlDriftCompensation : public ModelCommand
{
public:
    ReadColorControlDriftCompensation() : ModelCommand("read")
    {
        AddArgument("attr-name", "drift-compensation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlDriftCompensation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.DriftCompensation report", 0, value);
    }
};

class ReportColorControlDriftCompensation : public ModelCommand
{
public:
    ReportColorControlDriftCompensation() : ModelCommand("report")
    {
        AddArgument("attr-name", "drift-compensation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlDriftCompensation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.DriftCompensation report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CompensationText
 */
class ReadColorControlCompensationText : public ModelCommand
{
public:
    ReadColorControlCompensationText() : ModelCommand("read")
    {
        AddArgument("attr-name", "compensation-text");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCompensationText() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CompensationText report", 0, value);
    }
};

class ReportColorControlCompensationText : public ModelCommand
{
public:
    ReportColorControlCompensationText() : ModelCommand("report")
    {
        AddArgument("attr-name", "compensation-text");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCompensationText() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CompensationText report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTemperature
 */
class ReadColorControlColorTemperature : public ModelCommand
{
public:
    ReadColorControlColorTemperature() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTemperature() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorTemperature report", 0, value);
    }
};

class ReportColorControlColorTemperature : public ModelCommand
{
public:
    ReportColorControlColorTemperature() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTemperature() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorTemperature report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorMode
 */
class ReadColorControlColorMode : public ModelCommand
{
public:
    ReadColorControlColorMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorMode report", 0, value);
    }
};

class ReportColorControlColorMode : public ModelCommand
{
public:
    ReportColorControlColorMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorControlOptions
 */
class ReadColorControlColorControlOptions : public ModelCommand
{
public:
    ReadColorControlColorControlOptions() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-control-options");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000000F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorControlOptions report", 0, value);
    }
};

class WriteColorControlColorControlOptions : public ModelCommand
{
public:
    WriteColorControlColorControlOptions() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x0000000F, mValue);
    }

private:
    uint8_t mValue;
};

class ReportColorControlColorControlOptions : public ModelCommand
{
public:
    ReportColorControlColorControlOptions() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000000F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorControlOptions report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPrimaries
 */
class ReadColorControlNumberOfPrimaries : public ModelCommand
{
public:
    ReadColorControlNumberOfPrimaries() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-primaries");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlNumberOfPrimaries() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.NumberOfPrimaries report", 0, value);
    }
};

class ReportColorControlNumberOfPrimaries : public ModelCommand
{
public:
    ReportColorControlNumberOfPrimaries() : ModelCommand("report")
    {
        AddArgument("attr-name", "number-of-primaries");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlNumberOfPrimaries() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.NumberOfPrimaries report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1X
 */
class ReadColorControlPrimary1X : public ModelCommand
{
public:
    ReadColorControlPrimary1X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary1X report", 0, value);
    }
};

class ReportColorControlPrimary1X : public ModelCommand
{
public:
    ReportColorControlPrimary1X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary1x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary1X report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Y
 */
class ReadColorControlPrimary1Y : public ModelCommand
{
public:
    ReadColorControlPrimary1Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary1Y report", 0, value);
    }
};

class ReportColorControlPrimary1Y : public ModelCommand
{
public:
    ReportColorControlPrimary1Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary1y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary1Y report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Intensity
 */
class ReadColorControlPrimary1Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary1Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000013);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary1Intensity report", 0, value);
    }
};

class ReportColorControlPrimary1Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary1Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary1intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000013, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary1Intensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2X
 */
class ReadColorControlPrimary2X : public ModelCommand
{
public:
    ReadColorControlPrimary2X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000015);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary2X report", 0, value);
    }
};

class ReportColorControlPrimary2X : public ModelCommand
{
public:
    ReportColorControlPrimary2X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary2x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000015, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary2X report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Y
 */
class ReadColorControlPrimary2Y : public ModelCommand
{
public:
    ReadColorControlPrimary2Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000016);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary2Y report", 0, value);
    }
};

class ReportColorControlPrimary2Y : public ModelCommand
{
public:
    ReportColorControlPrimary2Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary2y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000016, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary2Y report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Intensity
 */
class ReadColorControlPrimary2Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary2Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000017);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary2Intensity report", 0, value);
    }
};

class ReportColorControlPrimary2Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary2Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary2intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000017, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary2Intensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3X
 */
class ReadColorControlPrimary3X : public ModelCommand
{
public:
    ReadColorControlPrimary3X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000019);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary3X report", 0, value);
    }
};

class ReportColorControlPrimary3X : public ModelCommand
{
public:
    ReportColorControlPrimary3X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary3x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000019, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary3X report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Y
 */
class ReadColorControlPrimary3Y : public ModelCommand
{
public:
    ReadColorControlPrimary3Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000001A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary3Y report", 0, value);
    }
};

class ReportColorControlPrimary3Y : public ModelCommand
{
public:
    ReportColorControlPrimary3Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary3y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000001A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary3Y report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Intensity
 */
class ReadColorControlPrimary3Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary3Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000001B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary3Intensity report", 0, value);
    }
};

class ReportColorControlPrimary3Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary3Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary3intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000001B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary3Intensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4X
 */
class ReadColorControlPrimary4X : public ModelCommand
{
public:
    ReadColorControlPrimary4X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000020);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary4X report", 0, value);
    }
};

class ReportColorControlPrimary4X : public ModelCommand
{
public:
    ReportColorControlPrimary4X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary4x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000020, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary4X report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Y
 */
class ReadColorControlPrimary4Y : public ModelCommand
{
public:
    ReadColorControlPrimary4Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000021);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary4Y report", 0, value);
    }
};

class ReportColorControlPrimary4Y : public ModelCommand
{
public:
    ReportColorControlPrimary4Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary4y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000021, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary4Y report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Intensity
 */
class ReadColorControlPrimary4Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary4Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000022);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary4Intensity report", 0, value);
    }
};

class ReportColorControlPrimary4Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary4Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary4intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000022, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary4Intensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5X
 */
class ReadColorControlPrimary5X : public ModelCommand
{
public:
    ReadColorControlPrimary5X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000024);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary5X report", 0, value);
    }
};

class ReportColorControlPrimary5X : public ModelCommand
{
public:
    ReportColorControlPrimary5X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary5x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000024, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary5X report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Y
 */
class ReadColorControlPrimary5Y : public ModelCommand
{
public:
    ReadColorControlPrimary5Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000025);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary5Y report", 0, value);
    }
};

class ReportColorControlPrimary5Y : public ModelCommand
{
public:
    ReportColorControlPrimary5Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary5y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000025, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary5Y report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Intensity
 */
class ReadColorControlPrimary5Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary5Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000026);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary5Intensity report", 0, value);
    }
};

class ReportColorControlPrimary5Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary5Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary5intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000026, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary5Intensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6X
 */
class ReadColorControlPrimary6X : public ModelCommand
{
public:
    ReadColorControlPrimary6X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000028);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary6X report", 0, value);
    }
};

class ReportColorControlPrimary6X : public ModelCommand
{
public:
    ReportColorControlPrimary6X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary6x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6X() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000028, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary6X report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Y
 */
class ReadColorControlPrimary6Y : public ModelCommand
{
public:
    ReadColorControlPrimary6Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000029);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary6Y report", 0, value);
    }
};

class ReportColorControlPrimary6Y : public ModelCommand
{
public:
    ReportColorControlPrimary6Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary6y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6Y() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000029, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary6Y report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Intensity
 */
class ReadColorControlPrimary6Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary6Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000002A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary6Intensity report", 0, value);
    }
};

class ReportColorControlPrimary6Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary6Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary6intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6Intensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000002A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.Primary6Intensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointX
 */
class ReadColorControlWhitePointX : public ModelCommand
{
public:
    ReadColorControlWhitePointX() : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000030);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.WhitePointX report", 0, value);
    }
};

class WriteColorControlWhitePointX : public ModelCommand
{
public:
    WriteColorControlWhitePointX() : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00000030, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlWhitePointX : public ModelCommand
{
public:
    ReportColorControlWhitePointX() : ModelCommand("report")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000030, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.WhitePointX report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointY
 */
class ReadColorControlWhitePointY : public ModelCommand
{
public:
    ReadColorControlWhitePointY() : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000031);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.WhitePointY report", 0, value);
    }
};

class WriteColorControlWhitePointY : public ModelCommand
{
public:
    WriteColorControlWhitePointY() : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00000031, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlWhitePointY : public ModelCommand
{
public:
    ReportColorControlWhitePointY() : ModelCommand("report")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000031, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.WhitePointY report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRX
 */
class ReadColorControlColorPointRX : public ModelCommand
{
public:
    ReadColorControlColorPointRX() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000032);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointRX report", 0, value);
    }
};

class WriteColorControlColorPointRX : public ModelCommand
{
public:
    WriteColorControlColorPointRX() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00000032, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointRX : public ModelCommand
{
public:
    ReportColorControlColorPointRX() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000032, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointRX report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRY
 */
class ReadColorControlColorPointRY : public ModelCommand
{
public:
    ReadColorControlColorPointRY() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-ry");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000033);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointRY report", 0, value);
    }
};

class WriteColorControlColorPointRY : public ModelCommand
{
public:
    WriteColorControlColorPointRY() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00000033, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointRY : public ModelCommand
{
public:
    ReportColorControlColorPointRY() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000033, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointRY report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRIntensity
 */
class ReadColorControlColorPointRIntensity : public ModelCommand
{
public:
    ReadColorControlColorPointRIntensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000034);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointRIntensity report", 0, value);
    }
};

class WriteColorControlColorPointRIntensity : public ModelCommand
{
public:
    WriteColorControlColorPointRIntensity() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00000034, mValue);
    }

private:
    uint8_t mValue;
};

class ReportColorControlColorPointRIntensity : public ModelCommand
{
public:
    ReportColorControlColorPointRIntensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000034, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointRIntensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGX
 */
class ReadColorControlColorPointGX : public ModelCommand
{
public:
    ReadColorControlColorPointGX() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000036);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointGX report", 0, value);
    }
};

class WriteColorControlColorPointGX : public ModelCommand
{
public:
    WriteColorControlColorPointGX() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00000036, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointGX : public ModelCommand
{
public:
    ReportColorControlColorPointGX() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000036, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointGX report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGY
 */
class ReadColorControlColorPointGY : public ModelCommand
{
public:
    ReadColorControlColorPointGY() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gy");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000037);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointGY report", 0, value);
    }
};

class WriteColorControlColorPointGY : public ModelCommand
{
public:
    WriteColorControlColorPointGY() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00000037, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointGY : public ModelCommand
{
public:
    ReportColorControlColorPointGY() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000037, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointGY report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGIntensity
 */
class ReadColorControlColorPointGIntensity : public ModelCommand
{
public:
    ReadColorControlColorPointGIntensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00000038);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointGIntensity report", 0, value);
    }
};

class WriteColorControlColorPointGIntensity : public ModelCommand
{
public:
    WriteColorControlColorPointGIntensity() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00000038, mValue);
    }

private:
    uint8_t mValue;
};

class ReportColorControlColorPointGIntensity : public ModelCommand
{
public:
    ReportColorControlColorPointGIntensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00000038, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointGIntensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBX
 */
class ReadColorControlColorPointBX : public ModelCommand
{
public:
    ReadColorControlColorPointBX() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000003A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointBX report", 0, value);
    }
};

class WriteColorControlColorPointBX : public ModelCommand
{
public:
    WriteColorControlColorPointBX() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x0000003A, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointBX : public ModelCommand
{
public:
    ReportColorControlColorPointBX() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000003A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointBX report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBY
 */
class ReadColorControlColorPointBY : public ModelCommand
{
public:
    ReadColorControlColorPointBY() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-by");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000003B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointBY report", 0, value);
    }
};

class WriteColorControlColorPointBY : public ModelCommand
{
public:
    WriteColorControlColorPointBY() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x0000003B, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointBY : public ModelCommand
{
public:
    ReportColorControlColorPointBY() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000003B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointBY report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBIntensity
 */
class ReadColorControlColorPointBIntensity : public ModelCommand
{
public:
    ReadColorControlColorPointBIntensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000003C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointBIntensity report", 0, value);
    }
};

class WriteColorControlColorPointBIntensity : public ModelCommand
{
public:
    WriteColorControlColorPointBIntensity() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x0000003C, mValue);
    }

private:
    uint8_t mValue;
};

class ReportColorControlColorPointBIntensity : public ModelCommand
{
public:
    ReportColorControlColorPointBIntensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000003C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorPointBIntensity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedCurrentHue
 */
class ReadColorControlEnhancedCurrentHue : public ModelCommand
{
public:
    ReadColorControlEnhancedCurrentHue() : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedCurrentHue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00004000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.EnhancedCurrentHue report", 0, value);
    }
};

class ReportColorControlEnhancedCurrentHue : public ModelCommand
{
public:
    ReportColorControlEnhancedCurrentHue() : ModelCommand("report")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlEnhancedCurrentHue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00004000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.EnhancedCurrentHue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedColorMode
 */
class ReadColorControlEnhancedColorMode : public ModelCommand
{
public:
    ReadColorControlEnhancedColorMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedColorMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00004001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.EnhancedColorMode report", 0, value);
    }
};

class ReportColorControlEnhancedColorMode : public ModelCommand
{
public:
    ReportColorControlEnhancedColorMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlEnhancedColorMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00004001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.EnhancedColorMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopActive
 */
class ReadColorControlColorLoopActive : public ModelCommand
{
public:
    ReadColorControlColorLoopActive() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-active");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopActive() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00004002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopActive report", 0, value);
    }
};

class ReportColorControlColorLoopActive : public ModelCommand
{
public:
    ReportColorControlColorLoopActive() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-active");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopActive() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00004002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopActive report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopDirection
 */
class ReadColorControlColorLoopDirection : public ModelCommand
{
public:
    ReadColorControlColorLoopDirection() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-direction");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopDirection() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00004003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopDirection report", 0, value);
    }
};

class ReportColorControlColorLoopDirection : public ModelCommand
{
public:
    ReportColorControlColorLoopDirection() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-direction");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopDirection() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00004003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopDirection report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopTime
 */
class ReadColorControlColorLoopTime : public ModelCommand
{
public:
    ReadColorControlColorLoopTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00004004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopTime report", 0, value);
    }
};

class ReportColorControlColorLoopTime : public ModelCommand
{
public:
    ReportColorControlColorLoopTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00004004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStartEnhancedHue
 */
class ReadColorControlColorLoopStartEnhancedHue : public ModelCommand
{
public:
    ReadColorControlColorLoopStartEnhancedHue() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStartEnhancedHue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00004005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopStartEnhancedHue report", 0, value);
    }
};

class ReportColorControlColorLoopStartEnhancedHue : public ModelCommand
{
public:
    ReportColorControlColorLoopStartEnhancedHue() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopStartEnhancedHue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00004005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopStartEnhancedHue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStoredEnhancedHue
 */
class ReadColorControlColorLoopStoredEnhancedHue : public ModelCommand
{
public:
    ReadColorControlColorLoopStoredEnhancedHue() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStoredEnhancedHue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00004006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopStoredEnhancedHue report", 0, value);
    }
};

class ReportColorControlColorLoopStoredEnhancedHue : public ModelCommand
{
public:
    ReportColorControlColorLoopStoredEnhancedHue() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopStoredEnhancedHue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00004006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorLoopStoredEnhancedHue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorCapabilities
 */
class ReadColorControlColorCapabilities : public ModelCommand
{
public:
    ReadColorControlColorCapabilities() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorCapabilities() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000400A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorCapabilities report", 0, value);
    }
};

class ReportColorControlColorCapabilities : public ModelCommand
{
public:
    ReportColorControlColorCapabilities() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorCapabilities() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000400A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorCapabilities report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMin
 */
class ReadColorControlColorTempPhysicalMin : public ModelCommand
{
public:
    ReadColorControlColorTempPhysicalMin() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMin() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000400B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorTempPhysicalMin report", 0, value);
    }
};

class ReportColorControlColorTempPhysicalMin : public ModelCommand
{
public:
    ReportColorControlColorTempPhysicalMin() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTempPhysicalMin() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000400B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorTempPhysicalMin report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMax
 */
class ReadColorControlColorTempPhysicalMax : public ModelCommand
{
public:
    ReadColorControlColorTempPhysicalMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000400C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorTempPhysicalMax report", 0, value);
    }
};

class ReportColorControlColorTempPhysicalMax : public ModelCommand
{
public:
    ReportColorControlColorTempPhysicalMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTempPhysicalMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000400C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ColorTempPhysicalMax report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CoupleColorTempToLevelMinMireds
 */
class ReadColorControlCoupleColorTempToLevelMinMireds : public ModelCommand
{
public:
    ReadColorControlCoupleColorTempToLevelMinMireds() : ModelCommand("read")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCoupleColorTempToLevelMinMireds() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000400D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CoupleColorTempToLevelMinMireds report", 0, value);
    }
};

class ReportColorControlCoupleColorTempToLevelMinMireds : public ModelCommand
{
public:
    ReportColorControlCoupleColorTempToLevelMinMireds() : ModelCommand("report")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCoupleColorTempToLevelMinMireds() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000400D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.CoupleColorTempToLevelMinMireds report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpColorTemperatureMireds
 */
class ReadColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    ReadColorControlStartUpColorTemperatureMireds() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x00004010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.StartUpColorTemperatureMireds report", 0, value);
    }
};

class WriteColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    WriteColorControlStartUpColorTemperatureMireds() : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000300, 0x00004010, mValue);
    }

private:
    uint16_t mValue;
};

class ReportColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    ReportColorControlStartUpColorTemperatureMireds() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x00004010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.StartUpColorTemperatureMireds report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadColorControlAttributeList : public ModelCommand
{
public:
    ReadColorControlAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadColorControlClusterRevision : public ModelCommand
{
public:
    ReadColorControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000300, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ClusterRevision report", 0, value);
    }
};

class ReportColorControlClusterRevision : public ModelCommand
{
public:
    ReportColorControlClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000300, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ColorControl.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ContentLauncher                                             | 0x050A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LaunchContentRequest                                              |   0x00 |
| * LaunchURLRequest                                                  |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AcceptHeaderList                                                  | 0x0000 |
| * SupportedStreamingProtocols                                       | 0x0001 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command LaunchContentRequest
 */
class ContentLauncherLaunchContentRequest : public ModelCommand
{
public:
    ContentLauncherLaunchContentRequest() : ModelCommand("launch-content-request")
    {
        AddArgument("AutoPlay", 0, 1, &mRequest.autoPlay);
        AddArgument("Data", &mRequest.data);
        // search Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnContentLauncherLaunchResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ContentLauncher::Commands::LaunchContentRequest::Type mRequest;
};

/*
 * Command LaunchURLRequest
 */
class ContentLauncherLaunchURLRequest : public ModelCommand
{
public:
    ContentLauncherLaunchURLRequest() : ModelCommand("launch-urlrequest")
    {
        AddArgument("ContentURL", &mRequest.contentURL);
        AddArgument("DisplayString", &mRequest.displayString);
        // brandingInformation Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnContentLauncherLaunchResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ContentLauncher::Commands::LaunchURLRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventContentLauncherWildcard : public ModelCommand
{
public:
    ReadEventContentLauncherWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventContentLauncherWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000050A, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventContentLauncherWildcard : public ModelCommand
{
public:
    ReportEventContentLauncherWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventContentLauncherWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000050A, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadContentLauncherWildcard : public ModelCommand
{
public:
    ReadContentLauncherWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050A, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportContentLauncherWildcard : public ModelCommand
{
public:
    ReportContentLauncherWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050A, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptHeaderList
 */
class ReadContentLauncherAcceptHeaderList : public ModelCommand
{
public:
    ReadContentLauncherAcceptHeaderList() : ModelCommand("read")
    {
        AddArgument("attr-name", "accept-header-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAcceptHeaderList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050A, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::CharSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ContentLauncher.AcceptHeaderList report", 0, value);
    }
};

class ReportContentLauncherAcceptHeaderList : public ModelCommand
{
public:
    ReportContentLauncherAcceptHeaderList() : ModelCommand("report")
    {
        AddArgument("attr-name", "accept-header-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherAcceptHeaderList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050A, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::CharSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ContentLauncher.AcceptHeaderList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedStreamingProtocols
 */
class ReadContentLauncherSupportedStreamingProtocols : public ModelCommand
{
public:
    ReadContentLauncherSupportedStreamingProtocols() : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050A, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ContentLauncher.SupportedStreamingProtocols report", 0, value);
    }
};

class WriteContentLauncherSupportedStreamingProtocols : public ModelCommand
{
public:
    WriteContentLauncherSupportedStreamingProtocols() : ModelCommand("write")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050A, 0x00000001, mValue);
    }

private:
    uint32_t mValue;
};

class ReportContentLauncherSupportedStreamingProtocols : public ModelCommand
{
public:
    ReportContentLauncherSupportedStreamingProtocols() : ModelCommand("report")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050A, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ContentLauncher.SupportedStreamingProtocols report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadContentLauncherAttributeList : public ModelCommand
{
public:
    ReadContentLauncherAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050A, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ContentLauncher.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadContentLauncherClusterRevision : public ModelCommand
{
public:
    ReadContentLauncherClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050A, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ContentLauncher.ClusterRevision report", 0, value);
    }
};

class ReportContentLauncherClusterRevision : public ModelCommand
{
public:
    ReportContentLauncherClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050A, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ContentLauncher.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Descriptor                                                  | 0x001D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DeviceList                                                        | 0x0000 |
| * ServerList                                                        | 0x0001 |
| * ClientList                                                        | 0x0002 |
| * PartsList                                                         | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventDescriptorWildcard : public ModelCommand
{
public:
    ReadEventDescriptorWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventDescriptorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000001D, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventDescriptorWildcard : public ModelCommand
{
public:
    ReportEventDescriptorWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventDescriptorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000001D, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadDescriptorWildcard : public ModelCommand
{
public:
    ReadDescriptorWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001D, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorWildcard : public ModelCommand
{
public:
    ReportDescriptorWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001D, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DeviceList
 */
class ReadDescriptorDeviceList : public ModelCommand
{
public:
    ReadDescriptorDeviceList() : ModelCommand("read")
    {
        AddArgument("attr-name", "device-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorDeviceList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001D, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.DeviceList report", 0, value);
    }
};

class ReportDescriptorDeviceList : public ModelCommand
{
public:
    ReportDescriptorDeviceList() : ModelCommand("report")
    {
        AddArgument("attr-name", "device-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorDeviceList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001D, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.DeviceList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerList
 */
class ReadDescriptorServerList : public ModelCommand
{
public:
    ReadDescriptorServerList() : ModelCommand("read")
    {
        AddArgument("attr-name", "server-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorServerList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001D, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ClusterId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.ServerList report", 0, value);
    }
};

class ReportDescriptorServerList : public ModelCommand
{
public:
    ReportDescriptorServerList() : ModelCommand("report")
    {
        AddArgument("attr-name", "server-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorServerList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001D, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ClusterId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.ServerList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientList
 */
class ReadDescriptorClientList : public ModelCommand
{
public:
    ReadDescriptorClientList() : ModelCommand("read")
    {
        AddArgument("attr-name", "client-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClientList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001D, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ClusterId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.ClientList report", 0, value);
    }
};

class ReportDescriptorClientList : public ModelCommand
{
public:
    ReportDescriptorClientList() : ModelCommand("report")
    {
        AddArgument("attr-name", "client-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorClientList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001D, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ClusterId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.ClientList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartsList
 */
class ReadDescriptorPartsList : public ModelCommand
{
public:
    ReadDescriptorPartsList() : ModelCommand("read")
    {
        AddArgument("attr-name", "parts-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorPartsList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001D, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::EndpointId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.PartsList report", 0, value);
    }
};

class ReportDescriptorPartsList : public ModelCommand
{
public:
    ReportDescriptorPartsList() : ModelCommand("report")
    {
        AddArgument("attr-name", "parts-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorPartsList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001D, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::EndpointId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.PartsList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDescriptorAttributeList : public ModelCommand
{
public:
    ReadDescriptorAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001D, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadDescriptorClusterRevision : public ModelCommand
{
public:
    ReadDescriptorClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000001D, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.ClusterRevision report", 0, value);
    }
};

class ReportDescriptorClusterRevision : public ModelCommand
{
public:
    ReportDescriptorClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000001D, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Descriptor.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster DiagnosticLogs                                              | 0x0032 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * RetrieveLogsRequest                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AttributeList                                                     | 0xFFFB |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RetrieveLogsRequest
 */
class DiagnosticLogsRetrieveLogsRequest : public ModelCommand
{
public:
    DiagnosticLogsRetrieveLogsRequest() : ModelCommand("retrieve-logs-request")
    {
        AddArgument("Intent", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.intent)> *>(&mRequest.intent));
        AddArgument("RequestedProtocol", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.requestedProtocol)> *>(&mRequest.requestedProtocol));
        AddArgument("TransferFileDesignator", &mRequest.transferFileDesignator);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDiagnosticLogsRetrieveLogsResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DiagnosticLogs::Commands::RetrieveLogsRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventDiagnosticLogsWildcard : public ModelCommand
{
public:
    ReadEventDiagnosticLogsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventDiagnosticLogsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000032, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventDiagnosticLogsWildcard : public ModelCommand
{
public:
    ReportEventDiagnosticLogsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventDiagnosticLogsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000032, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadDiagnosticLogsWildcard : public ModelCommand
{
public:
    ReadDiagnosticLogsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000032, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportDiagnosticLogsWildcard : public ModelCommand
{
public:
    ReportDiagnosticLogsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDiagnosticLogsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000032, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDiagnosticLogsAttributeList : public ModelCommand
{
public:
    ReadDiagnosticLogsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000032, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DiagnosticLogs.AttributeList report", 0, value);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster DoorLock                                                    | 0x0101 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ClearCredential                                                   |   0x26 |
| * ClearUser                                                         |   0x1D |
| * GetCredentialStatus                                               |   0x24 |
| * GetUser                                                           |   0x1B |
| * LockDoor                                                          |   0x00 |
| * SetCredential                                                     |   0x22 |
| * SetUser                                                           |   0x1A |
| * UnlockDoor                                                        |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LockState                                                         | 0x0000 |
| * LockType                                                          | 0x0001 |
| * ActuatorEnabled                                                   | 0x0002 |
| * DoorState                                                         | 0x0003 |
| * NumberOfTotalUsersSupported                                       | 0x0011 |
| * NumberOfPINUsersSupported                                         | 0x0012 |
| * MaxPINCodeLength                                                  | 0x0017 |
| * MinPINCodeLength                                                  | 0x0018 |
| * Language                                                          | 0x0021 |
| * AutoRelockTime                                                    | 0x0023 |
| * SoundVolume                                                       | 0x0024 |
| * OperatingMode                                                     | 0x0025 |
| * SupportedOperatingModes                                           | 0x0026 |
| * EnableOneTouchLocking                                             | 0x0029 |
| * EnablePrivacyModeButton                                           | 0x002B |
| * WrongCodeEntryLimit                                               | 0x0030 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * DoorLockAlarm                                                     | 0x0000 |
| * DoorStateChange                                                   | 0x0001 |
| * LockOperation                                                     | 0x0002 |
| * LockOperationError                                                | 0x0003 |
| * LockUserChange                                                    | 0x0004 |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearCredential
 */
class DoorLockClearCredential : public ModelCommand
{
public:
    DoorLockClearCredential() : ModelCommand("clear-credential")
    {
        // credential Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000026) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearCredential::Type mRequest;
};

/*
 * Command ClearUser
 */
class DoorLockClearUser : public ModelCommand
{
public:
    DoorLockClearUser() : ModelCommand("clear-user")
    {
        AddArgument("UserIndex", 0, UINT16_MAX, &mRequest.userIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001D) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearUser::Type mRequest;
};

/*
 * Command GetCredentialStatus
 */
class DoorLockGetCredentialStatus : public ModelCommand
{
public:
    DoorLockGetCredentialStatus() : ModelCommand("get-credential-status")
    {
        // credential Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000024) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetCredentialStatusResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type mRequest;
};

/*
 * Command GetUser
 */
class DoorLockGetUser : public ModelCommand
{
public:
    DoorLockGetUser() : ModelCommand("get-user")
    {
        AddArgument("UserIndex", 0, UINT16_MAX, &mRequest.userIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001B) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetUserResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetUser::Type mRequest;
};

/*
 * Command LockDoor
 */
class DoorLockLockDoor : public ModelCommand
{
public:
    DoorLockLockDoor() : ModelCommand("lock-door")
    {
        AddArgument("PinCode", &mRequest.pinCode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DoorLock::Commands::LockDoor::Type mRequest;
};

/*
 * Command SetCredential
 */
class DoorLockSetCredential : public ModelCommand
{
public:
    DoorLockSetCredential() : ModelCommand("set-credential")
    {
        AddArgument("OperationType", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.operationType)> *>(&mRequest.operationType));
        // credential Struct parsing is not supported yet
        AddArgument("CredentialData", &mRequest.credentialData);
        AddArgument("UserIndex", 0, UINT16_MAX, &mRequest.userIndex);
        AddArgument("UserStatus", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.userStatus)> *>(&mRequest.userStatus));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000022) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockSetCredentialResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DoorLock::Commands::SetCredential::Type mRequest;
};

/*
 * Command SetUser
 */
class DoorLockSetUser : public ModelCommand
{
public:
    DoorLockSetUser() : ModelCommand("set-user")
    {
        AddArgument("OperationType", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.operationType)> *>(&mRequest.operationType));
        AddArgument("UserIndex", 0, UINT16_MAX, &mRequest.userIndex);
        AddArgument("UserName", &mRequest.userName);
        AddArgument("UserUniqueId", 0, UINT32_MAX, &mRequest.userUniqueId);
        AddArgument("UserStatus", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.userStatus)> *>(&mRequest.userStatus));
        AddArgument("UserType", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.userType)> *>(&mRequest.userType));
        AddArgument("CredentialRule", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.credentialRule)> *>(&mRequest.credentialRule));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001A) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DoorLock::Commands::SetUser::Type mRequest;
};

/*
 * Command UnlockDoor
 */
class DoorLockUnlockDoor : public ModelCommand
{
public:
    DoorLockUnlockDoor() : ModelCommand("unlock-door")
    {
        AddArgument("PinCode", &mRequest.pinCode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventDoorLockWildcard : public ModelCommand
{
public:
    ReadEventDoorLockWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventDoorLockWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000101, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventDoorLockWildcard : public ModelCommand
{
public:
    ReportEventDoorLockWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventDoorLockWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000101, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event DoorLockAlarm
 */
class ReadDoorLockDoorLockAlarm : public ModelCommand
{
public:
    ReadDoorLockDoorLockAlarm() : ModelCommand("read-event")
    {
        AddArgument("event-name", "door-lock-alarm");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockDoorLockAlarm() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000101, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::DoorLockAlarm::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.DoorLockAlarm report", 0, value);
    }
};

class ReportDoorLockDoorLockAlarm : public ModelCommand
{
public:
    ReportDoorLockDoorLockAlarm() : ModelCommand("report-event")
    {
        AddArgument("event-name", "door-lock-alarm");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockDoorLockAlarm() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000101, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::DoorLockAlarm::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.DoorLockAlarm report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event DoorStateChange
 */
class ReadDoorLockDoorStateChange : public ModelCommand
{
public:
    ReadDoorLockDoorStateChange() : ModelCommand("read-event")
    {
        AddArgument("event-name", "door-state-change");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockDoorStateChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000101, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::DoorStateChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.DoorStateChange report", 0, value);
    }
};

class ReportDoorLockDoorStateChange : public ModelCommand
{
public:
    ReportDoorLockDoorStateChange() : ModelCommand("report-event")
    {
        AddArgument("event-name", "door-state-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockDoorStateChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000101, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::DoorStateChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.DoorStateChange report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LockOperation
 */
class ReadDoorLockLockOperation : public ModelCommand
{
public:
    ReadDoorLockLockOperation() : ModelCommand("read-event")
    {
        AddArgument("event-name", "lock-operation");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockOperation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000101, 0x00000002);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::LockOperation::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockOperation report", 0, value);
    }
};

class ReportDoorLockLockOperation : public ModelCommand
{
public:
    ReportDoorLockLockOperation() : ModelCommand("report-event")
    {
        AddArgument("event-name", "lock-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockOperation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000101, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::LockOperation::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockOperation report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LockOperationError
 */
class ReadDoorLockLockOperationError : public ModelCommand
{
public:
    ReadDoorLockLockOperationError() : ModelCommand("read-event")
    {
        AddArgument("event-name", "lock-operation-error");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockOperationError() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000101, 0x00000003);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::LockOperationError::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockOperationError report", 0, value);
    }
};

class ReportDoorLockLockOperationError : public ModelCommand
{
public:
    ReportDoorLockLockOperationError() : ModelCommand("report-event")
    {
        AddArgument("event-name", "lock-operation-error");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockOperationError() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000101, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::LockOperationError::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockOperationError report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LockUserChange
 */
class ReadDoorLockLockUserChange : public ModelCommand
{
public:
    ReadDoorLockLockUserChange() : ModelCommand("read-event")
    {
        AddArgument("event-name", "lock-user-change");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockUserChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000101, 0x00000004);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::LockUserChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockUserChange report", 0, value);
    }
};

class ReportDoorLockLockUserChange : public ModelCommand
{
public:
    ReportDoorLockLockUserChange() : ModelCommand("report-event")
    {
        AddArgument("event-name", "lock-user-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockUserChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000101, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::DoorLock::Events::LockUserChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockUserChange report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadDoorLockWildcard : public ModelCommand
{
public:
    ReadDoorLockWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockWildcard : public ModelCommand
{
public:
    ReportDoorLockWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LockState
 */
class ReadDoorLockLockState : public ModelCommand
{
public:
    ReadDoorLockLockState() : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockState report", 0, value);
    }
};

class ReportDoorLockLockState : public ModelCommand
{
public:
    ReportDoorLockLockState() : ModelCommand("report")
    {
        AddArgument("attr-name", "lock-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockState report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LockType
 */
class ReadDoorLockLockType : public ModelCommand
{
public:
    ReadDoorLockLockType() : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-type");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::DoorLock::DlLockType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockType report", 0, value);
    }
};

class ReportDoorLockLockType : public ModelCommand
{
public:
    ReportDoorLockLockType() : ModelCommand("report")
    {
        AddArgument("attr-name", "lock-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::DoorLock::DlLockType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.LockType report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActuatorEnabled
 */
class ReadDoorLockActuatorEnabled : public ModelCommand
{
public:
    ReadDoorLockActuatorEnabled() : ModelCommand("read")
    {
        AddArgument("attr-name", "actuator-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockActuatorEnabled() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.ActuatorEnabled report", 0, value);
    }
};

class ReportDoorLockActuatorEnabled : public ModelCommand
{
public:
    ReportDoorLockActuatorEnabled() : ModelCommand("report")
    {
        AddArgument("attr-name", "actuator-enabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockActuatorEnabled() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.ActuatorEnabled report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DoorState
 */
class ReadDoorLockDoorState : public ModelCommand
{
public:
    ReadDoorLockDoorState() : ModelCommand("read")
    {
        AddArgument("attr-name", "door-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockDoorState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlDoorState> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.DoorState report", 0, value);
    }
};

class ReportDoorLockDoorState : public ModelCommand
{
public:
    ReportDoorLockDoorState() : ModelCommand("report")
    {
        AddArgument("attr-name", "door-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockDoorState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlDoorState> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.DoorState report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfTotalUsersSupported
 */
class ReadDoorLockNumberOfTotalUsersSupported : public ModelCommand
{
public:
    ReadDoorLockNumberOfTotalUsersSupported() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-total-users-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfTotalUsersSupported() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.NumberOfTotalUsersSupported report", 0, value);
    }
};

/*
 * Attribute NumberOfPINUsersSupported
 */
class ReadDoorLockNumberOfPINUsersSupported : public ModelCommand
{
public:
    ReadDoorLockNumberOfPINUsersSupported() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-pinusers-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfPINUsersSupported() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.NumberOfPINUsersSupported report", 0, value);
    }
};

/*
 * Attribute MaxPINCodeLength
 */
class ReadDoorLockMaxPINCodeLength : public ModelCommand
{
public:
    ReadDoorLockMaxPINCodeLength() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pincode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMaxPINCodeLength() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000017);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.MaxPINCodeLength report", 0, value);
    }
};

/*
 * Attribute MinPINCodeLength
 */
class ReadDoorLockMinPINCodeLength : public ModelCommand
{
public:
    ReadDoorLockMinPINCodeLength() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-pincode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMinPINCodeLength() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000018);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.MinPINCodeLength report", 0, value);
    }
};

/*
 * Attribute Language
 */
class ReadDoorLockLanguage : public ModelCommand
{
public:
    ReadDoorLockLanguage() : ModelCommand("read")
    {
        AddArgument("attr-name", "language");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLanguage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000021);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.Language report", 0, value);
    }
};

class WriteDoorLockLanguage : public ModelCommand
{
public:
    WriteDoorLockLanguage() : ModelCommand("write")
    {
        AddArgument("attr-name", "language");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockLanguage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000101, 0x00000021, mValue);
    }

private:
    chip::CharSpan mValue;
};

class ReportDoorLockLanguage : public ModelCommand
{
public:
    ReportDoorLockLanguage() : ModelCommand("report")
    {
        AddArgument("attr-name", "language");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLanguage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000021, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.Language report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AutoRelockTime
 */
class ReadDoorLockAutoRelockTime : public ModelCommand
{
public:
    ReadDoorLockAutoRelockTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "auto-relock-time");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000023);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.AutoRelockTime report", 0, value);
    }
};

class WriteDoorLockAutoRelockTime : public ModelCommand
{
public:
    WriteDoorLockAutoRelockTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "auto-relock-time");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000101, 0x00000023, mValue);
    }

private:
    uint32_t mValue;
};

class ReportDoorLockAutoRelockTime : public ModelCommand
{
public:
    ReportDoorLockAutoRelockTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "auto-relock-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000023, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.AutoRelockTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoundVolume
 */
class ReadDoorLockSoundVolume : public ModelCommand
{
public:
    ReadDoorLockSoundVolume() : ModelCommand("read")
    {
        AddArgument("attr-name", "sound-volume");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000024);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.SoundVolume report", 0, value);
    }
};

class WriteDoorLockSoundVolume : public ModelCommand
{
public:
    WriteDoorLockSoundVolume() : ModelCommand("write")
    {
        AddArgument("attr-name", "sound-volume");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000101, 0x00000024, mValue);
    }

private:
    uint8_t mValue;
};

class ReportDoorLockSoundVolume : public ModelCommand
{
public:
    ReportDoorLockSoundVolume() : ModelCommand("report")
    {
        AddArgument("attr-name", "sound-volume");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000024, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.SoundVolume report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperatingMode
 */
class ReadDoorLockOperatingMode : public ModelCommand
{
public:
    ReadDoorLockOperatingMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "operating-mode");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000025);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::DoorLock::DlOperatingMode value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.OperatingMode report", 0, value);
    }
};

class WriteDoorLockOperatingMode : public ModelCommand
{
public:
    WriteDoorLockOperatingMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "operating-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000101, 0x00000025, mValue);
    }

private:
    chip::app::Clusters::DoorLock::DlOperatingMode mValue;
};

class ReportDoorLockOperatingMode : public ModelCommand
{
public:
    ReportDoorLockOperatingMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "operating-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000025, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::DoorLock::DlOperatingMode value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.OperatingMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedOperatingModes
 */
class ReadDoorLockSupportedOperatingModes : public ModelCommand
{
public:
    ReadDoorLockSupportedOperatingModes() : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-operating-modes");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockSupportedOperatingModes() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000026);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.SupportedOperatingModes report", 0, value);
    }
};

/*
 * Attribute EnableOneTouchLocking
 */
class ReadDoorLockEnableOneTouchLocking : public ModelCommand
{
public:
    ReadDoorLockEnableOneTouchLocking() : ModelCommand("read")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000029);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.EnableOneTouchLocking report", 0, value);
    }
};

class WriteDoorLockEnableOneTouchLocking : public ModelCommand
{
public:
    WriteDoorLockEnableOneTouchLocking() : ModelCommand("write")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000101, 0x00000029, mValue);
    }

private:
    bool mValue;
};

class ReportDoorLockEnableOneTouchLocking : public ModelCommand
{
public:
    ReportDoorLockEnableOneTouchLocking() : ModelCommand("report")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000029, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.EnableOneTouchLocking report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnablePrivacyModeButton
 */
class ReadDoorLockEnablePrivacyModeButton : public ModelCommand
{
public:
    ReadDoorLockEnablePrivacyModeButton() : ModelCommand("read")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x0000002B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.EnablePrivacyModeButton report", 0, value);
    }
};

class WriteDoorLockEnablePrivacyModeButton : public ModelCommand
{
public:
    WriteDoorLockEnablePrivacyModeButton() : ModelCommand("write")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000101, 0x0000002B, mValue);
    }

private:
    bool mValue;
};

class ReportDoorLockEnablePrivacyModeButton : public ModelCommand
{
public:
    ReportDoorLockEnablePrivacyModeButton() : ModelCommand("report")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x0000002B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.EnablePrivacyModeButton report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WrongCodeEntryLimit
 */
class ReadDoorLockWrongCodeEntryLimit : public ModelCommand
{
public:
    ReadDoorLockWrongCodeEntryLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x00000030);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.WrongCodeEntryLimit report", 0, value);
    }
};

class WriteDoorLockWrongCodeEntryLimit : public ModelCommand
{
public:
    WriteDoorLockWrongCodeEntryLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000101, 0x00000030, mValue);
    }

private:
    uint8_t mValue;
};

class ReportDoorLockWrongCodeEntryLimit : public ModelCommand
{
public:
    ReportDoorLockWrongCodeEntryLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x00000030, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.WrongCodeEntryLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDoorLockAttributeList : public ModelCommand
{
public:
    ReadDoorLockAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadDoorLockClusterRevision : public ModelCommand
{
public:
    ReadDoorLockClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000101, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.ClusterRevision report", 0, value);
    }
};

class ReportDoorLockClusterRevision : public ModelCommand
{
public:
    ReportDoorLockClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000101, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("DoorLock.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ElectricalMeasurement                                       | 0x0B04 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasurementType                                                   | 0x0000 |
| * TotalActivePower                                                  | 0x0304 |
| * RmsVoltage                                                        | 0x0505 |
| * RmsVoltageMin                                                     | 0x0506 |
| * RmsVoltageMax                                                     | 0x0507 |
| * RmsCurrent                                                        | 0x0508 |
| * RmsCurrentMin                                                     | 0x0509 |
| * RmsCurrentMax                                                     | 0x050A |
| * ActivePower                                                       | 0x050B |
| * ActivePowerMin                                                    | 0x050C |
| * ActivePowerMax                                                    | 0x050D |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventElectricalMeasurementWildcard : public ModelCommand
{
public:
    ReadEventElectricalMeasurementWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventElectricalMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000B04, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventElectricalMeasurementWildcard : public ModelCommand
{
public:
    ReportEventElectricalMeasurementWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventElectricalMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000B04, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadElectricalMeasurementWildcard : public ModelCommand
{
public:
    ReadElectricalMeasurementWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementWildcard : public ModelCommand
{
public:
    ReportElectricalMeasurementWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeasurementType
 */
class ReadElectricalMeasurementMeasurementType : public ModelCommand
{
public:
    ReadElectricalMeasurementMeasurementType() : ModelCommand("read")
    {
        AddArgument("attr-name", "measurement-type");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementMeasurementType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.MeasurementType report", 0, value);
    }
};

class ReportElectricalMeasurementMeasurementType : public ModelCommand
{
public:
    ReportElectricalMeasurementMeasurementType() : ModelCommand("report")
    {
        AddArgument("attr-name", "measurement-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementMeasurementType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.MeasurementType report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalActivePower
 */
class ReadElectricalMeasurementTotalActivePower : public ModelCommand
{
public:
    ReadElectricalMeasurementTotalActivePower() : ModelCommand("read")
    {
        AddArgument("attr-name", "total-active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementTotalActivePower() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x00000304);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.TotalActivePower report", 0, value);
    }
};

class ReportElectricalMeasurementTotalActivePower : public ModelCommand
{
public:
    ReportElectricalMeasurementTotalActivePower() : ModelCommand("report")
    {
        AddArgument("attr-name", "total-active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementTotalActivePower() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x00000304, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.TotalActivePower report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltage
 */
class ReadElectricalMeasurementRmsVoltage : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsVoltage() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x00000505);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsVoltage report", 0, value);
    }
};

class ReportElectricalMeasurementRmsVoltage : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsVoltage() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x00000505, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsVoltage report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMin
 */
class ReadElectricalMeasurementRmsVoltageMin : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsVoltageMin() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMin() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x00000506);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsVoltageMin report", 0, value);
    }
};

class ReportElectricalMeasurementRmsVoltageMin : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsVoltageMin() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-voltage-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltageMin() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x00000506, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsVoltageMin report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMax
 */
class ReadElectricalMeasurementRmsVoltageMax : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsVoltageMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x00000507);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsVoltageMax report", 0, value);
    }
};

class ReportElectricalMeasurementRmsVoltageMax : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsVoltageMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-voltage-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltageMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x00000507, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsVoltageMax report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrent
 */
class ReadElectricalMeasurementRmsCurrent : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsCurrent() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrent() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x00000508);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsCurrent report", 0, value);
    }
};

class ReportElectricalMeasurementRmsCurrent : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsCurrent() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-current");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrent() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x00000508, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsCurrent report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMin
 */
class ReadElectricalMeasurementRmsCurrentMin : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsCurrentMin() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMin() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x00000509);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsCurrentMin report", 0, value);
    }
};

class ReportElectricalMeasurementRmsCurrentMin : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsCurrentMin() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-current-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrentMin() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x00000509, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsCurrentMin report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMax
 */
class ReadElectricalMeasurementRmsCurrentMax : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsCurrentMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x0000050A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsCurrentMax report", 0, value);
    }
};

class ReportElectricalMeasurementRmsCurrentMax : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsCurrentMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-current-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrentMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x0000050A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.RmsCurrentMax report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePower
 */
class ReadElectricalMeasurementActivePower : public ModelCommand
{
public:
    ReadElectricalMeasurementActivePower() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePower() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x0000050B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.ActivePower report", 0, value);
    }
};

class ReportElectricalMeasurementActivePower : public ModelCommand
{
public:
    ReportElectricalMeasurementActivePower() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePower() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x0000050B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.ActivePower report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMin
 */
class ReadElectricalMeasurementActivePowerMin : public ModelCommand
{
public:
    ReadElectricalMeasurementActivePowerMin() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMin() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x0000050C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.ActivePowerMin report", 0, value);
    }
};

class ReportElectricalMeasurementActivePowerMin : public ModelCommand
{
public:
    ReportElectricalMeasurementActivePowerMin() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-power-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePowerMin() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x0000050C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.ActivePowerMin report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMax
 */
class ReadElectricalMeasurementActivePowerMax : public ModelCommand
{
public:
    ReadElectricalMeasurementActivePowerMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x0000050D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.ActivePowerMax report", 0, value);
    }
};

class ReportElectricalMeasurementActivePowerMax : public ModelCommand
{
public:
    ReportElectricalMeasurementActivePowerMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-power-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePowerMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x0000050D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.ActivePowerMax report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadElectricalMeasurementAttributeList : public ModelCommand
{
public:
    ReadElectricalMeasurementAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadElectricalMeasurementClusterRevision : public ModelCommand
{
public:
    ReadElectricalMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000B04, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.ClusterRevision report", 0, value);
    }
};

class ReportElectricalMeasurementClusterRevision : public ModelCommand
{
public:
    ReportElectricalMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000B04, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ElectricalMeasurement.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster EthernetNetworkDiagnostics                                  | 0x0037 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * PHYRate                                                           | 0x0000 |
| * FullDuplex                                                        | 0x0001 |
| * PacketRxCount                                                     | 0x0002 |
| * PacketTxCount                                                     | 0x0003 |
| * TxErrCount                                                        | 0x0004 |
| * CollisionCount                                                    | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * CarrierDetect                                                     | 0x0007 |
| * TimeSinceReset                                                    | 0x0008 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class EthernetNetworkDiagnosticsResetCounts : public ModelCommand
{
public:
    EthernetNetworkDiagnosticsResetCounts() : ModelCommand("reset-counts") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::EthernetNetworkDiagnostics::Commands::ResetCounts::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventEthernetNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReadEventEthernetNetworkDiagnosticsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventEthernetNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000037, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventEthernetNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReportEventEthernetNetworkDiagnosticsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventEthernetNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000037, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadEthernetNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PHYRate
 */
class ReadEthernetNetworkDiagnosticsPHYRate : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsPHYRate() : ModelCommand("read")
    {
        AddArgument("attr-name", "phyrate");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPHYRate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.PHYRate report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsPHYRate : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsPHYRate() : ModelCommand("report")
    {
        AddArgument("attr-name", "phyrate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPHYRate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.PHYRate report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FullDuplex
 */
class ReadEthernetNetworkDiagnosticsFullDuplex : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsFullDuplex() : ModelCommand("read")
    {
        AddArgument("attr-name", "full-duplex");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFullDuplex() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.FullDuplex report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsFullDuplex : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsFullDuplex() : ModelCommand("report")
    {
        AddArgument("attr-name", "full-duplex");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsFullDuplex() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.FullDuplex report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketRxCount
 */
class ReadEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsPacketRxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketRxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.PacketRxCount report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsPacketRxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPacketRxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.PacketRxCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketTxCount
 */
class ReadEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsPacketTxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketTxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.PacketTxCount report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsPacketTxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPacketTxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.PacketTxCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCount
 */
class ReadEthernetNetworkDiagnosticsTxErrCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsTxErrCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTxErrCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.TxErrCount report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsTxErrCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsTxErrCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-err-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsTxErrCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.TxErrCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CollisionCount
 */
class ReadEthernetNetworkDiagnosticsCollisionCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsCollisionCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "collision-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCollisionCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.CollisionCount report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsCollisionCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsCollisionCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "collision-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsCollisionCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.CollisionCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadEthernetNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsOverrunCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.OverrunCount report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsOverrunCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.OverrunCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CarrierDetect
 */
class ReadEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsCarrierDetect() : ModelCommand("read")
    {
        AddArgument("attr-name", "carrier-detect");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCarrierDetect() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.CarrierDetect report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsCarrierDetect() : ModelCommand("report")
    {
        AddArgument("attr-name", "carrier-detect");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsCarrierDetect() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.CarrierDetect report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TimeSinceReset
 */
class ReadEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsTimeSinceReset() : ModelCommand("read")
    {
        AddArgument("attr-name", "time-since-reset");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTimeSinceReset() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x00000008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.TimeSinceReset report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsTimeSinceReset() : ModelCommand("report")
    {
        AddArgument("attr-name", "time-since-reset");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsTimeSinceReset() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.TimeSinceReset report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadEthernetNetworkDiagnosticsAttributeList : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadEthernetNetworkDiagnosticsFeatureMap : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.FeatureMap report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadEthernetNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000037, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.ClusterRevision report", 0, value);
    }
};

class ReportEthernetNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000037, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("EthernetNetworkDiagnostics.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FixedLabel                                                  | 0x0040 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventFixedLabelWildcard : public ModelCommand
{
public:
    ReadEventFixedLabelWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventFixedLabelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000040, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventFixedLabelWildcard : public ModelCommand
{
public:
    ReportEventFixedLabelWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventFixedLabelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000040, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadFixedLabelWildcard : public ModelCommand
{
public:
    ReadFixedLabelWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000040, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportFixedLabelWildcard : public ModelCommand
{
public:
    ReportFixedLabelWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000040, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LabelList
 */
class ReadFixedLabelLabelList : public ModelCommand
{
public:
    ReadFixedLabelLabelList() : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelLabelList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000040, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FixedLabel.LabelList report", 0, value);
    }
};

class ReportFixedLabelLabelList : public ModelCommand
{
public:
    ReportFixedLabelLabelList() : ModelCommand("report")
    {
        AddArgument("attr-name", "label-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelLabelList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000040, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FixedLabel.LabelList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFixedLabelAttributeList : public ModelCommand
{
public:
    ReadFixedLabelAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000040, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FixedLabel.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadFixedLabelClusterRevision : public ModelCommand
{
public:
    ReadFixedLabelClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000040, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FixedLabel.ClusterRevision report", 0, value);
    }
};

class ReportFixedLabelClusterRevision : public ModelCommand
{
public:
    ReportFixedLabelClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000040, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FixedLabel.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FlowMeasurement                                             | 0x0404 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventFlowMeasurementWildcard : public ModelCommand
{
public:
    ReadEventFlowMeasurementWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventFlowMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000404, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventFlowMeasurementWildcard : public ModelCommand
{
public:
    ReportEventFlowMeasurementWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventFlowMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000404, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadFlowMeasurementWildcard : public ModelCommand
{
public:
    ReadFlowMeasurementWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000404, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementWildcard : public ModelCommand
{
public:
    ReportFlowMeasurementWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000404, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeasuredValue
 */
class ReadFlowMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadFlowMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000404, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.MeasuredValue report", 0, value);
    }
};

class ReportFlowMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportFlowMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000404, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.MeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadFlowMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadFlowMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000404, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.MinMeasuredValue report", 0, value);
    }
};

class ReportFlowMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportFlowMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000404, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.MinMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadFlowMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadFlowMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000404, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.MaxMeasuredValue report", 0, value);
    }
};

class ReportFlowMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportFlowMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000404, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.MaxMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadFlowMeasurementTolerance : public ModelCommand
{
public:
    ReadFlowMeasurementTolerance() : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementTolerance() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000404, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.Tolerance report", 0, value);
    }
};

class ReportFlowMeasurementTolerance : public ModelCommand
{
public:
    ReportFlowMeasurementTolerance() : ModelCommand("report")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementTolerance() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000404, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.Tolerance report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFlowMeasurementAttributeList : public ModelCommand
{
public:
    ReadFlowMeasurementAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000404, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadFlowMeasurementClusterRevision : public ModelCommand
{
public:
    ReadFlowMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000404, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.ClusterRevision report", 0, value);
    }
};

class ReportFlowMeasurementClusterRevision : public ModelCommand
{
public:
    ReportFlowMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000404, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("FlowMeasurement.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralCommissioning                                        | 0x0030 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ArmFailSafe                                                       |   0x00 |
| * CommissioningComplete                                             |   0x04 |
| * SetRegulatoryConfig                                               |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Breadcrumb                                                        | 0x0000 |
| * BasicCommissioningInfoList                                        | 0x0001 |
| * RegulatoryConfig                                                  | 0x0002 |
| * LocationCapability                                                | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ArmFailSafe
 */
class GeneralCommissioningArmFailSafe : public ModelCommand
{
public:
    GeneralCommissioningArmFailSafe() : ModelCommand("arm-fail-safe")
    {
        AddArgument("ExpiryLengthSeconds", 0, UINT16_MAX, &mRequest.expiryLengthSeconds);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGeneralCommissioningArmFailSafeResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type mRequest;
};

/*
 * Command CommissioningComplete
 */
class GeneralCommissioningCommissioningComplete : public ModelCommand
{
public:
    GeneralCommissioningCommissioningComplete() : ModelCommand("commissioning-complete") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGeneralCommissioningCommissioningCompleteResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::GeneralCommissioning::Commands::CommissioningComplete::Type mRequest;
};

/*
 * Command SetRegulatoryConfig
 */
class GeneralCommissioningSetRegulatoryConfig : public ModelCommand
{
public:
    GeneralCommissioningSetRegulatoryConfig() : ModelCommand("set-regulatory-config")
    {
        AddArgument("Location", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.location)> *>(&mRequest.location));
        AddArgument("CountryCode", &mRequest.countryCode);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGeneralCommissioningSetRegulatoryConfigResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::GeneralCommissioning::Commands::SetRegulatoryConfig::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventGeneralCommissioningWildcard : public ModelCommand
{
public:
    ReadEventGeneralCommissioningWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventGeneralCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000030, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventGeneralCommissioningWildcard : public ModelCommand
{
public:
    ReportEventGeneralCommissioningWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventGeneralCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000030, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadGeneralCommissioningWildcard : public ModelCommand
{
public:
    ReadGeneralCommissioningWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000030, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralCommissioningWildcard : public ModelCommand
{
public:
    ReportGeneralCommissioningWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000030, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Breadcrumb
 */
class ReadGeneralCommissioningBreadcrumb : public ModelCommand
{
public:
    ReadGeneralCommissioningBreadcrumb() : ModelCommand("read")
    {
        AddArgument("attr-name", "breadcrumb");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000030, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.Breadcrumb report", 0, value);
    }
};

class WriteGeneralCommissioningBreadcrumb : public ModelCommand
{
public:
    WriteGeneralCommissioningBreadcrumb() : ModelCommand("write")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000030, 0x00000000, mValue);
    }

private:
    uint64_t mValue;
};

class ReportGeneralCommissioningBreadcrumb : public ModelCommand
{
public:
    ReportGeneralCommissioningBreadcrumb() : ModelCommand("report")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000030, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.Breadcrumb report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BasicCommissioningInfoList
 */
class ReadGeneralCommissioningBasicCommissioningInfoList : public ModelCommand
{
public:
    ReadGeneralCommissioningBasicCommissioningInfoList() : ModelCommand("read")
    {
        AddArgument("attr-name", "basic-commissioning-info-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBasicCommissioningInfoList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000030, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<
            chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.BasicCommissioningInfoList report", 0, value);
    }
};

class ReportGeneralCommissioningBasicCommissioningInfoList : public ModelCommand
{
public:
    ReportGeneralCommissioningBasicCommissioningInfoList() : ModelCommand("report")
    {
        AddArgument("attr-name", "basic-commissioning-info-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningBasicCommissioningInfoList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000030, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<
            chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.BasicCommissioningInfoList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RegulatoryConfig
 */
class ReadGeneralCommissioningRegulatoryConfig : public ModelCommand
{
public:
    ReadGeneralCommissioningRegulatoryConfig() : ModelCommand("read")
    {
        AddArgument("attr-name", "regulatory-config");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningRegulatoryConfig() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000030, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.RegulatoryConfig report", 0, value);
    }
};

/*
 * Attribute LocationCapability
 */
class ReadGeneralCommissioningLocationCapability : public ModelCommand
{
public:
    ReadGeneralCommissioningLocationCapability() : ModelCommand("read")
    {
        AddArgument("attr-name", "location-capability");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningLocationCapability() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000030, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.LocationCapability report", 0, value);
    }
};

/*
 * Attribute AttributeList
 */
class ReadGeneralCommissioningAttributeList : public ModelCommand
{
public:
    ReadGeneralCommissioningAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000030, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralCommissioningClusterRevision : public ModelCommand
{
public:
    ReadGeneralCommissioningClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000030, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.ClusterRevision report", 0, value);
    }
};

class ReportGeneralCommissioningClusterRevision : public ModelCommand
{
public:
    ReportGeneralCommissioningClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000030, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralCommissioning.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralDiagnostics                                          | 0x0033 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NetworkInterfaces                                                 | 0x0000 |
| * RebootCount                                                       | 0x0001 |
| * UpTime                                                            | 0x0002 |
| * TotalOperationalHours                                             | 0x0003 |
| * BootReasons                                                       | 0x0004 |
| * ActiveHardwareFaults                                              | 0x0005 |
| * ActiveRadioFaults                                                 | 0x0006 |
| * ActiveNetworkFaults                                               | 0x0007 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * HardwareFaultChange                                               | 0x0000 |
| * RadioFaultChange                                                  | 0x0001 |
| * NetworkFaultChange                                                | 0x0002 |
| * BootReason                                                        | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventGeneralDiagnosticsWildcard : public ModelCommand
{
public:
    ReadEventGeneralDiagnosticsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventGeneralDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000033, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventGeneralDiagnosticsWildcard : public ModelCommand
{
public:
    ReportEventGeneralDiagnosticsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventGeneralDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000033, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event HardwareFaultChange
 */
class ReadGeneralDiagnosticsHardwareFaultChange : public ModelCommand
{
public:
    ReadGeneralDiagnosticsHardwareFaultChange() : ModelCommand("read-event")
    {
        AddArgument("event-name", "hardware-fault-change");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsHardwareFaultChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000033, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::GeneralDiagnostics::Events::HardwareFaultChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.HardwareFaultChange report", 0, value);
    }
};

class ReportGeneralDiagnosticsHardwareFaultChange : public ModelCommand
{
public:
    ReportGeneralDiagnosticsHardwareFaultChange() : ModelCommand("report-event")
    {
        AddArgument("event-name", "hardware-fault-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsHardwareFaultChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000033, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::GeneralDiagnostics::Events::HardwareFaultChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.HardwareFaultChange report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event RadioFaultChange
 */
class ReadGeneralDiagnosticsRadioFaultChange : public ModelCommand
{
public:
    ReadGeneralDiagnosticsRadioFaultChange() : ModelCommand("read-event")
    {
        AddArgument("event-name", "radio-fault-change");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsRadioFaultChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000033, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::GeneralDiagnostics::Events::RadioFaultChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.RadioFaultChange report", 0, value);
    }
};

class ReportGeneralDiagnosticsRadioFaultChange : public ModelCommand
{
public:
    ReportGeneralDiagnosticsRadioFaultChange() : ModelCommand("report-event")
    {
        AddArgument("event-name", "radio-fault-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsRadioFaultChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000033, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::GeneralDiagnostics::Events::RadioFaultChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.RadioFaultChange report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event NetworkFaultChange
 */
class ReadGeneralDiagnosticsNetworkFaultChange : public ModelCommand
{
public:
    ReadGeneralDiagnosticsNetworkFaultChange() : ModelCommand("read-event")
    {
        AddArgument("event-name", "network-fault-change");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsNetworkFaultChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000033, 0x00000002);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::GeneralDiagnostics::Events::NetworkFaultChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.NetworkFaultChange report", 0, value);
    }
};

class ReportGeneralDiagnosticsNetworkFaultChange : public ModelCommand
{
public:
    ReportGeneralDiagnosticsNetworkFaultChange() : ModelCommand("report-event")
    {
        AddArgument("event-name", "network-fault-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsNetworkFaultChange() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000033, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::GeneralDiagnostics::Events::NetworkFaultChange::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.NetworkFaultChange report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event BootReason
 */
class ReadGeneralDiagnosticsBootReason : public ModelCommand
{
public:
    ReadGeneralDiagnosticsBootReason() : ModelCommand("read-event")
    {
        AddArgument("event-name", "boot-reason");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsBootReason() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000033, 0x00000003);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::GeneralDiagnostics::Events::BootReason::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.BootReason report", 0, value);
    }
};

class ReportGeneralDiagnosticsBootReason : public ModelCommand
{
public:
    ReportGeneralDiagnosticsBootReason() : ModelCommand("report-event")
    {
        AddArgument("event-name", "boot-reason");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsBootReason() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000033, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::GeneralDiagnostics::Events::BootReason::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.BootReason report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadGeneralDiagnosticsWildcard : public ModelCommand
{
public:
    ReadGeneralDiagnosticsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsWildcard : public ModelCommand
{
public:
    ReportGeneralDiagnosticsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NetworkInterfaces
 */
class ReadGeneralDiagnosticsNetworkInterfaces : public ModelCommand
{
public:
    ReadGeneralDiagnosticsNetworkInterfaces() : ModelCommand("read")
    {
        AddArgument("attr-name", "network-interfaces");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsNetworkInterfaces() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.NetworkInterfaces report", 0, value);
    }
};

class ReportGeneralDiagnosticsNetworkInterfaces : public ModelCommand
{
public:
    ReportGeneralDiagnosticsNetworkInterfaces() : ModelCommand("report")
    {
        AddArgument("attr-name", "network-interfaces");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsNetworkInterfaces() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.NetworkInterfaces report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RebootCount
 */
class ReadGeneralDiagnosticsRebootCount : public ModelCommand
{
public:
    ReadGeneralDiagnosticsRebootCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "reboot-count");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsRebootCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.RebootCount report", 0, value);
    }
};

class ReportGeneralDiagnosticsRebootCount : public ModelCommand
{
public:
    ReportGeneralDiagnosticsRebootCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "reboot-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsRebootCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.RebootCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpTime
 */
class ReadGeneralDiagnosticsUpTime : public ModelCommand
{
public:
    ReadGeneralDiagnosticsUpTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "up-time");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsUpTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.UpTime report", 0, value);
    }
};

class ReportGeneralDiagnosticsUpTime : public ModelCommand
{
public:
    ReportGeneralDiagnosticsUpTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "up-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsUpTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.UpTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalOperationalHours
 */
class ReadGeneralDiagnosticsTotalOperationalHours : public ModelCommand
{
public:
    ReadGeneralDiagnosticsTotalOperationalHours() : ModelCommand("read")
    {
        AddArgument("attr-name", "total-operational-hours");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsTotalOperationalHours() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.TotalOperationalHours report", 0, value);
    }
};

class ReportGeneralDiagnosticsTotalOperationalHours : public ModelCommand
{
public:
    ReportGeneralDiagnosticsTotalOperationalHours() : ModelCommand("report")
    {
        AddArgument("attr-name", "total-operational-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsTotalOperationalHours() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.TotalOperationalHours report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BootReasons
 */
class ReadGeneralDiagnosticsBootReasons : public ModelCommand
{
public:
    ReadGeneralDiagnosticsBootReasons() : ModelCommand("read")
    {
        AddArgument("attr-name", "boot-reasons");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsBootReasons() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.BootReasons report", 0, value);
    }
};

class ReportGeneralDiagnosticsBootReasons : public ModelCommand
{
public:
    ReportGeneralDiagnosticsBootReasons() : ModelCommand("report")
    {
        AddArgument("attr-name", "boot-reasons");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsBootReasons() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.BootReasons report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveHardwareFaults
 */
class ReadGeneralDiagnosticsActiveHardwareFaults : public ModelCommand
{
public:
    ReadGeneralDiagnosticsActiveHardwareFaults() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-hardware-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveHardwareFaults() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.ActiveHardwareFaults report", 0, value);
    }
};

class ReportGeneralDiagnosticsActiveHardwareFaults : public ModelCommand
{
public:
    ReportGeneralDiagnosticsActiveHardwareFaults() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-hardware-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsActiveHardwareFaults() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.ActiveHardwareFaults report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveRadioFaults
 */
class ReadGeneralDiagnosticsActiveRadioFaults : public ModelCommand
{
public:
    ReadGeneralDiagnosticsActiveRadioFaults() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-radio-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveRadioFaults() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.ActiveRadioFaults report", 0, value);
    }
};

class ReportGeneralDiagnosticsActiveRadioFaults : public ModelCommand
{
public:
    ReportGeneralDiagnosticsActiveRadioFaults() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-radio-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsActiveRadioFaults() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.ActiveRadioFaults report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveNetworkFaults
 */
class ReadGeneralDiagnosticsActiveNetworkFaults : public ModelCommand
{
public:
    ReadGeneralDiagnosticsActiveNetworkFaults() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveNetworkFaults() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.ActiveNetworkFaults report", 0, value);
    }
};

class ReportGeneralDiagnosticsActiveNetworkFaults : public ModelCommand
{
public:
    ReportGeneralDiagnosticsActiveNetworkFaults() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-network-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsActiveNetworkFaults() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.ActiveNetworkFaults report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGeneralDiagnosticsAttributeList : public ModelCommand
{
public:
    ReadGeneralDiagnosticsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadGeneralDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000033, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.ClusterRevision report", 0, value);
    }
};

class ReportGeneralDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportGeneralDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000033, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GeneralDiagnostics.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GroupKeyManagement                                          | 0x003F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * KeySetRead                                                        |   0x01 |
| * KeySetReadAllIndices                                              |   0x04 |
| * KeySetRemove                                                      |   0x03 |
| * KeySetWrite                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GroupKeyMap                                                       | 0x0000 |
| * GroupTable                                                        | 0x0001 |
| * MaxGroupsPerFabric                                                | 0x0002 |
| * MaxGroupKeysPerFabric                                             | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command KeySetRead
 */
class GroupKeyManagementKeySetRead : public ModelCommand
{
public:
    GroupKeyManagementKeySetRead() : ModelCommand("key-set-read")
    {
        AddArgument("GroupKeySetID", 0, UINT16_MAX, &mRequest.groupKeySetID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupKeyManagementKeySetReadResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type mRequest;
};

/*
 * Command KeySetReadAllIndices
 */
class GroupKeyManagementKeySetReadAllIndices : public ModelCommand
{
public:
    GroupKeyManagementKeySetReadAllIndices() : ModelCommand("key-set-read-all-indices")
    {
        // groupKeySetIDs Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupKeyManagementKeySetReadAllIndicesResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadAllIndices::Type mRequest;
};

/*
 * Command KeySetRemove
 */
class GroupKeyManagementKeySetRemove : public ModelCommand
{
public:
    GroupKeyManagementKeySetRemove() : ModelCommand("key-set-remove")
    {
        AddArgument("GroupKeySetID", 0, UINT16_MAX, &mRequest.groupKeySetID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::GroupKeyManagement::Commands::KeySetRemove::Type mRequest;
};

/*
 * Command KeySetWrite
 */
class GroupKeyManagementKeySetWrite : public ModelCommand
{
public:
    GroupKeyManagementKeySetWrite() : ModelCommand("key-set-write")
    {
        // groupKeySet Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventGroupKeyManagementWildcard : public ModelCommand
{
public:
    ReadEventGroupKeyManagementWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventGroupKeyManagementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003F, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventGroupKeyManagementWildcard : public ModelCommand
{
public:
    ReportEventGroupKeyManagementWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventGroupKeyManagementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003F, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadGroupKeyManagementWildcard : public ModelCommand
{
public:
    ReadGroupKeyManagementWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003F, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementWildcard : public ModelCommand
{
public:
    ReportGroupKeyManagementWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003F, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GroupKeyMap
 */
class ReadGroupKeyManagementGroupKeyMap : public ModelCommand
{
public:
    ReadGroupKeyManagementGroupKeyMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "group-key-map");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003F, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.GroupKeyMap report", 0, value);
    }
};

class ReportGroupKeyManagementGroupKeyMap : public ModelCommand
{
public:
    ReportGroupKeyManagementGroupKeyMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "group-key-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003F, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.GroupKeyMap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GroupTable
 */
class ReadGroupKeyManagementGroupTable : public ModelCommand
{
public:
    ReadGroupKeyManagementGroupTable() : ModelCommand("read")
    {
        AddArgument("attr-name", "group-table");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupTable() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003F, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.GroupTable report", 0, value);
    }
};

class ReportGroupKeyManagementGroupTable : public ModelCommand
{
public:
    ReportGroupKeyManagementGroupTable() : ModelCommand("report")
    {
        AddArgument("attr-name", "group-table");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementGroupTable() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003F, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.GroupTable report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxGroupsPerFabric
 */
class ReadGroupKeyManagementMaxGroupsPerFabric : public ModelCommand
{
public:
    ReadGroupKeyManagementMaxGroupsPerFabric() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-groups-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementMaxGroupsPerFabric() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003F, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.MaxGroupsPerFabric report", 0, value);
    }
};

/*
 * Attribute MaxGroupKeysPerFabric
 */
class ReadGroupKeyManagementMaxGroupKeysPerFabric : public ModelCommand
{
public:
    ReadGroupKeyManagementMaxGroupKeysPerFabric() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-group-keys-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementMaxGroupKeysPerFabric() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003F, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.MaxGroupKeysPerFabric report", 0, value);
    }
};

/*
 * Attribute AttributeList
 */
class ReadGroupKeyManagementAttributeList : public ModelCommand
{
public:
    ReadGroupKeyManagementAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003F, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupKeyManagementClusterRevision : public ModelCommand
{
public:
    ReadGroupKeyManagementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003F, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.ClusterRevision report", 0, value);
    }
};

class ReportGroupKeyManagementClusterRevision : public ModelCommand
{
public:
    ReportGroupKeyManagementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003F, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("GroupKeyManagement.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Groups                                                      | 0x0004 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddGroup                                                          |   0x00 |
| * AddGroupIfIdentifying                                             |   0x05 |
| * GetGroupMembership                                                |   0x02 |
| * RemoveAllGroups                                                   |   0x04 |
| * RemoveGroup                                                       |   0x03 |
| * ViewGroup                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NameSupport                                                       | 0x0000 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddGroup
 */
class GroupsAddGroup : public ModelCommand
{
public:
    GroupsAddGroup() : ModelCommand("add-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("GroupName", &mRequest.groupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupsAddGroupResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Groups::Commands::AddGroup::Type mRequest;
};

/*
 * Command AddGroupIfIdentifying
 */
class GroupsAddGroupIfIdentifying : public ModelCommand
{
public:
    GroupsAddGroupIfIdentifying() : ModelCommand("add-group-if-identifying")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("GroupName", &mRequest.groupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000005) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Groups::Commands::AddGroupIfIdentifying::Type mRequest;
};

/*
 * Command GetGroupMembership
 */
class GroupsGetGroupMembership : public ModelCommand
{
public:
    GroupsGetGroupMembership() : ModelCommand("get-group-membership")
    {
        // groupList Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupsGetGroupMembershipResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Groups::Commands::GetGroupMembership::Type mRequest;
};

/*
 * Command RemoveAllGroups
 */
class GroupsRemoveAllGroups : public ModelCommand
{
public:
    GroupsRemoveAllGroups() : ModelCommand("remove-all-groups") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type mRequest;
};

/*
 * Command RemoveGroup
 */
class GroupsRemoveGroup : public ModelCommand
{
public:
    GroupsRemoveGroup() : ModelCommand("remove-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupsRemoveGroupResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Groups::Commands::RemoveGroup::Type mRequest;
};

/*
 * Command ViewGroup
 */
class GroupsViewGroup : public ModelCommand
{
public:
    GroupsViewGroup() : ModelCommand("view-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupsViewGroupResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Groups::Commands::ViewGroup::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventGroupsWildcard : public ModelCommand
{
public:
    ReadEventGroupsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventGroupsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000004, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventGroupsWildcard : public ModelCommand
{
public:
    ReportEventGroupsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventGroupsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000004, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadGroupsWildcard : public ModelCommand
{
public:
    ReadGroupsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000004, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportGroupsWildcard : public ModelCommand
{
public:
    ReportGroupsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000004, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NameSupport
 */
class ReadGroupsNameSupport : public ModelCommand
{
public:
    ReadGroupsNameSupport() : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsNameSupport() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000004, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Groups.NameSupport report", 0, value);
    }
};

class ReportGroupsNameSupport : public ModelCommand
{
public:
    ReportGroupsNameSupport() : ModelCommand("report")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsNameSupport() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000004, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Groups.NameSupport report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGroupsAttributeList : public ModelCommand
{
public:
    ReadGroupsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000004, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Groups.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupsClusterRevision : public ModelCommand
{
public:
    ReadGroupsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000004, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Groups.ClusterRevision report", 0, value);
    }
};

class ReportGroupsClusterRevision : public ModelCommand
{
public:
    ReportGroupsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000004, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Groups.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Identify                                                    | 0x0003 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Identify                                                          |   0x00 |
| * IdentifyQuery                                                     |   0x01 |
| * TriggerEffect                                                     |   0x40 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * IdentifyTime                                                      | 0x0000 |
| * IdentifyType                                                      | 0x0001 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Identify
 */
class IdentifyIdentify : public ModelCommand
{
public:
    IdentifyIdentify() : ModelCommand("identify")
    {
        AddArgument("IdentifyTime", 0, UINT16_MAX, &mRequest.identifyTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Identify::Commands::Identify::Type mRequest;
};

/*
 * Command IdentifyQuery
 */
class IdentifyIdentifyQuery : public ModelCommand
{
public:
    IdentifyIdentifyQuery() : ModelCommand("identify-query") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnIdentifyIdentifyQueryResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Identify::Commands::IdentifyQuery::Type mRequest;
};

/*
 * Command TriggerEffect
 */
class IdentifyTriggerEffect : public ModelCommand
{
public:
    IdentifyTriggerEffect() : ModelCommand("trigger-effect")
    {
        AddArgument("EffectIdentifier", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.effectIdentifier)> *>(&mRequest.effectIdentifier));
        AddArgument("EffectVariant", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.effectVariant)> *>(&mRequest.effectVariant));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000040) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Identify::Commands::TriggerEffect::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventIdentifyWildcard : public ModelCommand
{
public:
    ReadEventIdentifyWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventIdentifyWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000003, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventIdentifyWildcard : public ModelCommand
{
public:
    ReportEventIdentifyWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventIdentifyWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000003, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadIdentifyWildcard : public ModelCommand
{
public:
    ReadIdentifyWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000003, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportIdentifyWildcard : public ModelCommand
{
public:
    ReportIdentifyWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000003, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute IdentifyTime
 */
class ReadIdentifyIdentifyTime : public ModelCommand
{
public:
    ReadIdentifyIdentifyTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-time");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000003, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Identify.IdentifyTime report", 0, value);
    }
};

class WriteIdentifyIdentifyTime : public ModelCommand
{
public:
    WriteIdentifyIdentifyTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000003, 0x00000000, mValue);
    }

private:
    uint16_t mValue;
};

class ReportIdentifyIdentifyTime : public ModelCommand
{
public:
    ReportIdentifyIdentifyTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000003, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Identify.IdentifyTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute IdentifyType
 */
class ReadIdentifyIdentifyType : public ModelCommand
{
public:
    ReadIdentifyIdentifyType() : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-type");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000003, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Identify.IdentifyType report", 0, value);
    }
};

class ReportIdentifyIdentifyType : public ModelCommand
{
public:
    ReportIdentifyIdentifyType() : ModelCommand("report")
    {
        AddArgument("attr-name", "identify-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyIdentifyType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000003, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Identify.IdentifyType report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadIdentifyAttributeList : public ModelCommand
{
public:
    ReadIdentifyAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000003, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Identify.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadIdentifyClusterRevision : public ModelCommand
{
public:
    ReadIdentifyClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000003, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Identify.ClusterRevision report", 0, value);
    }
};

class ReportIdentifyClusterRevision : public ModelCommand
{
public:
    ReportIdentifyClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000003, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Identify.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster IlluminanceMeasurement                                      | 0x0400 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * LightSensorType                                                   | 0x0004 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventIlluminanceMeasurementWildcard : public ModelCommand
{
public:
    ReadEventIlluminanceMeasurementWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventIlluminanceMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000400, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventIlluminanceMeasurementWildcard : public ModelCommand
{
public:
    ReportEventIlluminanceMeasurementWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventIlluminanceMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000400, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadIlluminanceMeasurementWildcard : public ModelCommand
{
public:
    ReadIlluminanceMeasurementWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000400, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementWildcard : public ModelCommand
{
public:
    ReportIlluminanceMeasurementWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000400, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeasuredValue
 */
class ReadIlluminanceMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadIlluminanceMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000400, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.MeasuredValue report", 0, value);
    }
};

class ReportIlluminanceMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportIlluminanceMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000400, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.MeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadIlluminanceMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadIlluminanceMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000400, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.MinMeasuredValue report", 0, value);
    }
};

class ReportIlluminanceMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportIlluminanceMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000400, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.MinMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadIlluminanceMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadIlluminanceMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000400, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.MaxMeasuredValue report", 0, value);
    }
};

class ReportIlluminanceMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportIlluminanceMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000400, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.MaxMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadIlluminanceMeasurementTolerance : public ModelCommand
{
public:
    ReadIlluminanceMeasurementTolerance() : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementTolerance() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000400, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.Tolerance report", 0, value);
    }
};

class ReportIlluminanceMeasurementTolerance : public ModelCommand
{
public:
    ReportIlluminanceMeasurementTolerance() : ModelCommand("report")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementTolerance() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000400, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.Tolerance report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LightSensorType
 */
class ReadIlluminanceMeasurementLightSensorType : public ModelCommand
{
public:
    ReadIlluminanceMeasurementLightSensorType() : ModelCommand("read")
    {
        AddArgument("attr-name", "light-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementLightSensorType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000400, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.LightSensorType report", 0, value);
    }
};

class ReportIlluminanceMeasurementLightSensorType : public ModelCommand
{
public:
    ReportIlluminanceMeasurementLightSensorType() : ModelCommand("report")
    {
        AddArgument("attr-name", "light-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementLightSensorType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000400, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.LightSensorType report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadIlluminanceMeasurementAttributeList : public ModelCommand
{
public:
    ReadIlluminanceMeasurementAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000400, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadIlluminanceMeasurementClusterRevision : public ModelCommand
{
public:
    ReadIlluminanceMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000400, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.ClusterRevision report", 0, value);
    }
};

class ReportIlluminanceMeasurementClusterRevision : public ModelCommand
{
public:
    ReportIlluminanceMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000400, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("IlluminanceMeasurement.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster KeypadInput                                                 | 0x0509 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SendKeyRequest                                                    |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command SendKeyRequest
 */
class KeypadInputSendKeyRequest : public ModelCommand
{
public:
    KeypadInputSendKeyRequest() : ModelCommand("send-key-request")
    {
        AddArgument("KeyCode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.keyCode)> *>(&mRequest.keyCode));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnKeypadInputSendKeyResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::KeypadInput::Commands::SendKeyRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventKeypadInputWildcard : public ModelCommand
{
public:
    ReadEventKeypadInputWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventKeypadInputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000509, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventKeypadInputWildcard : public ModelCommand
{
public:
    ReportEventKeypadInputWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventKeypadInputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000509, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadKeypadInputWildcard : public ModelCommand
{
public:
    ReadKeypadInputWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000509, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportKeypadInputWildcard : public ModelCommand
{
public:
    ReportKeypadInputWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportKeypadInputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000509, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadKeypadInputAttributeList : public ModelCommand
{
public:
    ReadKeypadInputAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000509, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("KeypadInput.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadKeypadInputClusterRevision : public ModelCommand
{
public:
    ReadKeypadInputClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000509, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("KeypadInput.ClusterRevision report", 0, value);
    }
};

class ReportKeypadInputClusterRevision : public ModelCommand
{
public:
    ReportKeypadInputClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportKeypadInputClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000509, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("KeypadInput.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LevelControl                                                | 0x0008 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Move                                                              |   0x01 |
| * MoveToLevel                                                       |   0x00 |
| * MoveToLevelWithOnOff                                              |   0x04 |
| * MoveWithOnOff                                                     |   0x05 |
| * Step                                                              |   0x02 |
| * StepWithOnOff                                                     |   0x06 |
| * Stop                                                              |   0x03 |
| * StopWithOnOff                                                     |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentLevel                                                      | 0x0000 |
| * RemainingTime                                                     | 0x0001 |
| * MinLevel                                                          | 0x0002 |
| * MaxLevel                                                          | 0x0003 |
| * CurrentFrequency                                                  | 0x0004 |
| * MinFrequency                                                      | 0x0005 |
| * MaxFrequency                                                      | 0x0006 |
| * Options                                                           | 0x000F |
| * OnOffTransitionTime                                               | 0x0010 |
| * OnLevel                                                           | 0x0011 |
| * OnTransitionTime                                                  | 0x0012 |
| * OffTransitionTime                                                 | 0x0013 |
| * DefaultMoveRate                                                   | 0x0014 |
| * StartUpCurrentLevel                                               | 0x4000 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Move
 */
class LevelControlMove : public ModelCommand
{
public:
    LevelControlMove() : ModelCommand("move")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT8_MAX, &mRequest.rate);
        AddArgument("OptionMask", 0, UINT8_MAX, &mRequest.optionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mRequest.optionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LevelControl::Commands::Move::Type mRequest;
};

/*
 * Command MoveToLevel
 */
class LevelControlMoveToLevel : public ModelCommand
{
public:
    LevelControlMoveToLevel() : ModelCommand("move-to-level")
    {
        AddArgument("Level", 0, UINT8_MAX, &mRequest.level);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mRequest.optionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mRequest.optionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type mRequest;
};

/*
 * Command MoveToLevelWithOnOff
 */
class LevelControlMoveToLevelWithOnOff : public ModelCommand
{
public:
    LevelControlMoveToLevelWithOnOff() : ModelCommand("move-to-level-with-on-off")
    {
        AddArgument("Level", 0, UINT8_MAX, &mRequest.level);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type mRequest;
};

/*
 * Command MoveWithOnOff
 */
class LevelControlMoveWithOnOff : public ModelCommand
{
public:
    LevelControlMoveWithOnOff() : ModelCommand("move-with-on-off")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT8_MAX, &mRequest.rate);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000005) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type mRequest;
};

/*
 * Command Step
 */
class LevelControlStep : public ModelCommand
{
public:
    LevelControlStep() : ModelCommand("step")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT8_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mRequest.optionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mRequest.optionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LevelControl::Commands::Step::Type mRequest;
};

/*
 * Command StepWithOnOff
 */
class LevelControlStepWithOnOff : public ModelCommand
{
public:
    LevelControlStepWithOnOff() : ModelCommand("step-with-on-off")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT8_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000006) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type mRequest;
};

/*
 * Command Stop
 */
class LevelControlStop : public ModelCommand
{
public:
    LevelControlStop() : ModelCommand("stop")
    {
        AddArgument("OptionMask", 0, UINT8_MAX, &mRequest.optionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mRequest.optionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LevelControl::Commands::Stop::Type mRequest;
};

/*
 * Command StopWithOnOff
 */
class LevelControlStopWithOnOff : public ModelCommand
{
public:
    LevelControlStopWithOnOff() : ModelCommand("stop-with-on-off") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000007) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventLevelControlWildcard : public ModelCommand
{
public:
    ReadEventLevelControlWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventLevelControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000008, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventLevelControlWildcard : public ModelCommand
{
public:
    ReportEventLevelControlWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventLevelControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000008, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadLevelControlWildcard : public ModelCommand
{
public:
    ReadLevelControlWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlWildcard : public ModelCommand
{
public:
    ReportLevelControlWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentLevel
 */
class ReadLevelControlCurrentLevel : public ModelCommand
{
public:
    ReadLevelControlCurrentLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.CurrentLevel report", 0, value);
    }
};

class ReportLevelControlCurrentLevel : public ModelCommand
{
public:
    ReportLevelControlCurrentLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlCurrentLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.CurrentLevel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadLevelControlRemainingTime : public ModelCommand
{
public:
    ReadLevelControlRemainingTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlRemainingTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.RemainingTime report", 0, value);
    }
};

class ReportLevelControlRemainingTime : public ModelCommand
{
public:
    ReportLevelControlRemainingTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlRemainingTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.RemainingTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinLevel
 */
class ReadLevelControlMinLevel : public ModelCommand
{
public:
    ReadLevelControlMinLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.MinLevel report", 0, value);
    }
};

class ReportLevelControlMinLevel : public ModelCommand
{
public:
    ReportLevelControlMinLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMinLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.MinLevel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxLevel
 */
class ReadLevelControlMaxLevel : public ModelCommand
{
public:
    ReadLevelControlMaxLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.MaxLevel report", 0, value);
    }
};

class ReportLevelControlMaxLevel : public ModelCommand
{
public:
    ReportLevelControlMaxLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMaxLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.MaxLevel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFrequency
 */
class ReadLevelControlCurrentFrequency : public ModelCommand
{
public:
    ReadLevelControlCurrentFrequency() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentFrequency() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.CurrentFrequency report", 0, value);
    }
};

class ReportLevelControlCurrentFrequency : public ModelCommand
{
public:
    ReportLevelControlCurrentFrequency() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlCurrentFrequency() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.CurrentFrequency report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinFrequency
 */
class ReadLevelControlMinFrequency : public ModelCommand
{
public:
    ReadLevelControlMinFrequency() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinFrequency() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.MinFrequency report", 0, value);
    }
};

class ReportLevelControlMinFrequency : public ModelCommand
{
public:
    ReportLevelControlMinFrequency() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMinFrequency() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.MinFrequency report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFrequency
 */
class ReadLevelControlMaxFrequency : public ModelCommand
{
public:
    ReadLevelControlMaxFrequency() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxFrequency() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.MaxFrequency report", 0, value);
    }
};

class ReportLevelControlMaxFrequency : public ModelCommand
{
public:
    ReportLevelControlMaxFrequency() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMaxFrequency() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.MaxFrequency report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Options
 */
class ReadLevelControlOptions : public ModelCommand
{
public:
    ReadLevelControlOptions() : ModelCommand("read")
    {
        AddArgument("attr-name", "options");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOptions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x0000000F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.Options report", 0, value);
    }
};

class WriteLevelControlOptions : public ModelCommand
{
public:
    WriteLevelControlOptions() : ModelCommand("write")
    {
        AddArgument("attr-name", "options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOptions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000008, 0x0000000F, mValue);
    }

private:
    uint8_t mValue;
};

class ReportLevelControlOptions : public ModelCommand
{
public:
    ReportLevelControlOptions() : ModelCommand("report")
    {
        AddArgument("attr-name", "options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOptions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x0000000F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.Options report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnOffTransitionTime
 */
class ReadLevelControlOnOffTransitionTime : public ModelCommand
{
public:
    ReadLevelControlOnOffTransitionTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.OnOffTransitionTime report", 0, value);
    }
};

class WriteLevelControlOnOffTransitionTime : public ModelCommand
{
public:
    WriteLevelControlOnOffTransitionTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000008, 0x00000010, mValue);
    }

private:
    uint16_t mValue;
};

class ReportLevelControlOnOffTransitionTime : public ModelCommand
{
public:
    ReportLevelControlOnOffTransitionTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.OnOffTransitionTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnLevel
 */
class ReadLevelControlOnLevel : public ModelCommand
{
public:
    ReadLevelControlOnLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.OnLevel report", 0, value);
    }
};

class WriteLevelControlOnLevel : public ModelCommand
{
public:
    WriteLevelControlOnLevel() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000008, 0x00000011, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint8_t> mValue;
};

class ReportLevelControlOnLevel : public ModelCommand
{
public:
    ReportLevelControlOnLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.OnLevel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTransitionTime
 */
class ReadLevelControlOnTransitionTime : public ModelCommand
{
public:
    ReadLevelControlOnTransitionTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.OnTransitionTime report", 0, value);
    }
};

class WriteLevelControlOnTransitionTime : public ModelCommand
{
public:
    WriteLevelControlOnTransitionTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000008, 0x00000012, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint16_t> mValue;
};

class ReportLevelControlOnTransitionTime : public ModelCommand
{
public:
    ReportLevelControlOnTransitionTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.OnTransitionTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffTransitionTime
 */
class ReadLevelControlOffTransitionTime : public ModelCommand
{
public:
    ReadLevelControlOffTransitionTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000013);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.OffTransitionTime report", 0, value);
    }
};

class WriteLevelControlOffTransitionTime : public ModelCommand
{
public:
    WriteLevelControlOffTransitionTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000008, 0x00000013, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint16_t> mValue;
};

class ReportLevelControlOffTransitionTime : public ModelCommand
{
public:
    ReportLevelControlOffTransitionTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000013, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.OffTransitionTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DefaultMoveRate
 */
class ReadLevelControlDefaultMoveRate : public ModelCommand
{
public:
    ReadLevelControlDefaultMoveRate() : ModelCommand("read")
    {
        AddArgument("attr-name", "default-move-rate");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00000014);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.DefaultMoveRate report", 0, value);
    }
};

class WriteLevelControlDefaultMoveRate : public ModelCommand
{
public:
    WriteLevelControlDefaultMoveRate() : ModelCommand("write")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000008, 0x00000014, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint8_t> mValue;
};

class ReportLevelControlDefaultMoveRate : public ModelCommand
{
public:
    ReportLevelControlDefaultMoveRate() : ModelCommand("report")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00000014, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.DefaultMoveRate report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpCurrentLevel
 */
class ReadLevelControlStartUpCurrentLevel : public ModelCommand
{
public:
    ReadLevelControlStartUpCurrentLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x00004000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.StartUpCurrentLevel report", 0, value);
    }
};

class WriteLevelControlStartUpCurrentLevel : public ModelCommand
{
public:
    WriteLevelControlStartUpCurrentLevel() : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000008, 0x00004000, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint8_t> mValue;
};

class ReportLevelControlStartUpCurrentLevel : public ModelCommand
{
public:
    ReportLevelControlStartUpCurrentLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x00004000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.StartUpCurrentLevel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadLevelControlAttributeList : public ModelCommand
{
public:
    ReadLevelControlAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadLevelControlFeatureMap : public ModelCommand
{
public:
    ReadLevelControlFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.FeatureMap report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadLevelControlClusterRevision : public ModelCommand
{
public:
    ReadLevelControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000008, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.ClusterRevision report", 0, value);
    }
};

class ReportLevelControlClusterRevision : public ModelCommand
{
public:
    ReportLevelControlClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000008, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LevelControl.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LocalizationConfiguration                                   | 0x002B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActiveLocale                                                      | 0x0001 |
| * SupportedLocales                                                  | 0x0002 |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventLocalizationConfigurationWildcard : public ModelCommand
{
public:
    ReadEventLocalizationConfigurationWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventLocalizationConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000002B, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventLocalizationConfigurationWildcard : public ModelCommand
{
public:
    ReportEventLocalizationConfigurationWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventLocalizationConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000002B, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadLocalizationConfigurationWildcard : public ModelCommand
{
public:
    ReadLocalizationConfigurationWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002B, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportLocalizationConfigurationWildcard : public ModelCommand
{
public:
    ReportLocalizationConfigurationWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLocalizationConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002B, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveLocale
 */
class ReadLocalizationConfigurationActiveLocale : public ModelCommand
{
public:
    ReadLocalizationConfigurationActiveLocale() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-locale");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002B, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LocalizationConfiguration.ActiveLocale report", 0, value);
    }
};

class WriteLocalizationConfigurationActiveLocale : public ModelCommand
{
public:
    WriteLocalizationConfigurationActiveLocale() : ModelCommand("write")
    {
        AddArgument("attr-name", "active-locale");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000002B, 0x00000001, mValue);
    }

private:
    chip::CharSpan mValue;
};

/*
 * Attribute SupportedLocales
 */
class ReadLocalizationConfigurationSupportedLocales : public ModelCommand
{
public:
    ReadLocalizationConfigurationSupportedLocales() : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-locales");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationSupportedLocales() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002B, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::CharSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LocalizationConfiguration.SupportedLocales report", 0, value);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster LowPower                                                    | 0x0508 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Sleep                                                             |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Sleep
 */
class LowPowerSleep : public ModelCommand
{
public:
    LowPowerSleep() : ModelCommand("sleep") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::LowPower::Commands::Sleep::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventLowPowerWildcard : public ModelCommand
{
public:
    ReadEventLowPowerWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventLowPowerWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000508, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventLowPowerWildcard : public ModelCommand
{
public:
    ReportEventLowPowerWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventLowPowerWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000508, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadLowPowerWildcard : public ModelCommand
{
public:
    ReadLowPowerWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000508, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportLowPowerWildcard : public ModelCommand
{
public:
    ReportLowPowerWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLowPowerWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000508, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadLowPowerAttributeList : public ModelCommand
{
public:
    ReadLowPowerAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000508, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LowPower.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadLowPowerClusterRevision : public ModelCommand
{
public:
    ReadLowPowerClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000508, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LowPower.ClusterRevision report", 0, value);
    }
};

class ReportLowPowerClusterRevision : public ModelCommand
{
public:
    ReportLowPowerClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLowPowerClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000508, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("LowPower.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaInput                                                  | 0x0507 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * HideInputStatusRequest                                            |   0x02 |
| * RenameInputRequest                                                |   0x03 |
| * SelectInputRequest                                                |   0x00 |
| * ShowInputStatusRequest                                            |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MediaInputList                                                    | 0x0000 |
| * CurrentMediaInput                                                 | 0x0001 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command HideInputStatusRequest
 */
class MediaInputHideInputStatusRequest : public ModelCommand
{
public:
    MediaInputHideInputStatusRequest() : ModelCommand("hide-input-status-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaInput::Commands::HideInputStatusRequest::Type mRequest;
};

/*
 * Command RenameInputRequest
 */
class MediaInputRenameInputRequest : public ModelCommand
{
public:
    MediaInputRenameInputRequest() : ModelCommand("rename-input-request")
    {
        AddArgument("Index", 0, UINT8_MAX, &mRequest.index);
        AddArgument("Name", &mRequest.name);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaInput::Commands::RenameInputRequest::Type mRequest;
};

/*
 * Command SelectInputRequest
 */
class MediaInputSelectInputRequest : public ModelCommand
{
public:
    MediaInputSelectInputRequest() : ModelCommand("select-input-request")
    {
        AddArgument("Index", 0, UINT8_MAX, &mRequest.index);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaInput::Commands::SelectInputRequest::Type mRequest;
};

/*
 * Command ShowInputStatusRequest
 */
class MediaInputShowInputStatusRequest : public ModelCommand
{
public:
    MediaInputShowInputStatusRequest() : ModelCommand("show-input-status-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaInput::Commands::ShowInputStatusRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventMediaInputWildcard : public ModelCommand
{
public:
    ReadEventMediaInputWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventMediaInputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000507, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventMediaInputWildcard : public ModelCommand
{
public:
    ReportEventMediaInputWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventMediaInputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000507, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadMediaInputWildcard : public ModelCommand
{
public:
    ReadMediaInputWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000507, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportMediaInputWildcard : public ModelCommand
{
public:
    ReportMediaInputWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000507, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MediaInputList
 */
class ReadMediaInputMediaInputList : public ModelCommand
{
public:
    ReadMediaInputMediaInputList() : ModelCommand("read")
    {
        AddArgument("attr-name", "media-input-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputMediaInputList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000507, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaInput.MediaInputList report", 0, value);
    }
};

class ReportMediaInputMediaInputList : public ModelCommand
{
public:
    ReportMediaInputMediaInputList() : ModelCommand("report")
    {
        AddArgument("attr-name", "media-input-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputMediaInputList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000507, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaInput.MediaInputList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMediaInput
 */
class ReadMediaInputCurrentMediaInput : public ModelCommand
{
public:
    ReadMediaInputCurrentMediaInput() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-media-input");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputCurrentMediaInput() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000507, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaInput.CurrentMediaInput report", 0, value);
    }
};

class ReportMediaInputCurrentMediaInput : public ModelCommand
{
public:
    ReportMediaInputCurrentMediaInput() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-media-input");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputCurrentMediaInput() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000507, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaInput.CurrentMediaInput report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadMediaInputAttributeList : public ModelCommand
{
public:
    ReadMediaInputAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000507, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaInput.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaInputClusterRevision : public ModelCommand
{
public:
    ReadMediaInputClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000507, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaInput.ClusterRevision report", 0, value);
    }
};

class ReportMediaInputClusterRevision : public ModelCommand
{
public:
    ReportMediaInputClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000507, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaInput.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaPlayback                                               | 0x0506 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * FastForwardRequest                                                |   0x07 |
| * NextRequest                                                       |   0x05 |
| * PauseRequest                                                      |   0x01 |
| * PlayRequest                                                       |   0x00 |
| * PreviousRequest                                                   |   0x04 |
| * RewindRequest                                                     |   0x06 |
| * SeekRequest                                                       |   0x0B |
| * SkipBackwardRequest                                               |   0x09 |
| * SkipForwardRequest                                                |   0x08 |
| * StartOverRequest                                                  |   0x03 |
| * StopRequest                                                       |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * PlaybackState                                                     | 0x0000 |
| * StartTime                                                         | 0x0001 |
| * Duration                                                          | 0x0002 |
| * PlaybackSpeed                                                     | 0x0004 |
| * SeekRangeEnd                                                      | 0x0005 |
| * SeekRangeStart                                                    | 0x0006 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command FastForwardRequest
 */
class MediaPlaybackFastForwardRequest : public ModelCommand
{
public:
    MediaPlaybackFastForwardRequest() : ModelCommand("fast-forward-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000007) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::FastForwardRequest::Type mRequest;
};

/*
 * Command NextRequest
 */
class MediaPlaybackNextRequest : public ModelCommand
{
public:
    MediaPlaybackNextRequest() : ModelCommand("next-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000005) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::NextRequest::Type mRequest;
};

/*
 * Command PauseRequest
 */
class MediaPlaybackPauseRequest : public ModelCommand
{
public:
    MediaPlaybackPauseRequest() : ModelCommand("pause-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::PauseRequest::Type mRequest;
};

/*
 * Command PlayRequest
 */
class MediaPlaybackPlayRequest : public ModelCommand
{
public:
    MediaPlaybackPlayRequest() : ModelCommand("play-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::PlayRequest::Type mRequest;
};

/*
 * Command PreviousRequest
 */
class MediaPlaybackPreviousRequest : public ModelCommand
{
public:
    MediaPlaybackPreviousRequest() : ModelCommand("previous-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::PreviousRequest::Type mRequest;
};

/*
 * Command RewindRequest
 */
class MediaPlaybackRewindRequest : public ModelCommand
{
public:
    MediaPlaybackRewindRequest() : ModelCommand("rewind-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000006) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::RewindRequest::Type mRequest;
};

/*
 * Command SeekRequest
 */
class MediaPlaybackSeekRequest : public ModelCommand
{
public:
    MediaPlaybackSeekRequest() : ModelCommand("seek-request")
    {
        AddArgument("Position", 0, UINT64_MAX, &mRequest.position);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::SeekRequest::Type mRequest;
};

/*
 * Command SkipBackwardRequest
 */
class MediaPlaybackSkipBackwardRequest : public ModelCommand
{
public:
    MediaPlaybackSkipBackwardRequest() : ModelCommand("skip-backward-request")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mRequest.deltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000009) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::SkipBackwardRequest::Type mRequest;
};

/*
 * Command SkipForwardRequest
 */
class MediaPlaybackSkipForwardRequest : public ModelCommand
{
public:
    MediaPlaybackSkipForwardRequest() : ModelCommand("skip-forward-request")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mRequest.deltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000008) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::SkipForwardRequest::Type mRequest;
};

/*
 * Command StartOverRequest
 */
class MediaPlaybackStartOverRequest : public ModelCommand
{
public:
    MediaPlaybackStartOverRequest() : ModelCommand("start-over-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::StartOverRequest::Type mRequest;
};

/*
 * Command StopRequest
 */
class MediaPlaybackStopRequest : public ModelCommand
{
public:
    MediaPlaybackStopRequest() : ModelCommand("stop-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackPlaybackResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::StopRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventMediaPlaybackWildcard : public ModelCommand
{
public:
    ReadEventMediaPlaybackWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventMediaPlaybackWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000506, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventMediaPlaybackWildcard : public ModelCommand
{
public:
    ReportEventMediaPlaybackWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventMediaPlaybackWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000506, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadMediaPlaybackWildcard : public ModelCommand
{
public:
    ReadMediaPlaybackWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackWildcard : public ModelCommand
{
public:
    ReportMediaPlaybackWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000506, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PlaybackState
 */
class ReadMediaPlaybackPlaybackState : public ModelCommand
{
public:
    ReadMediaPlaybackPlaybackState() : ModelCommand("read")
    {
        AddArgument("attr-name", "playback-state");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPlaybackState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.PlaybackState report", 0, value);
    }
};

class ReportMediaPlaybackPlaybackState : public ModelCommand
{
public:
    ReportMediaPlaybackPlaybackState() : ModelCommand("report")
    {
        AddArgument("attr-name", "playback-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackPlaybackState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000506, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.PlaybackState report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartTime
 */
class ReadMediaPlaybackStartTime : public ModelCommand
{
public:
    ReadMediaPlaybackStartTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-time");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackStartTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.StartTime report", 0, value);
    }
};

class ReportMediaPlaybackStartTime : public ModelCommand
{
public:
    ReportMediaPlaybackStartTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackStartTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000506, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.StartTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Duration
 */
class ReadMediaPlaybackDuration : public ModelCommand
{
public:
    ReadMediaPlaybackDuration() : ModelCommand("read")
    {
        AddArgument("attr-name", "duration");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackDuration() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.Duration report", 0, value);
    }
};

class ReportMediaPlaybackDuration : public ModelCommand
{
public:
    ReportMediaPlaybackDuration() : ModelCommand("report")
    {
        AddArgument("attr-name", "duration");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackDuration() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000506, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.Duration report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PlaybackSpeed
 */
class ReadMediaPlaybackPlaybackSpeed : public ModelCommand
{
public:
    ReadMediaPlaybackPlaybackSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "playback-speed");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPlaybackSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        float value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.PlaybackSpeed report", 0, value);
    }
};

/*
 * Attribute SeekRangeEnd
 */
class ReadMediaPlaybackSeekRangeEnd : public ModelCommand
{
public:
    ReadMediaPlaybackSeekRangeEnd() : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-end");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeEnd() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.SeekRangeEnd report", 0, value);
    }
};

class ReportMediaPlaybackSeekRangeEnd : public ModelCommand
{
public:
    ReportMediaPlaybackSeekRangeEnd() : ModelCommand("report")
    {
        AddArgument("attr-name", "seek-range-end");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackSeekRangeEnd() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000506, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.SeekRangeEnd report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeStart
 */
class ReadMediaPlaybackSeekRangeStart : public ModelCommand
{
public:
    ReadMediaPlaybackSeekRangeStart() : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-start");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeStart() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.SeekRangeStart report", 0, value);
    }
};

class ReportMediaPlaybackSeekRangeStart : public ModelCommand
{
public:
    ReportMediaPlaybackSeekRangeStart() : ModelCommand("report")
    {
        AddArgument("attr-name", "seek-range-start");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackSeekRangeStart() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000506, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.SeekRangeStart report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadMediaPlaybackAttributeList : public ModelCommand
{
public:
    ReadMediaPlaybackAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaPlaybackClusterRevision : public ModelCommand
{
public:
    ReadMediaPlaybackClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000506, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.ClusterRevision report", 0, value);
    }
};

class ReportMediaPlaybackClusterRevision : public ModelCommand
{
public:
    ReportMediaPlaybackClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000506, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("MediaPlayback.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ModeSelect                                                  | 0x0050 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeToMode                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentMode                                                       | 0x0000 |
| * SupportedModes                                                    | 0x0001 |
| * OnMode                                                            | 0x0002 |
| * StartUpMode                                                       | 0x0003 |
| * Description                                                       | 0x0004 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeToMode
 */
class ModeSelectChangeToMode : public ModelCommand
{
public:
    ModeSelectChangeToMode() : ModelCommand("change-to-mode")
    {
        AddArgument("NewMode", 0, UINT8_MAX, &mRequest.newMode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventModeSelectWildcard : public ModelCommand
{
public:
    ReadEventModeSelectWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventModeSelectWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000050, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventModeSelectWildcard : public ModelCommand
{
public:
    ReportEventModeSelectWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventModeSelectWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000050, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadModeSelectWildcard : public ModelCommand
{
public:
    ReadModeSelectWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000050, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectWildcard : public ModelCommand
{
public:
    ReportModeSelectWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000050, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMode
 */
class ReadModeSelectCurrentMode : public ModelCommand
{
public:
    ReadModeSelectCurrentMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectCurrentMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000050, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.CurrentMode report", 0, value);
    }
};

class ReportModeSelectCurrentMode : public ModelCommand
{
public:
    ReportModeSelectCurrentMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectCurrentMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000050, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.CurrentMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedModes
 */
class ReadModeSelectSupportedModes : public ModelCommand
{
public:
    ReadModeSelectSupportedModes() : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-modes");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectSupportedModes() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000050, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.SupportedModes report", 0, value);
    }
};

class ReportModeSelectSupportedModes : public ModelCommand
{
public:
    ReportModeSelectSupportedModes() : ModelCommand("report")
    {
        AddArgument("attr-name", "supported-modes");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectSupportedModes() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000050, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.SupportedModes report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnMode
 */
class ReadModeSelectOnMode : public ModelCommand
{
public:
    ReadModeSelectOnMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectOnMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000050, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.OnMode report", 0, value);
    }
};

class WriteModeSelectOnMode : public ModelCommand
{
public:
    WriteModeSelectOnMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteModeSelectOnMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000050, 0x00000002, mValue);
    }

private:
    uint8_t mValue;
};

class ReportModeSelectOnMode : public ModelCommand
{
public:
    ReportModeSelectOnMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectOnMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000050, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.OnMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpMode
 */
class ReadModeSelectStartUpMode : public ModelCommand
{
public:
    ReadModeSelectStartUpMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000050, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.StartUpMode report", 0, value);
    }
};

class ReportModeSelectStartUpMode : public ModelCommand
{
public:
    ReportModeSelectStartUpMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-up-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000050, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.StartUpMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadModeSelectDescription : public ModelCommand
{
public:
    ReadModeSelectDescription() : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectDescription() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000050, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.Description report", 0, value);
    }
};

class ReportModeSelectDescription : public ModelCommand
{
public:
    ReportModeSelectDescription() : ModelCommand("report")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectDescription() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000050, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.Description report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadModeSelectAttributeList : public ModelCommand
{
public:
    ReadModeSelectAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000050, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadModeSelectClusterRevision : public ModelCommand
{
public:
    ReadModeSelectClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000050, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.ClusterRevision report", 0, value);
    }
};

class ReportModeSelectClusterRevision : public ModelCommand
{
public:
    ReportModeSelectClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000050, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ModeSelect.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster NetworkCommissioning                                        | 0x0031 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddOrUpdateThreadNetwork                                          |   0x03 |
| * AddOrUpdateWiFiNetwork                                            |   0x02 |
| * ConnectNetwork                                                    |   0x06 |
| * RemoveNetwork                                                     |   0x04 |
| * ReorderNetwork                                                    |   0x08 |
| * ScanNetworks                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxNetworks                                                       | 0x0000 |
| * Networks                                                          | 0x0001 |
| * ScanMaxTimeSeconds                                                | 0x0002 |
| * ConnectMaxTimeSeconds                                             | 0x0003 |
| * InterfaceEnabled                                                  | 0x0004 |
| * LastNetworkingStatus                                              | 0x0005 |
| * LastNetworkID                                                     | 0x0006 |
| * LastConnectErrorValue                                             | 0x0007 |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddOrUpdateThreadNetwork
 */
class NetworkCommissioningAddOrUpdateThreadNetwork : public ModelCommand
{
public:
    NetworkCommissioningAddOrUpdateThreadNetwork() : ModelCommand("add-or-update-thread-network")
    {
        AddArgument("OperationalDataset", &mRequest.operationalDataset);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningNetworkConfigResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::AddOrUpdateThreadNetwork::Type mRequest;
};

/*
 * Command AddOrUpdateWiFiNetwork
 */
class NetworkCommissioningAddOrUpdateWiFiNetwork : public ModelCommand
{
public:
    NetworkCommissioningAddOrUpdateWiFiNetwork() : ModelCommand("add-or-update-wi-fi-network")
    {
        AddArgument("Ssid", &mRequest.ssid);
        AddArgument("Credentials", &mRequest.credentials);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningNetworkConfigResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::AddOrUpdateWiFiNetwork::Type mRequest;
};

/*
 * Command ConnectNetwork
 */
class NetworkCommissioningConnectNetwork : public ModelCommand
{
public:
    NetworkCommissioningConnectNetwork() : ModelCommand("connect-network")
    {
        AddArgument("NetworkID", &mRequest.networkID);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000006) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningConnectNetworkResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::ConnectNetwork::Type mRequest;
};

/*
 * Command RemoveNetwork
 */
class NetworkCommissioningRemoveNetwork : public ModelCommand
{
public:
    NetworkCommissioningRemoveNetwork() : ModelCommand("remove-network")
    {
        AddArgument("NetworkID", &mRequest.networkID);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningNetworkConfigResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::RemoveNetwork::Type mRequest;
};

/*
 * Command ReorderNetwork
 */
class NetworkCommissioningReorderNetwork : public ModelCommand
{
public:
    NetworkCommissioningReorderNetwork() : ModelCommand("reorder-network")
    {
        AddArgument("NetworkID", &mRequest.networkID);
        AddArgument("NetworkIndex", 0, UINT8_MAX, &mRequest.networkIndex);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000008) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningNetworkConfigResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::ReorderNetwork::Type mRequest;
};

/*
 * Command ScanNetworks
 */
class NetworkCommissioningScanNetworks : public ModelCommand
{
public:
    NetworkCommissioningScanNetworks() : ModelCommand("scan-networks")
    {
        AddArgument("Ssid", &mRequest.ssid);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningScanNetworksResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::ScanNetworks::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventNetworkCommissioningWildcard : public ModelCommand
{
public:
    ReadEventNetworkCommissioningWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventNetworkCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000031, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventNetworkCommissioningWildcard : public ModelCommand
{
public:
    ReportEventNetworkCommissioningWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventNetworkCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000031, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadNetworkCommissioningWildcard : public ModelCommand
{
public:
    ReadNetworkCommissioningWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningWildcard : public ModelCommand
{
public:
    ReportNetworkCommissioningWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000031, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxNetworks
 */
class ReadNetworkCommissioningMaxNetworks : public ModelCommand
{
public:
    ReadNetworkCommissioningMaxNetworks() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-networks");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningMaxNetworks() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.MaxNetworks report", 0, value);
    }
};

/*
 * Attribute Networks
 */
class ReadNetworkCommissioningNetworks : public ModelCommand
{
public:
    ReadNetworkCommissioningNetworks() : ModelCommand("read")
    {
        AddArgument("attr-name", "networks");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningNetworks() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.Networks report", 0, value);
    }
};

/*
 * Attribute ScanMaxTimeSeconds
 */
class ReadNetworkCommissioningScanMaxTimeSeconds : public ModelCommand
{
public:
    ReadNetworkCommissioningScanMaxTimeSeconds() : ModelCommand("read")
    {
        AddArgument("attr-name", "scan-max-time-seconds");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningScanMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.ScanMaxTimeSeconds report", 0, value);
    }
};

/*
 * Attribute ConnectMaxTimeSeconds
 */
class ReadNetworkCommissioningConnectMaxTimeSeconds : public ModelCommand
{
public:
    ReadNetworkCommissioningConnectMaxTimeSeconds() : ModelCommand("read")
    {
        AddArgument("attr-name", "connect-max-time-seconds");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningConnectMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.ConnectMaxTimeSeconds report", 0, value);
    }
};

/*
 * Attribute InterfaceEnabled
 */
class ReadNetworkCommissioningInterfaceEnabled : public ModelCommand
{
public:
    ReadNetworkCommissioningInterfaceEnabled() : ModelCommand("read")
    {
        AddArgument("attr-name", "interface-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.InterfaceEnabled report", 0, value);
    }
};

class WriteNetworkCommissioningInterfaceEnabled : public ModelCommand
{
public:
    WriteNetworkCommissioningInterfaceEnabled() : ModelCommand("write")
    {
        AddArgument("attr-name", "interface-enabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000031, 0x00000004, mValue);
    }

private:
    bool mValue;
};

/*
 * Attribute LastNetworkingStatus
 */
class ReadNetworkCommissioningLastNetworkingStatus : public ModelCommand
{
public:
    ReadNetworkCommissioningLastNetworkingStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "last-networking-status");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastNetworkingStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatus value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.LastNetworkingStatus report", 0, value);
    }
};

/*
 * Attribute LastNetworkID
 */
class ReadNetworkCommissioningLastNetworkID : public ModelCommand
{
public:
    ReadNetworkCommissioningLastNetworkID() : ModelCommand("read")
    {
        AddArgument("attr-name", "last-network-id");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastNetworkID() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.LastNetworkID report", 0, value);
    }
};

/*
 * Attribute LastConnectErrorValue
 */
class ReadNetworkCommissioningLastConnectErrorValue : public ModelCommand
{
public:
    ReadNetworkCommissioningLastConnectErrorValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "last-connect-error-value");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastConnectErrorValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.LastConnectErrorValue report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadNetworkCommissioningFeatureMap : public ModelCommand
{
public:
    ReadNetworkCommissioningFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.FeatureMap report", 0, value);
    }
};

class ReportNetworkCommissioningFeatureMap : public ModelCommand
{
public:
    ReportNetworkCommissioningFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000031, 0x0000FFFC, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.FeatureMap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadNetworkCommissioningClusterRevision : public ModelCommand
{
public:
    ReadNetworkCommissioningClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000031, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.ClusterRevision report", 0, value);
    }
};

class ReportNetworkCommissioningClusterRevision : public ModelCommand
{
public:
    ReportNetworkCommissioningClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000031, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("NetworkCommissioning.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateProvider                                   | 0x0029 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ApplyUpdateRequest                                                |   0x02 |
| * NotifyUpdateApplied                                               |   0x04 |
| * QueryImage                                                        |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ApplyUpdateRequest
 */
class OtaSoftwareUpdateProviderApplyUpdateRequest : public ModelCommand
{
public:
    OtaSoftwareUpdateProviderApplyUpdateRequest() : ModelCommand("apply-update-request")
    {
        AddArgument("UpdateToken", &mRequest.updateToken);
        AddArgument("NewVersion", 0, UINT32_MAX, &mRequest.newVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOtaSoftwareUpdateProviderApplyUpdateResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateRequest::Type mRequest;
};

/*
 * Command NotifyUpdateApplied
 */
class OtaSoftwareUpdateProviderNotifyUpdateApplied : public ModelCommand
{
public:
    OtaSoftwareUpdateProviderNotifyUpdateApplied() : ModelCommand("notify-update-applied")
    {
        AddArgument("UpdateToken", &mRequest.updateToken);
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mRequest.softwareVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::NotifyUpdateApplied::Type mRequest;
};

/*
 * Command QueryImage
 */
class OtaSoftwareUpdateProviderQueryImage : public ModelCommand
{
public:
    OtaSoftwareUpdateProviderQueryImage() : ModelCommand("query-image")
    {
        AddArgument("VendorId", 0, UINT16_MAX, &mRequest.vendorId);
        AddArgument("ProductId", 0, UINT16_MAX, &mRequest.productId);
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mRequest.softwareVersion);
        // protocolsSupported Array parsing is not supported yet
        AddArgument("HardwareVersion", 0, UINT16_MAX, &mRequest.hardwareVersion);
        AddArgument("Location", &mRequest.location);
        AddArgument("RequestorCanConsent", 0, 1, &mRequest.requestorCanConsent);
        AddArgument("MetadataForProvider", &mRequest.metadataForProvider);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOtaSoftwareUpdateProviderQueryImageResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::QueryImage::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventOtaSoftwareUpdateProviderWildcard : public ModelCommand
{
public:
    ReadEventOtaSoftwareUpdateProviderWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventOtaSoftwareUpdateProviderWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000029, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventOtaSoftwareUpdateProviderWildcard : public ModelCommand
{
public:
    ReportEventOtaSoftwareUpdateProviderWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventOtaSoftwareUpdateProviderWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000029, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadOtaSoftwareUpdateProviderWildcard : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateProviderWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000029, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateProviderWildcard : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateProviderWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateProviderWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000029, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOtaSoftwareUpdateProviderAttributeList : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateProviderAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000029, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateProvider.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateProviderClusterRevision : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateProviderClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000029, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateProvider.ClusterRevision report", 0, value);
    }
};

class ReportOtaSoftwareUpdateProviderClusterRevision : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateProviderClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateProviderClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000029, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateProvider.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateRequestor                                  | 0x002A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AnnounceOtaProvider                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DefaultOtaProviders                                               | 0x0000 |
| * UpdatePossible                                                    | 0x0001 |
| * UpdateState                                                       | 0x0002 |
| * UpdateStateProgress                                               | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateTransition                                                   | 0x0000 |
| * VersionApplied                                                    | 0x0001 |
| * DownloadError                                                     | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command AnnounceOtaProvider
 */
class OtaSoftwareUpdateRequestorAnnounceOtaProvider : public ModelCommand
{
public:
    OtaSoftwareUpdateRequestorAnnounceOtaProvider() : ModelCommand("announce-ota-provider")
    {
        AddArgument("ProviderNodeId", 0, UINT64_MAX, &mRequest.providerNodeId);
        AddArgument("VendorId", 0, UINT16_MAX, &mRequest.vendorId);
        AddArgument(
            "AnnouncementReason", 0, UINT8_MAX,
            reinterpret_cast<std::underlying_type_t<decltype(mRequest.announcementReason)> *>(&mRequest.announcementReason));
        AddArgument("MetadataForNode", &mRequest.metadataForNode);
        AddArgument("Endpoint", 0, UINT16_MAX, &mRequest.endpoint);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OtaSoftwareUpdateRequestor::Commands::AnnounceOtaProvider::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventOtaSoftwareUpdateRequestorWildcard : public ModelCommand
{
public:
    ReadEventOtaSoftwareUpdateRequestorWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventOtaSoftwareUpdateRequestorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000002A, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventOtaSoftwareUpdateRequestorWildcard : public ModelCommand
{
public:
    ReportEventOtaSoftwareUpdateRequestorWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventOtaSoftwareUpdateRequestorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000002A, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event StateTransition
 */
class ReadOtaSoftwareUpdateRequestorStateTransition : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorStateTransition() : ModelCommand("read-event")
    {
        AddArgument("event-name", "state-transition");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorStateTransition() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000002A, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::StateTransition::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.StateTransition report", 0, value);
    }
};

class ReportOtaSoftwareUpdateRequestorStateTransition : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorStateTransition() : ModelCommand("report-event")
    {
        AddArgument("event-name", "state-transition");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorStateTransition() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000002A, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::StateTransition::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.StateTransition report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event VersionApplied
 */
class ReadOtaSoftwareUpdateRequestorVersionApplied : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorVersionApplied() : ModelCommand("read-event")
    {
        AddArgument("event-name", "version-applied");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorVersionApplied() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000002A, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::VersionApplied::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.VersionApplied report", 0, value);
    }
};

class ReportOtaSoftwareUpdateRequestorVersionApplied : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorVersionApplied() : ModelCommand("report-event")
    {
        AddArgument("event-name", "version-applied");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorVersionApplied() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000002A, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::VersionApplied::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.VersionApplied report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event DownloadError
 */
class ReadOtaSoftwareUpdateRequestorDownloadError : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorDownloadError() : ModelCommand("read-event")
    {
        AddArgument("event-name", "download-error");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorDownloadError() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000002A, 0x00000002);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::DownloadError::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.DownloadError report", 0, value);
    }
};

class ReportOtaSoftwareUpdateRequestorDownloadError : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorDownloadError() : ModelCommand("report-event")
    {
        AddArgument("event-name", "download-error");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorDownloadError() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000002A, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Events::DownloadError::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.DownloadError report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadOtaSoftwareUpdateRequestorWildcard : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002A, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateRequestorWildcard : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002A, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DefaultOtaProviders
 */
class ReadOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorDefaultOtaProviders() : ModelCommand("read")
    {
        AddArgument("attr-name", "default-ota-providers");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002A, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<
            chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.DefaultOtaProviders report", 0, value);
    }
};

class ReportOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorDefaultOtaProviders() : ModelCommand("report")
    {
        AddArgument("attr-name", "default-ota-providers");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002A, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<
            chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.DefaultOtaProviders report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdatePossible
 */
class ReadOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorUpdatePossible() : ModelCommand("read")
    {
        AddArgument("attr-name", "update-possible");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdatePossible() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002A, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.UpdatePossible report", 0, value);
    }
};

class ReportOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorUpdatePossible() : ModelCommand("report")
    {
        AddArgument("attr-name", "update-possible");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorUpdatePossible() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002A, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.UpdatePossible report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdateState
 */
class ReadOtaSoftwareUpdateRequestorUpdateState : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorUpdateState() : ModelCommand("read")
    {
        AddArgument("attr-name", "update-state");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdateState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002A, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAUpdateStateEnum value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.UpdateState report", 0, value);
    }
};

class ReportOtaSoftwareUpdateRequestorUpdateState : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorUpdateState() : ModelCommand("report")
    {
        AddArgument("attr-name", "update-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorUpdateState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002A, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAUpdateStateEnum value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.UpdateState report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdateStateProgress
 */
class ReadOtaSoftwareUpdateRequestorUpdateStateProgress : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorUpdateStateProgress() : ModelCommand("read")
    {
        AddArgument("attr-name", "update-state-progress");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdateStateProgress() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002A, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.UpdateStateProgress report", 0, value);
    }
};

class ReportOtaSoftwareUpdateRequestorUpdateStateProgress : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorUpdateStateProgress() : ModelCommand("report")
    {
        AddArgument("attr-name", "update-state-progress");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorUpdateStateProgress() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002A, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.UpdateStateProgress report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOtaSoftwareUpdateRequestorAttributeList : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002A, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002A, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.ClusterRevision report", 0, value);
    }
};

class ReportOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002A, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OtaSoftwareUpdateRequestor.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OccupancySensing                                            | 0x0406 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Occupancy                                                         | 0x0000 |
| * OccupancySensorType                                               | 0x0001 |
| * OccupancySensorTypeBitmap                                         | 0x0002 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventOccupancySensingWildcard : public ModelCommand
{
public:
    ReadEventOccupancySensingWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventOccupancySensingWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000406, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventOccupancySensingWildcard : public ModelCommand
{
public:
    ReportEventOccupancySensingWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventOccupancySensingWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000406, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadOccupancySensingWildcard : public ModelCommand
{
public:
    ReadOccupancySensingWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000406, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportOccupancySensingWildcard : public ModelCommand
{
public:
    ReportOccupancySensingWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000406, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Occupancy
 */
class ReadOccupancySensingOccupancy : public ModelCommand
{
public:
    ReadOccupancySensingOccupancy() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancy() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000406, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.Occupancy report", 0, value);
    }
};

class ReportOccupancySensingOccupancy : public ModelCommand
{
public:
    ReportOccupancySensingOccupancy() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupancy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancy() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000406, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.Occupancy report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorType
 */
class ReadOccupancySensingOccupancySensorType : public ModelCommand
{
public:
    ReadOccupancySensingOccupancySensorType() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000406, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.OccupancySensorType report", 0, value);
    }
};

class ReportOccupancySensingOccupancySensorType : public ModelCommand
{
public:
    ReportOccupancySensingOccupancySensorType() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancySensorType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000406, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.OccupancySensorType report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorTypeBitmap
 */
class ReadOccupancySensingOccupancySensorTypeBitmap : public ModelCommand
{
public:
    ReadOccupancySensingOccupancySensorTypeBitmap() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorTypeBitmap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000406, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.OccupancySensorTypeBitmap report", 0, value);
    }
};

class ReportOccupancySensingOccupancySensorTypeBitmap : public ModelCommand
{
public:
    ReportOccupancySensingOccupancySensorTypeBitmap() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancySensorTypeBitmap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000406, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.OccupancySensorTypeBitmap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOccupancySensingAttributeList : public ModelCommand
{
public:
    ReadOccupancySensingAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000406, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadOccupancySensingClusterRevision : public ModelCommand
{
public:
    ReadOccupancySensingClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000406, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.ClusterRevision report", 0, value);
    }
};

class ReportOccupancySensingClusterRevision : public ModelCommand
{
public:
    ReportOccupancySensingClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000406, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OccupancySensing.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOff                                                       | 0x0006 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Off                                                               |   0x00 |
| * OffWithEffect                                                     |   0x40 |
| * On                                                                |   0x01 |
| * OnWithRecallGlobalScene                                           |   0x41 |
| * OnWithTimedOff                                                    |   0x42 |
| * Toggle                                                            |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OnOff                                                             | 0x0000 |
| * GlobalSceneControl                                                | 0x4000 |
| * OnTime                                                            | 0x4001 |
| * OffWaitTime                                                       | 0x4002 |
| * StartUpOnOff                                                      | 0x4003 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Off
 */
class OnOffOff : public ModelCommand
{
public:
    OnOffOff() : ModelCommand("off") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OnOff::Commands::Off::Type mRequest;
};

/*
 * Command OffWithEffect
 */
class OnOffOffWithEffect : public ModelCommand
{
public:
    OnOffOffWithEffect() : ModelCommand("off-with-effect")
    {
        AddArgument("EffectId", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.effectId)> *>(&mRequest.effectId));
        AddArgument("EffectVariant", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.effectVariant)> *>(&mRequest.effectVariant));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000040) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OnOff::Commands::OffWithEffect::Type mRequest;
};

/*
 * Command On
 */
class OnOffOn : public ModelCommand
{
public:
    OnOffOn() : ModelCommand("on") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OnOff::Commands::On::Type mRequest;
};

/*
 * Command OnWithRecallGlobalScene
 */
class OnOffOnWithRecallGlobalScene : public ModelCommand
{
public:
    OnOffOnWithRecallGlobalScene() : ModelCommand("on-with-recall-global-scene") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000041) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type mRequest;
};

/*
 * Command OnWithTimedOff
 */
class OnOffOnWithTimedOff : public ModelCommand
{
public:
    OnOffOnWithTimedOff() : ModelCommand("on-with-timed-off")
    {
        AddArgument("OnOffControl", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<chip::app::Clusters::OnOff::OnOffControl> *>(&mRequest.onOffControl));
        AddArgument("OnTime", 0, UINT16_MAX, &mRequest.onTime);
        AddArgument("OffWaitTime", 0, UINT16_MAX, &mRequest.offWaitTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000042) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type mRequest;
};

/*
 * Command Toggle
 */
class OnOffToggle : public ModelCommand
{
public:
    OnOffToggle() : ModelCommand("toggle") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OnOff::Commands::Toggle::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventOnOffWildcard : public ModelCommand
{
public:
    ReadEventOnOffWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventOnOffWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000006, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventOnOffWildcard : public ModelCommand
{
public:
    ReportEventOnOffWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventOnOffWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000006, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadOnOffWildcard : public ModelCommand
{
public:
    ReadOnOffWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffWildcard : public ModelCommand
{
public:
    ReportOnOffWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000006, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnOff
 */
class ReadOnOffOnOff : public ModelCommand
{
public:
    ReadOnOffOnOff() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnOff() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.OnOff report", 0, value);
    }
};

class ReportOnOffOnOff : public ModelCommand
{
public:
    ReportOnOffOnOff() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOnOff() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000006, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.OnOff report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GlobalSceneControl
 */
class ReadOnOffGlobalSceneControl : public ModelCommand
{
public:
    ReadOnOffGlobalSceneControl() : ModelCommand("read")
    {
        AddArgument("attr-name", "global-scene-control");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffGlobalSceneControl() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, 0x00004000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.GlobalSceneControl report", 0, value);
    }
};

class ReportOnOffGlobalSceneControl : public ModelCommand
{
public:
    ReportOnOffGlobalSceneControl() : ModelCommand("report")
    {
        AddArgument("attr-name", "global-scene-control");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffGlobalSceneControl() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000006, 0x00004000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.GlobalSceneControl report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTime
 */
class ReadOnOffOnTime : public ModelCommand
{
public:
    ReadOnOffOnTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, 0x00004001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.OnTime report", 0, value);
    }
};

class WriteOnOffOnTime : public ModelCommand
{
public:
    WriteOnOffOnTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOnTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000006, 0x00004001, mValue);
    }

private:
    uint16_t mValue;
};

class ReportOnOffOnTime : public ModelCommand
{
public:
    ReportOnOffOnTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOnTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000006, 0x00004001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.OnTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffWaitTime
 */
class ReadOnOffOffWaitTime : public ModelCommand
{
public:
    ReadOnOffOffWaitTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "off-wait-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, 0x00004002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.OffWaitTime report", 0, value);
    }
};

class WriteOnOffOffWaitTime : public ModelCommand
{
public:
    WriteOnOffOffWaitTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000006, 0x00004002, mValue);
    }

private:
    uint16_t mValue;
};

class ReportOnOffOffWaitTime : public ModelCommand
{
public:
    ReportOnOffOffWaitTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000006, 0x00004002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.OffWaitTime report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpOnOff
 */
class ReadOnOffStartUpOnOff : public ModelCommand
{
public:
    ReadOnOffStartUpOnOff() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, 0x00004003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.StartUpOnOff report", 0, value);
    }
};

class WriteOnOffStartUpOnOff : public ModelCommand
{
public:
    WriteOnOffStartUpOnOff() : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000006, 0x00004003, mValue);
    }

private:
    uint8_t mValue;
};

class ReportOnOffStartUpOnOff : public ModelCommand
{
public:
    ReportOnOffStartUpOnOff() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000006, 0x00004003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.StartUpOnOff report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOnOffAttributeList : public ModelCommand
{
public:
    ReadOnOffAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadOnOffFeatureMap : public ModelCommand
{
public:
    ReadOnOffFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.FeatureMap report", 0, value);
    }
};

class ReportOnOffFeatureMap : public ModelCommand
{
public:
    ReportOnOffFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000006, 0x0000FFFC, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.FeatureMap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffClusterRevision : public ModelCommand
{
public:
    ReadOnOffClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000006, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.ClusterRevision report", 0, value);
    }
};

class ReportOnOffClusterRevision : public ModelCommand
{
public:
    ReportOnOffClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000006, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOff.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOffSwitchConfiguration                                    | 0x0007 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SwitchType                                                        | 0x0000 |
| * SwitchActions                                                     | 0x0010 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventOnOffSwitchConfigurationWildcard : public ModelCommand
{
public:
    ReadEventOnOffSwitchConfigurationWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventOnOffSwitchConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000007, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventOnOffSwitchConfigurationWildcard : public ModelCommand
{
public:
    ReportEventOnOffSwitchConfigurationWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventOnOffSwitchConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000007, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadOnOffSwitchConfigurationWildcard : public ModelCommand
{
public:
    ReadOnOffSwitchConfigurationWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000007, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffSwitchConfigurationWildcard : public ModelCommand
{
public:
    ReportOnOffSwitchConfigurationWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000007, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SwitchType
 */
class ReadOnOffSwitchConfigurationSwitchType : public ModelCommand
{
public:
    ReadOnOffSwitchConfigurationSwitchType() : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-type");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000007, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOffSwitchConfiguration.SwitchType report", 0, value);
    }
};

class ReportOnOffSwitchConfigurationSwitchType : public ModelCommand
{
public:
    ReportOnOffSwitchConfigurationSwitchType() : ModelCommand("report")
    {
        AddArgument("attr-name", "switch-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationSwitchType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000007, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOffSwitchConfiguration.SwitchType report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SwitchActions
 */
class ReadOnOffSwitchConfigurationSwitchActions : public ModelCommand
{
public:
    ReadOnOffSwitchConfigurationSwitchActions() : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-actions");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000007, 0x00000010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOffSwitchConfiguration.SwitchActions report", 0, value);
    }
};

class WriteOnOffSwitchConfigurationSwitchActions : public ModelCommand
{
public:
    WriteOnOffSwitchConfigurationSwitchActions() : ModelCommand("write")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000007, 0x00000010, mValue);
    }

private:
    uint8_t mValue;
};

class ReportOnOffSwitchConfigurationSwitchActions : public ModelCommand
{
public:
    ReportOnOffSwitchConfigurationSwitchActions() : ModelCommand("report")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000007, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOffSwitchConfiguration.SwitchActions report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOnOffSwitchConfigurationAttributeList : public ModelCommand
{
public:
    ReadOnOffSwitchConfigurationAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000007, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOffSwitchConfiguration.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffSwitchConfigurationClusterRevision : public ModelCommand
{
public:
    ReadOnOffSwitchConfigurationClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000007, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOffSwitchConfiguration.ClusterRevision report", 0, value);
    }
};

class ReportOnOffSwitchConfigurationClusterRevision : public ModelCommand
{
public:
    ReportOnOffSwitchConfigurationClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000007, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OnOffSwitchConfiguration.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OperationalCredentials                                      | 0x003E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddNOC                                                            |   0x06 |
| * AddTrustedRootCertificate                                         |   0x0B |
| * AttestationRequest                                                |   0x00 |
| * CertificateChainRequest                                           |   0x02 |
| * OpCSRRequest                                                      |   0x04 |
| * RemoveFabric                                                      |   0x0A |
| * RemoveTrustedRootCertificate                                      |   0x0C |
| * UpdateFabricLabel                                                 |   0x09 |
| * UpdateNOC                                                         |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * FabricsList                                                       | 0x0001 |
| * SupportedFabrics                                                  | 0x0002 |
| * CommissionedFabrics                                               | 0x0003 |
| * TrustedRootCertificates                                           | 0x0004 |
| * CurrentFabricIndex                                                | 0x0005 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddNOC
 */
class OperationalCredentialsAddNOC : public ModelCommand
{
public:
    OperationalCredentialsAddNOC() : ModelCommand("add-noc")
    {
        AddArgument("NOCValue", &mRequest.NOCValue);
        AddArgument("ICACValue", &mRequest.ICACValue);
        AddArgument("IPKValue", &mRequest.IPKValue);
        AddArgument("CaseAdminNode", 0, UINT64_MAX, &mRequest.caseAdminNode);
        AddArgument("AdminVendorId", 0, UINT16_MAX, &mRequest.adminVendorId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000006) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsNOCResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::AddNOC::Type mRequest;
};

/*
 * Command AddTrustedRootCertificate
 */
class OperationalCredentialsAddTrustedRootCertificate : public ModelCommand
{
public:
    OperationalCredentialsAddTrustedRootCertificate() : ModelCommand("add-trusted-root-certificate")
    {
        AddArgument("RootCertificate", &mRequest.rootCertificate);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::AddTrustedRootCertificate::Type mRequest;
};

/*
 * Command AttestationRequest
 */
class OperationalCredentialsAttestationRequest : public ModelCommand
{
public:
    OperationalCredentialsAttestationRequest() : ModelCommand("attestation-request")
    {
        AddArgument("AttestationNonce", &mRequest.attestationNonce);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsAttestationResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::AttestationRequest::Type mRequest;
};

/*
 * Command CertificateChainRequest
 */
class OperationalCredentialsCertificateChainRequest : public ModelCommand
{
public:
    OperationalCredentialsCertificateChainRequest() : ModelCommand("certificate-chain-request")
    {
        AddArgument("CertificateType", 0, UINT8_MAX, &mRequest.certificateType);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsCertificateChainResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::CertificateChainRequest::Type mRequest;
};

/*
 * Command OpCSRRequest
 */
class OperationalCredentialsOpCSRRequest : public ModelCommand
{
public:
    OperationalCredentialsOpCSRRequest() : ModelCommand("op-csrrequest")
    {
        AddArgument("CSRNonce", &mRequest.CSRNonce);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsOpCSRResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::OpCSRRequest::Type mRequest;
};

/*
 * Command RemoveFabric
 */
class OperationalCredentialsRemoveFabric : public ModelCommand
{
public:
    OperationalCredentialsRemoveFabric() : ModelCommand("remove-fabric")
    {
        AddArgument("FabricIndex", 0, UINT8_MAX, &mRequest.fabricIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsNOCResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::RemoveFabric::Type mRequest;
};

/*
 * Command RemoveTrustedRootCertificate
 */
class OperationalCredentialsRemoveTrustedRootCertificate : public ModelCommand
{
public:
    OperationalCredentialsRemoveTrustedRootCertificate() : ModelCommand("remove-trusted-root-certificate")
    {
        AddArgument("TrustedRootIdentifier", &mRequest.trustedRootIdentifier);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000C) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::RemoveTrustedRootCertificate::Type mRequest;
};

/*
 * Command UpdateFabricLabel
 */
class OperationalCredentialsUpdateFabricLabel : public ModelCommand
{
public:
    OperationalCredentialsUpdateFabricLabel() : ModelCommand("update-fabric-label")
    {
        AddArgument("Label", &mRequest.label);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000009) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsNOCResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::UpdateFabricLabel::Type mRequest;
};

/*
 * Command UpdateNOC
 */
class OperationalCredentialsUpdateNOC : public ModelCommand
{
public:
    OperationalCredentialsUpdateNOC() : ModelCommand("update-noc")
    {
        AddArgument("NOCValue", &mRequest.NOCValue);
        AddArgument("ICACValue", &mRequest.ICACValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000007) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsNOCResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::UpdateNOC::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventOperationalCredentialsWildcard : public ModelCommand
{
public:
    ReadEventOperationalCredentialsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventOperationalCredentialsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003E, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventOperationalCredentialsWildcard : public ModelCommand
{
public:
    ReportEventOperationalCredentialsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventOperationalCredentialsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003E, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadOperationalCredentialsWildcard : public ModelCommand
{
public:
    ReadOperationalCredentialsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003E, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsWildcard : public ModelCommand
{
public:
    ReportOperationalCredentialsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003E, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FabricsList
 */
class ReadOperationalCredentialsFabricsList : public ModelCommand
{
public:
    ReadOperationalCredentialsFabricsList() : ModelCommand("read")
    {
        AddArgument("attr-name", "fabrics-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsFabricsList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003E, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.FabricsList report", 0, value);
    }
};

class ReportOperationalCredentialsFabricsList : public ModelCommand
{
public:
    ReportOperationalCredentialsFabricsList() : ModelCommand("report")
    {
        AddArgument("attr-name", "fabrics-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsFabricsList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003E, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.FabricsList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedFabrics
 */
class ReadOperationalCredentialsSupportedFabrics : public ModelCommand
{
public:
    ReadOperationalCredentialsSupportedFabrics() : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsSupportedFabrics() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003E, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.SupportedFabrics report", 0, value);
    }
};

class ReportOperationalCredentialsSupportedFabrics : public ModelCommand
{
public:
    ReportOperationalCredentialsSupportedFabrics() : ModelCommand("report")
    {
        AddArgument("attr-name", "supported-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsSupportedFabrics() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003E, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.SupportedFabrics report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CommissionedFabrics
 */
class ReadOperationalCredentialsCommissionedFabrics : public ModelCommand
{
public:
    ReadOperationalCredentialsCommissionedFabrics() : ModelCommand("read")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCommissionedFabrics() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003E, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.CommissionedFabrics report", 0, value);
    }
};

class ReportOperationalCredentialsCommissionedFabrics : public ModelCommand
{
public:
    ReportOperationalCredentialsCommissionedFabrics() : ModelCommand("report")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsCommissionedFabrics() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003E, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.CommissionedFabrics report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TrustedRootCertificates
 */
class ReadOperationalCredentialsTrustedRootCertificates : public ModelCommand
{
public:
    ReadOperationalCredentialsTrustedRootCertificates() : ModelCommand("read")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsTrustedRootCertificates() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003E, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ByteSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.TrustedRootCertificates report", 0, value);
    }
};

class ReportOperationalCredentialsTrustedRootCertificates : public ModelCommand
{
public:
    ReportOperationalCredentialsTrustedRootCertificates() : ModelCommand("report")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsTrustedRootCertificates() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003E, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ByteSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.TrustedRootCertificates report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFabricIndex
 */
class ReadOperationalCredentialsCurrentFabricIndex : public ModelCommand
{
public:
    ReadOperationalCredentialsCurrentFabricIndex() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCurrentFabricIndex() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003E, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::FabricIndex value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.CurrentFabricIndex report", 0, value);
    }
};

class ReportOperationalCredentialsCurrentFabricIndex : public ModelCommand
{
public:
    ReportOperationalCredentialsCurrentFabricIndex() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-fabric-index");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsCurrentFabricIndex() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003E, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::FabricIndex value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.CurrentFabricIndex report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOperationalCredentialsAttributeList : public ModelCommand
{
public:
    ReadOperationalCredentialsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003E, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadOperationalCredentialsClusterRevision : public ModelCommand
{
public:
    ReadOperationalCredentialsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003E, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.ClusterRevision report", 0, value);
    }
};

class ReportOperationalCredentialsClusterRevision : public ModelCommand
{
public:
    ReportOperationalCredentialsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003E, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("OperationalCredentials.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSource                                                 | 0x002F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Status                                                            | 0x0000 |
| * Order                                                             | 0x0001 |
| * Description                                                       | 0x0002 |
| * BatteryVoltage                                                    | 0x000B |
| * BatteryPercentRemaining                                           | 0x000C |
| * BatteryTimeRemaining                                              | 0x000D |
| * BatteryChargeLevel                                                | 0x000E |
| * ActiveBatteryFaults                                               | 0x0012 |
| * BatteryChargeState                                                | 0x001A |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventPowerSourceWildcard : public ModelCommand
{
public:
    ReadEventPowerSourceWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventPowerSourceWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000002F, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventPowerSourceWildcard : public ModelCommand
{
public:
    ReportEventPowerSourceWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventPowerSourceWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000002F, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadPowerSourceWildcard : public ModelCommand
{
public:
    ReadPowerSourceWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceWildcard : public ModelCommand
{
public:
    ReportPowerSourceWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Status
 */
class ReadPowerSourceStatus : public ModelCommand
{
public:
    ReadPowerSourceStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "status");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.Status report", 0, value);
    }
};

class ReportPowerSourceStatus : public ModelCommand
{
public:
    ReportPowerSourceStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.Status report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Order
 */
class ReadPowerSourceOrder : public ModelCommand
{
public:
    ReadPowerSourceOrder() : ModelCommand("read")
    {
        AddArgument("attr-name", "order");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceOrder() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.Order report", 0, value);
    }
};

class ReportPowerSourceOrder : public ModelCommand
{
public:
    ReportPowerSourceOrder() : ModelCommand("report")
    {
        AddArgument("attr-name", "order");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceOrder() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.Order report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadPowerSourceDescription : public ModelCommand
{
public:
    ReadPowerSourceDescription() : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceDescription() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.Description report", 0, value);
    }
};

class ReportPowerSourceDescription : public ModelCommand
{
public:
    ReportPowerSourceDescription() : ModelCommand("report")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceDescription() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.Description report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryVoltage
 */
class ReadPowerSourceBatteryVoltage : public ModelCommand
{
public:
    ReadPowerSourceBatteryVoltage() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryVoltage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x0000000B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryVoltage report", 0, value);
    }
};

class ReportPowerSourceBatteryVoltage : public ModelCommand
{
public:
    ReportPowerSourceBatteryVoltage() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryVoltage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x0000000B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryVoltage report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryPercentRemaining
 */
class ReadPowerSourceBatteryPercentRemaining : public ModelCommand
{
public:
    ReadPowerSourceBatteryPercentRemaining() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryPercentRemaining() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x0000000C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryPercentRemaining report", 0, value);
    }
};

class ReportPowerSourceBatteryPercentRemaining : public ModelCommand
{
public:
    ReportPowerSourceBatteryPercentRemaining() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryPercentRemaining() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x0000000C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryPercentRemaining report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryTimeRemaining
 */
class ReadPowerSourceBatteryTimeRemaining : public ModelCommand
{
public:
    ReadPowerSourceBatteryTimeRemaining() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-time-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryTimeRemaining() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x0000000D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryTimeRemaining report", 0, value);
    }
};

class ReportPowerSourceBatteryTimeRemaining : public ModelCommand
{
public:
    ReportPowerSourceBatteryTimeRemaining() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-time-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryTimeRemaining() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x0000000D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryTimeRemaining report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeLevel
 */
class ReadPowerSourceBatteryChargeLevel : public ModelCommand
{
public:
    ReadPowerSourceBatteryChargeLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-level");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x0000000E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryChargeLevel report", 0, value);
    }
};

class ReportPowerSourceBatteryChargeLevel : public ModelCommand
{
public:
    ReportPowerSourceBatteryChargeLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-charge-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryChargeLevel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x0000000E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryChargeLevel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveBatteryFaults
 */
class ReadPowerSourceActiveBatteryFaults : public ModelCommand
{
public:
    ReadPowerSourceActiveBatteryFaults() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-battery-faults");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceActiveBatteryFaults() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.ActiveBatteryFaults report", 0, value);
    }
};

class ReportPowerSourceActiveBatteryFaults : public ModelCommand
{
public:
    ReportPowerSourceActiveBatteryFaults() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-battery-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceActiveBatteryFaults() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x00000012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.ActiveBatteryFaults report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeState
 */
class ReadPowerSourceBatteryChargeState : public ModelCommand
{
public:
    ReadPowerSourceBatteryChargeState() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-state");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x0000001A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryChargeState report", 0, value);
    }
};

class ReportPowerSourceBatteryChargeState : public ModelCommand
{
public:
    ReportPowerSourceBatteryChargeState() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-charge-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryChargeState() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x0000001A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.BatteryChargeState report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPowerSourceAttributeList : public ModelCommand
{
public:
    ReadPowerSourceAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadPowerSourceFeatureMap : public ModelCommand
{
public:
    ReadPowerSourceFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.FeatureMap report", 0, value);
    }
};

class ReportPowerSourceFeatureMap : public ModelCommand
{
public:
    ReportPowerSourceFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x0000FFFC, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.FeatureMap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceClusterRevision : public ModelCommand
{
public:
    ReadPowerSourceClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002F, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.ClusterRevision report", 0, value);
    }
};

class ReportPowerSourceClusterRevision : public ModelCommand
{
public:
    ReportPowerSourceClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002F, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSource.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSourceConfiguration                                    | 0x002E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Sources                                                           | 0x0000 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventPowerSourceConfigurationWildcard : public ModelCommand
{
public:
    ReadEventPowerSourceConfigurationWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventPowerSourceConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000002E, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventPowerSourceConfigurationWildcard : public ModelCommand
{
public:
    ReportEventPowerSourceConfigurationWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventPowerSourceConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000002E, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadPowerSourceConfigurationWildcard : public ModelCommand
{
public:
    ReadPowerSourceConfigurationWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002E, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceConfigurationWildcard : public ModelCommand
{
public:
    ReportPowerSourceConfigurationWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000002E, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Sources
 */
class ReadPowerSourceConfigurationSources : public ModelCommand
{
public:
    ReadPowerSourceConfigurationSources() : ModelCommand("read")
    {
        AddArgument("attr-name", "sources");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationSources() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002E, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSourceConfiguration.Sources report", 0, value);
    }
};

/*
 * Attribute AttributeList
 */
class ReadPowerSourceConfigurationAttributeList : public ModelCommand
{
public:
    ReadPowerSourceConfigurationAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002E, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSourceConfiguration.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceConfigurationClusterRevision : public ModelCommand
{
public:
    ReadPowerSourceConfigurationClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000002E, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PowerSourceConfiguration.ClusterRevision report", 0, value);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster PressureMeasurement                                         | 0x0403 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventPressureMeasurementWildcard : public ModelCommand
{
public:
    ReadEventPressureMeasurementWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventPressureMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000403, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventPressureMeasurementWildcard : public ModelCommand
{
public:
    ReportEventPressureMeasurementWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventPressureMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000403, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadPressureMeasurementWildcard : public ModelCommand
{
public:
    ReadPressureMeasurementWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000403, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportPressureMeasurementWildcard : public ModelCommand
{
public:
    ReportPressureMeasurementWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000403, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeasuredValue
 */
class ReadPressureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadPressureMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000403, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.MeasuredValue report", 0, value);
    }
};

class ReportPressureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportPressureMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000403, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.MeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadPressureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadPressureMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000403, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.MinMeasuredValue report", 0, value);
    }
};

class ReportPressureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportPressureMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000403, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.MinMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadPressureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadPressureMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000403, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.MaxMeasuredValue report", 0, value);
    }
};

class ReportPressureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportPressureMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000403, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.MaxMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPressureMeasurementAttributeList : public ModelCommand
{
public:
    ReadPressureMeasurementAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000403, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadPressureMeasurementClusterRevision : public ModelCommand
{
public:
    ReadPressureMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000403, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.ClusterRevision report", 0, value);
    }
};

class ReportPressureMeasurementClusterRevision : public ModelCommand
{
public:
    ReportPressureMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000403, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PressureMeasurement.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PumpConfigurationAndControl                                 | 0x0200 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxPressure                                                       | 0x0000 |
| * MaxSpeed                                                          | 0x0001 |
| * MaxFlow                                                           | 0x0002 |
| * MinConstPressure                                                  | 0x0003 |
| * MaxConstPressure                                                  | 0x0004 |
| * MinCompPressure                                                   | 0x0005 |
| * MaxCompPressure                                                   | 0x0006 |
| * MinConstSpeed                                                     | 0x0007 |
| * MaxConstSpeed                                                     | 0x0008 |
| * MinConstFlow                                                      | 0x0009 |
| * MaxConstFlow                                                      | 0x000A |
| * MinConstTemp                                                      | 0x000B |
| * MaxConstTemp                                                      | 0x000C |
| * PumpStatus                                                        | 0x0010 |
| * EffectiveOperationMode                                            | 0x0011 |
| * EffectiveControlMode                                              | 0x0012 |
| * Capacity                                                          | 0x0013 |
| * Speed                                                             | 0x0014 |
| * LifetimeRunningHours                                              | 0x0015 |
| * Power                                                             | 0x0016 |
| * LifetimeEnergyConsumed                                            | 0x0017 |
| * OperationMode                                                     | 0x0020 |
| * ControlMode                                                       | 0x0021 |
| * AlarmMask                                                         | 0x0022 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SupplyVoltageLow                                                  | 0x0000 |
| * SupplyVoltageHigh                                                 | 0x0001 |
| * PowerMissingPhase                                                 | 0x0002 |
| * SystemPressureLow                                                 | 0x0003 |
| * SystemPressureHigh                                                | 0x0004 |
| * DryRunning                                                        | 0x0005 |
| * MotorTemperatureHigh                                              | 0x0006 |
| * PumpMotorFatalFailure                                             | 0x0007 |
| * ElectronicTemperatureHigh                                         | 0x0008 |
| * PumpBlocked                                                       | 0x0009 |
| * SensorFailure                                                     | 0x000A |
| * ElectronicNonFatalFailure                                         | 0x000B |
| * ElectronicFatalFailure                                            | 0x000C |
| * GeneralFault                                                      | 0x000D |
| * Leakage                                                           | 0x000E |
| * AirDetection                                                      | 0x000F |
| * TurbineOperation                                                  | 0x0010 |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventPumpConfigurationAndControlWildcard : public ModelCommand
{
public:
    ReadEventPumpConfigurationAndControlWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventPumpConfigurationAndControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventPumpConfigurationAndControlWildcard : public ModelCommand
{
public:
    ReportEventPumpConfigurationAndControlWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventPumpConfigurationAndControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event SupplyVoltageLow
 */
class ReadPumpConfigurationAndControlSupplyVoltageLow : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlSupplyVoltageLow() : ModelCommand("read-event")
    {
        AddArgument("event-name", "supply-voltage-low");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSupplyVoltageLow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SupplyVoltageLow::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SupplyVoltageLow report", 0, value);
    }
};

class ReportPumpConfigurationAndControlSupplyVoltageLow : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlSupplyVoltageLow() : ModelCommand("report-event")
    {
        AddArgument("event-name", "supply-voltage-low");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSupplyVoltageLow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SupplyVoltageLow::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SupplyVoltageLow report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event SupplyVoltageHigh
 */
class ReadPumpConfigurationAndControlSupplyVoltageHigh : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlSupplyVoltageHigh() : ModelCommand("read-event")
    {
        AddArgument("event-name", "supply-voltage-high");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSupplyVoltageHigh() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SupplyVoltageHigh::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SupplyVoltageHigh report", 0, value);
    }
};

class ReportPumpConfigurationAndControlSupplyVoltageHigh : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlSupplyVoltageHigh() : ModelCommand("report-event")
    {
        AddArgument("event-name", "supply-voltage-high");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSupplyVoltageHigh() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SupplyVoltageHigh::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SupplyVoltageHigh report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event PowerMissingPhase
 */
class ReadPumpConfigurationAndControlPowerMissingPhase : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlPowerMissingPhase() : ModelCommand("read-event")
    {
        AddArgument("event-name", "power-missing-phase");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPowerMissingPhase() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000002);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::PowerMissingPhase::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.PowerMissingPhase report", 0, value);
    }
};

class ReportPumpConfigurationAndControlPowerMissingPhase : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlPowerMissingPhase() : ModelCommand("report-event")
    {
        AddArgument("event-name", "power-missing-phase");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPowerMissingPhase() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::PowerMissingPhase::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.PowerMissingPhase report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event SystemPressureLow
 */
class ReadPumpConfigurationAndControlSystemPressureLow : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlSystemPressureLow() : ModelCommand("read-event")
    {
        AddArgument("event-name", "system-pressure-low");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSystemPressureLow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000003);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SystemPressureLow::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SystemPressureLow report", 0, value);
    }
};

class ReportPumpConfigurationAndControlSystemPressureLow : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlSystemPressureLow() : ModelCommand("report-event")
    {
        AddArgument("event-name", "system-pressure-low");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSystemPressureLow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SystemPressureLow::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SystemPressureLow report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event SystemPressureHigh
 */
class ReadPumpConfigurationAndControlSystemPressureHigh : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlSystemPressureHigh() : ModelCommand("read-event")
    {
        AddArgument("event-name", "system-pressure-high");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSystemPressureHigh() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000004);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SystemPressureHigh::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SystemPressureHigh report", 0, value);
    }
};

class ReportPumpConfigurationAndControlSystemPressureHigh : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlSystemPressureHigh() : ModelCommand("report-event")
    {
        AddArgument("event-name", "system-pressure-high");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSystemPressureHigh() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SystemPressureHigh::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SystemPressureHigh report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event DryRunning
 */
class ReadPumpConfigurationAndControlDryRunning : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlDryRunning() : ModelCommand("read-event")
    {
        AddArgument("event-name", "dry-running");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlDryRunning() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000005);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::DryRunning::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.DryRunning report", 0, value);
    }
};

class ReportPumpConfigurationAndControlDryRunning : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlDryRunning() : ModelCommand("report-event")
    {
        AddArgument("event-name", "dry-running");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlDryRunning() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::DryRunning::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.DryRunning report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event MotorTemperatureHigh
 */
class ReadPumpConfigurationAndControlMotorTemperatureHigh : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMotorTemperatureHigh() : ModelCommand("read-event")
    {
        AddArgument("event-name", "motor-temperature-high");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMotorTemperatureHigh() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000006);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::MotorTemperatureHigh::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MotorTemperatureHigh report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMotorTemperatureHigh : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMotorTemperatureHigh() : ModelCommand("report-event")
    {
        AddArgument("event-name", "motor-temperature-high");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMotorTemperatureHigh() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::MotorTemperatureHigh::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MotorTemperatureHigh report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event PumpMotorFatalFailure
 */
class ReadPumpConfigurationAndControlPumpMotorFatalFailure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlPumpMotorFatalFailure() : ModelCommand("read-event")
    {
        AddArgument("event-name", "pump-motor-fatal-failure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpMotorFatalFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000007);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::PumpMotorFatalFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.PumpMotorFatalFailure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlPumpMotorFatalFailure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlPumpMotorFatalFailure() : ModelCommand("report-event")
    {
        AddArgument("event-name", "pump-motor-fatal-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPumpMotorFatalFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::PumpMotorFatalFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.PumpMotorFatalFailure report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ElectronicTemperatureHigh
 */
class ReadPumpConfigurationAndControlElectronicTemperatureHigh : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlElectronicTemperatureHigh() : ModelCommand("read-event")
    {
        AddArgument("event-name", "electronic-temperature-high");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlElectronicTemperatureHigh() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000008);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicTemperatureHigh::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ElectronicTemperatureHigh report", 0, value);
    }
};

class ReportPumpConfigurationAndControlElectronicTemperatureHigh : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlElectronicTemperatureHigh() : ModelCommand("report-event")
    {
        AddArgument("event-name", "electronic-temperature-high");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlElectronicTemperatureHigh() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicTemperatureHigh::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ElectronicTemperatureHigh report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event PumpBlocked
 */
class ReadPumpConfigurationAndControlPumpBlocked : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlPumpBlocked() : ModelCommand("read-event")
    {
        AddArgument("event-name", "pump-blocked");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpBlocked() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000009);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::PumpBlocked::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.PumpBlocked report", 0, value);
    }
};

class ReportPumpConfigurationAndControlPumpBlocked : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlPumpBlocked() : ModelCommand("report-event")
    {
        AddArgument("event-name", "pump-blocked");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPumpBlocked() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000009, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::PumpBlocked::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.PumpBlocked report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event SensorFailure
 */
class ReadPumpConfigurationAndControlSensorFailure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlSensorFailure() : ModelCommand("read-event")
    {
        AddArgument("event-name", "sensor-failure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSensorFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x0000000A);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SensorFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SensorFailure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlSensorFailure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlSensorFailure() : ModelCommand("report-event")
    {
        AddArgument("event-name", "sensor-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSensorFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x0000000A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::SensorFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.SensorFailure report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ElectronicNonFatalFailure
 */
class ReadPumpConfigurationAndControlElectronicNonFatalFailure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlElectronicNonFatalFailure() : ModelCommand("read-event")
    {
        AddArgument("event-name", "electronic-non-fatal-failure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlElectronicNonFatalFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x0000000B);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicNonFatalFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ElectronicNonFatalFailure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlElectronicNonFatalFailure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlElectronicNonFatalFailure() : ModelCommand("report-event")
    {
        AddArgument("event-name", "electronic-non-fatal-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlElectronicNonFatalFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x0000000B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicNonFatalFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ElectronicNonFatalFailure report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ElectronicFatalFailure
 */
class ReadPumpConfigurationAndControlElectronicFatalFailure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlElectronicFatalFailure() : ModelCommand("read-event")
    {
        AddArgument("event-name", "electronic-fatal-failure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlElectronicFatalFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x0000000C);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicFatalFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ElectronicFatalFailure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlElectronicFatalFailure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlElectronicFatalFailure() : ModelCommand("report-event")
    {
        AddArgument("event-name", "electronic-fatal-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlElectronicFatalFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x0000000C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::ElectronicFatalFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ElectronicFatalFailure report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event GeneralFault
 */
class ReadPumpConfigurationAndControlGeneralFault : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlGeneralFault() : ModelCommand("read-event")
    {
        AddArgument("event-name", "general-fault");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlGeneralFault() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x0000000D);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::GeneralFault::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.GeneralFault report", 0, value);
    }
};

class ReportPumpConfigurationAndControlGeneralFault : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlGeneralFault() : ModelCommand("report-event")
    {
        AddArgument("event-name", "general-fault");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlGeneralFault() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x0000000D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::GeneralFault::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.GeneralFault report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event Leakage
 */
class ReadPumpConfigurationAndControlLeakage : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlLeakage() : ModelCommand("read-event")
    {
        AddArgument("event-name", "leakage");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLeakage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x0000000E);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::Leakage::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.Leakage report", 0, value);
    }
};

class ReportPumpConfigurationAndControlLeakage : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlLeakage() : ModelCommand("report-event")
    {
        AddArgument("event-name", "leakage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlLeakage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x0000000E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::Leakage::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.Leakage report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event AirDetection
 */
class ReadPumpConfigurationAndControlAirDetection : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlAirDetection() : ModelCommand("read-event")
    {
        AddArgument("event-name", "air-detection");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAirDetection() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x0000000F);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::AirDetection::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.AirDetection report", 0, value);
    }
};

class ReportPumpConfigurationAndControlAirDetection : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlAirDetection() : ModelCommand("report-event")
    {
        AddArgument("event-name", "air-detection");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlAirDetection() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x0000000F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::AirDetection::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.AirDetection report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event TurbineOperation
 */
class ReadPumpConfigurationAndControlTurbineOperation : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlTurbineOperation() : ModelCommand("read-event")
    {
        AddArgument("event-name", "turbine-operation");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlTurbineOperation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000200, 0x00000010);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::TurbineOperation::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.TurbineOperation report", 0, value);
    }
};

class ReportPumpConfigurationAndControlTurbineOperation : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlTurbineOperation() : ModelCommand("report-event")
    {
        AddArgument("event-name", "turbine-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlTurbineOperation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000200, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::PumpConfigurationAndControl::Events::TurbineOperation::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.TurbineOperation report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadPumpConfigurationAndControlWildcard : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlWildcard : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxPressure
 */
class ReadPumpConfigurationAndControlMaxPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxPressure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMaxPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxPressure report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxSpeed
 */
class ReadPumpConfigurationAndControlMaxSpeed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxSpeed report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMaxSpeed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxSpeed report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFlow
 */
class ReadPumpConfigurationAndControlMaxFlow : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxFlow() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxFlow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxFlow report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMaxFlow : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxFlow() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxFlow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxFlow report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstPressure
 */
class ReadPumpConfigurationAndControlMinConstPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinConstPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinConstPressure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMinConstPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinConstPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinConstPressure report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstPressure
 */
class ReadPumpConfigurationAndControlMaxConstPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxConstPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxConstPressure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMaxConstPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxConstPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxConstPressure report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCompPressure
 */
class ReadPumpConfigurationAndControlMinCompPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinCompPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinCompPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinCompPressure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMinCompPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinCompPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinCompPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinCompPressure report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCompPressure
 */
class ReadPumpConfigurationAndControlMaxCompPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxCompPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxCompPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxCompPressure report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMaxCompPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxCompPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxCompPressure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxCompPressure report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstSpeed
 */
class ReadPumpConfigurationAndControlMinConstSpeed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinConstSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinConstSpeed report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMinConstSpeed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinConstSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinConstSpeed report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstSpeed
 */
class ReadPumpConfigurationAndControlMaxConstSpeed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxConstSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxConstSpeed report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMaxConstSpeed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxConstSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxConstSpeed report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstFlow
 */
class ReadPumpConfigurationAndControlMinConstFlow : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinConstFlow() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstFlow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000009);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinConstFlow report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMinConstFlow : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinConstFlow() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstFlow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000009, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinConstFlow report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstFlow
 */
class ReadPumpConfigurationAndControlMaxConstFlow : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxConstFlow() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstFlow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x0000000A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxConstFlow report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMaxConstFlow : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxConstFlow() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstFlow() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x0000000A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxConstFlow report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstTemp
 */
class ReadPumpConfigurationAndControlMinConstTemp : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinConstTemp() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstTemp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x0000000B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinConstTemp report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMinConstTemp : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinConstTemp() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstTemp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x0000000B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MinConstTemp report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstTemp
 */
class ReadPumpConfigurationAndControlMaxConstTemp : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxConstTemp() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstTemp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x0000000C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxConstTemp report", 0, value);
    }
};

class ReportPumpConfigurationAndControlMaxConstTemp : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxConstTemp() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstTemp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x0000000C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.MaxConstTemp report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PumpStatus
 */
class ReadPumpConfigurationAndControlPumpStatus : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlPumpStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "pump-status");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.PumpStatus report", 0, value);
    }
};

class ReportPumpConfigurationAndControlPumpStatus : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlPumpStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "pump-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPumpStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.PumpStatus report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveOperationMode
 */
class ReadPumpConfigurationAndControlEffectiveOperationMode : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlEffectiveOperationMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveOperationMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.EffectiveOperationMode report", 0, value);
    }
};

class ReportPumpConfigurationAndControlEffectiveOperationMode : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlEffectiveOperationMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "effective-operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlEffectiveOperationMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.EffectiveOperationMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveControlMode
 */
class ReadPumpConfigurationAndControlEffectiveControlMode : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlEffectiveControlMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveControlMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.EffectiveControlMode report", 0, value);
    }
};

class ReportPumpConfigurationAndControlEffectiveControlMode : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlEffectiveControlMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "effective-control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlEffectiveControlMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.EffectiveControlMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Capacity
 */
class ReadPumpConfigurationAndControlCapacity : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlCapacity() : ModelCommand("read")
    {
        AddArgument("attr-name", "capacity");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlCapacity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000013);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.Capacity report", 0, value);
    }
};

class ReportPumpConfigurationAndControlCapacity : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlCapacity() : ModelCommand("report")
    {
        AddArgument("attr-name", "capacity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlCapacity() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000013, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.Capacity report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Speed
 */
class ReadPumpConfigurationAndControlSpeed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000014);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.Speed report", 0, value);
    }
};

class ReportPumpConfigurationAndControlSpeed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSpeed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000014, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.Speed report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeRunningHours
 */
class ReadPumpConfigurationAndControlLifetimeRunningHours : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlLifetimeRunningHours() : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000015);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.LifetimeRunningHours report", 0, value);
    }
};

class WritePumpConfigurationAndControlLifetimeRunningHours : public ModelCommand
{
public:
    WritePumpConfigurationAndControlLifetimeRunningHours() : ModelCommand("write")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000200, 0x00000015, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint32_t> mValue;
};

class ReportPumpConfigurationAndControlLifetimeRunningHours : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlLifetimeRunningHours() : ModelCommand("report")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000015, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.LifetimeRunningHours report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Power
 */
class ReadPumpConfigurationAndControlPower : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlPower() : ModelCommand("read")
    {
        AddArgument("attr-name", "power");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPower() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000016);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.Power report", 0, value);
    }
};

class ReportPumpConfigurationAndControlPower : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlPower() : ModelCommand("report")
    {
        AddArgument("attr-name", "power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPower() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000016, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.Power report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeEnergyConsumed
 */
class ReadPumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlLifetimeEnergyConsumed() : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000017);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.LifetimeEnergyConsumed report", 0, value);
    }
};

class WritePumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand
{
public:
    WritePumpConfigurationAndControlLifetimeEnergyConsumed() : ModelCommand("write")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000200, 0x00000017, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint32_t> mValue;
};

class ReportPumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlLifetimeEnergyConsumed() : ModelCommand("report")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000017, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.LifetimeEnergyConsumed report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationMode
 */
class ReadPumpConfigurationAndControlOperationMode : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlOperationMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000020);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.OperationMode report", 0, value);
    }
};

class WritePumpConfigurationAndControlOperationMode : public ModelCommand
{
public:
    WritePumpConfigurationAndControlOperationMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000200, 0x00000020, mValue);
    }

private:
    uint8_t mValue;
};

class ReportPumpConfigurationAndControlOperationMode : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlOperationMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000020, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.OperationMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlMode
 */
class ReadPumpConfigurationAndControlControlMode : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlControlMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000021);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ControlMode report", 0, value);
    }
};

class WritePumpConfigurationAndControlControlMode : public ModelCommand
{
public:
    WritePumpConfigurationAndControlControlMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000200, 0x00000021, mValue);
    }

private:
    uint8_t mValue;
};

class ReportPumpConfigurationAndControlControlMode : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlControlMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000021, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ControlMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AlarmMask
 */
class ReadPumpConfigurationAndControlAlarmMask : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlAlarmMask() : ModelCommand("read")
    {
        AddArgument("attr-name", "alarm-mask");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAlarmMask() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x00000022);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.AlarmMask report", 0, value);
    }
};

class ReportPumpConfigurationAndControlAlarmMask : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlAlarmMask() : ModelCommand("report")
    {
        AddArgument("attr-name", "alarm-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlAlarmMask() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x00000022, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.AlarmMask report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPumpConfigurationAndControlAttributeList : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadPumpConfigurationAndControlFeatureMap : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.FeatureMap report", 0, value);
    }
};

class ReportPumpConfigurationAndControlFeatureMap : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x0000FFFC, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.FeatureMap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPumpConfigurationAndControlClusterRevision : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000200, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ClusterRevision report", 0, value);
    }
};

class ReportPumpConfigurationAndControlClusterRevision : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000200, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("PumpConfigurationAndControl.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster RelativeHumidityMeasurement                                 | 0x0405 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventRelativeHumidityMeasurementWildcard : public ModelCommand
{
public:
    ReadEventRelativeHumidityMeasurementWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventRelativeHumidityMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000405, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventRelativeHumidityMeasurementWildcard : public ModelCommand
{
public:
    ReportEventRelativeHumidityMeasurementWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventRelativeHumidityMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000405, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadRelativeHumidityMeasurementWildcard : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000405, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementWildcard : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000405, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeasuredValue
 */
class ReadRelativeHumidityMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000405, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.MeasuredValue report", 0, value);
    }
};

class ReportRelativeHumidityMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000405, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.MeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000405, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.MinMeasuredValue report", 0, value);
    }
};

class ReportRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000405, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.MinMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000405, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.MaxMeasuredValue report", 0, value);
    }
};

class ReportRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000405, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.MaxMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadRelativeHumidityMeasurementTolerance : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementTolerance() : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementTolerance() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000405, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.Tolerance report", 0, value);
    }
};

class ReportRelativeHumidityMeasurementTolerance : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementTolerance() : ModelCommand("report")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementTolerance() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000405, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.Tolerance report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadRelativeHumidityMeasurementAttributeList : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000405, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadRelativeHumidityMeasurementClusterRevision : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000405, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.ClusterRevision report", 0, value);
    }
};

class ReportRelativeHumidityMeasurementClusterRevision : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000405, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("RelativeHumidityMeasurement.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Scenes                                                      | 0x0005 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddScene                                                          |   0x00 |
| * GetSceneMembership                                                |   0x06 |
| * RecallScene                                                       |   0x05 |
| * RemoveAllScenes                                                   |   0x03 |
| * RemoveScene                                                       |   0x02 |
| * StoreScene                                                        |   0x04 |
| * ViewScene                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SceneCount                                                        | 0x0000 |
| * CurrentScene                                                      | 0x0001 |
| * CurrentGroup                                                      | 0x0002 |
| * SceneValid                                                        | 0x0003 |
| * NameSupport                                                       | 0x0004 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddScene
 */
class ScenesAddScene : public ModelCommand
{
public:
    ScenesAddScene() : ModelCommand("add-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("SceneName", &mRequest.sceneName);
        // extensionFieldSets Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesAddSceneResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Scenes::Commands::AddScene::Type mRequest;
};

/*
 * Command GetSceneMembership
 */
class ScenesGetSceneMembership : public ModelCommand
{
public:
    ScenesGetSceneMembership() : ModelCommand("get-scene-membership")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000006) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesGetSceneMembershipResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Scenes::Commands::GetSceneMembership::Type mRequest;
};

/*
 * Command RecallScene
 */
class ScenesRecallScene : public ModelCommand
{
public:
    ScenesRecallScene() : ModelCommand("recall-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000005) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Scenes::Commands::RecallScene::Type mRequest;
};

/*
 * Command RemoveAllScenes
 */
class ScenesRemoveAllScenes : public ModelCommand
{
public:
    ScenesRemoveAllScenes() : ModelCommand("remove-all-scenes")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesRemoveAllScenesResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Scenes::Commands::RemoveAllScenes::Type mRequest;
};

/*
 * Command RemoveScene
 */
class ScenesRemoveScene : public ModelCommand
{
public:
    ScenesRemoveScene() : ModelCommand("remove-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesRemoveSceneResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Scenes::Commands::RemoveScene::Type mRequest;
};

/*
 * Command StoreScene
 */
class ScenesStoreScene : public ModelCommand
{
public:
    ScenesStoreScene() : ModelCommand("store-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesStoreSceneResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Scenes::Commands::StoreScene::Type mRequest;
};

/*
 * Command ViewScene
 */
class ScenesViewScene : public ModelCommand
{
public:
    ScenesViewScene() : ModelCommand("view-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesViewSceneResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Scenes::Commands::ViewScene::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventScenesWildcard : public ModelCommand
{
public:
    ReadEventScenesWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventScenesWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000005, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventScenesWildcard : public ModelCommand
{
public:
    ReportEventScenesWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventScenesWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000005, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadScenesWildcard : public ModelCommand
{
public:
    ReadScenesWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadScenesWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000005, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportScenesWildcard : public ModelCommand
{
public:
    ReportScenesWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000005, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SceneCount
 */
class ReadScenesSceneCount : public ModelCommand
{
public:
    ReadScenesSceneCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-count");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000005, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.SceneCount report", 0, value);
    }
};

class ReportScenesSceneCount : public ModelCommand
{
public:
    ReportScenesSceneCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "scene-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesSceneCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000005, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.SceneCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentScene
 */
class ReadScenesCurrentScene : public ModelCommand
{
public:
    ReadScenesCurrentScene() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-scene");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentScene() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000005, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.CurrentScene report", 0, value);
    }
};

class ReportScenesCurrentScene : public ModelCommand
{
public:
    ReportScenesCurrentScene() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-scene");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesCurrentScene() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000005, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.CurrentScene report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentGroup
 */
class ReadScenesCurrentGroup : public ModelCommand
{
public:
    ReadScenesCurrentGroup() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-group");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentGroup() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000005, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.CurrentGroup report", 0, value);
    }
};

class ReportScenesCurrentGroup : public ModelCommand
{
public:
    ReportScenesCurrentGroup() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-group");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesCurrentGroup() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000005, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.CurrentGroup report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SceneValid
 */
class ReadScenesSceneValid : public ModelCommand
{
public:
    ReadScenesSceneValid() : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-valid");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneValid() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000005, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.SceneValid report", 0, value);
    }
};

class ReportScenesSceneValid : public ModelCommand
{
public:
    ReportScenesSceneValid() : ModelCommand("report")
    {
        AddArgument("attr-name", "scene-valid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesSceneValid() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000005, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.SceneValid report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NameSupport
 */
class ReadScenesNameSupport : public ModelCommand
{
public:
    ReadScenesNameSupport() : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadScenesNameSupport() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000005, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.NameSupport report", 0, value);
    }
};

class ReportScenesNameSupport : public ModelCommand
{
public:
    ReportScenesNameSupport() : ModelCommand("report")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesNameSupport() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000005, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.NameSupport report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadScenesAttributeList : public ModelCommand
{
public:
    ReadScenesAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000005, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadScenesClusterRevision : public ModelCommand
{
public:
    ReadScenesClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadScenesClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000005, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.ClusterRevision report", 0, value);
    }
};

class ReportScenesClusterRevision : public ModelCommand
{
public:
    ReportScenesClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000005, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Scenes.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster SoftwareDiagnostics                                         | 0x0034 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetWatermarks                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ThreadMetrics                                                     | 0x0000 |
| * CurrentHeapFree                                                   | 0x0001 |
| * CurrentHeapUsed                                                   | 0x0002 |
| * CurrentHeapHighWatermark                                          | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SoftwareFault                                                     | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetWatermarks
 */
class SoftwareDiagnosticsResetWatermarks : public ModelCommand
{
public:
    SoftwareDiagnosticsResetWatermarks() : ModelCommand("reset-watermarks") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::SoftwareDiagnostics::Commands::ResetWatermarks::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventSoftwareDiagnosticsWildcard : public ModelCommand
{
public:
    ReadEventSoftwareDiagnosticsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventSoftwareDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000034, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventSoftwareDiagnosticsWildcard : public ModelCommand
{
public:
    ReportEventSoftwareDiagnosticsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventSoftwareDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000034, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event SoftwareFault
 */
class ReadSoftwareDiagnosticsSoftwareFault : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsSoftwareFault() : ModelCommand("read-event")
    {
        AddArgument("event-name", "software-fault");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsSoftwareFault() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000034, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::SoftwareDiagnostics::Events::SoftwareFault::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.SoftwareFault report", 0, value);
    }
};

class ReportSoftwareDiagnosticsSoftwareFault : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsSoftwareFault() : ModelCommand("report-event")
    {
        AddArgument("event-name", "software-fault");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsSoftwareFault() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000034, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::SoftwareDiagnostics::Events::SoftwareFault::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.SoftwareFault report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadSoftwareDiagnosticsWildcard : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000034, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsWildcard : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000034, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ThreadMetrics
 */
class ReadSoftwareDiagnosticsThreadMetrics : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsThreadMetrics() : ModelCommand("read")
    {
        AddArgument("attr-name", "thread-metrics");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsThreadMetrics() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000034, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.ThreadMetrics report", 0, value);
    }
};

class ReportSoftwareDiagnosticsThreadMetrics : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsThreadMetrics() : ModelCommand("report")
    {
        AddArgument("attr-name", "thread-metrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsThreadMetrics() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000034, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.ThreadMetrics report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapFree
 */
class ReadSoftwareDiagnosticsCurrentHeapFree : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsCurrentHeapFree() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-free");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapFree() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000034, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.CurrentHeapFree report", 0, value);
    }
};

class ReportSoftwareDiagnosticsCurrentHeapFree : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsCurrentHeapFree() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-heap-free");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapFree() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000034, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.CurrentHeapFree report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapUsed
 */
class ReadSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsCurrentHeapUsed() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-used");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapUsed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000034, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.CurrentHeapUsed report", 0, value);
    }
};

class ReportSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsCurrentHeapUsed() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-heap-used");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapUsed() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000034, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.CurrentHeapUsed report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapHighWatermark
 */
class ReadSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsCurrentHeapHighWatermark() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapHighWatermark() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000034, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.CurrentHeapHighWatermark report", 0, value);
    }
};

class ReportSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsCurrentHeapHighWatermark() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapHighWatermark() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000034, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.CurrentHeapHighWatermark report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadSoftwareDiagnosticsAttributeList : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000034, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadSoftwareDiagnosticsFeatureMap : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000034, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.FeatureMap report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadSoftwareDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000034, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.ClusterRevision report", 0, value);
    }
};

class ReportSoftwareDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000034, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("SoftwareDiagnostics.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Switch                                                      | 0x003B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NumberOfPositions                                                 | 0x0000 |
| * CurrentPosition                                                   | 0x0001 |
| * MultiPressMax                                                     | 0x0002 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SwitchLatched                                                     | 0x0000 |
| * InitialPress                                                      | 0x0001 |
| * LongPress                                                         | 0x0002 |
| * ShortRelease                                                      | 0x0003 |
| * LongRelease                                                       | 0x0004 |
| * MultiPressOngoing                                                 | 0x0005 |
| * MultiPressComplete                                                | 0x0006 |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventSwitchWildcard : public ModelCommand
{
public:
    ReadEventSwitchWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventSwitchWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003B, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventSwitchWildcard : public ModelCommand
{
public:
    ReportEventSwitchWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventSwitchWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003B, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event SwitchLatched
 */
class ReadSwitchSwitchLatched : public ModelCommand
{
public:
    ReadSwitchSwitchLatched() : ModelCommand("read-event")
    {
        AddArgument("event-name", "switch-latched");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchSwitchLatched() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003B, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::SwitchLatched::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.SwitchLatched report", 0, value);
    }
};

class ReportSwitchSwitchLatched : public ModelCommand
{
public:
    ReportSwitchSwitchLatched() : ModelCommand("report-event")
    {
        AddArgument("event-name", "switch-latched");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchSwitchLatched() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003B, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::SwitchLatched::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.SwitchLatched report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event InitialPress
 */
class ReadSwitchInitialPress : public ModelCommand
{
public:
    ReadSwitchInitialPress() : ModelCommand("read-event")
    {
        AddArgument("event-name", "initial-press");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchInitialPress() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003B, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::InitialPress::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.InitialPress report", 0, value);
    }
};

class ReportSwitchInitialPress : public ModelCommand
{
public:
    ReportSwitchInitialPress() : ModelCommand("report-event")
    {
        AddArgument("event-name", "initial-press");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchInitialPress() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003B, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::InitialPress::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.InitialPress report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LongPress
 */
class ReadSwitchLongPress : public ModelCommand
{
public:
    ReadSwitchLongPress() : ModelCommand("read-event")
    {
        AddArgument("event-name", "long-press");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchLongPress() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003B, 0x00000002);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::LongPress::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.LongPress report", 0, value);
    }
};

class ReportSwitchLongPress : public ModelCommand
{
public:
    ReportSwitchLongPress() : ModelCommand("report-event")
    {
        AddArgument("event-name", "long-press");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchLongPress() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003B, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::LongPress::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.LongPress report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ShortRelease
 */
class ReadSwitchShortRelease : public ModelCommand
{
public:
    ReadSwitchShortRelease() : ModelCommand("read-event")
    {
        AddArgument("event-name", "short-release");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchShortRelease() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003B, 0x00000003);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::ShortRelease::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.ShortRelease report", 0, value);
    }
};

class ReportSwitchShortRelease : public ModelCommand
{
public:
    ReportSwitchShortRelease() : ModelCommand("report-event")
    {
        AddArgument("event-name", "short-release");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchShortRelease() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003B, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::ShortRelease::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.ShortRelease report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LongRelease
 */
class ReadSwitchLongRelease : public ModelCommand
{
public:
    ReadSwitchLongRelease() : ModelCommand("read-event")
    {
        AddArgument("event-name", "long-release");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchLongRelease() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003B, 0x00000004);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::LongRelease::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.LongRelease report", 0, value);
    }
};

class ReportSwitchLongRelease : public ModelCommand
{
public:
    ReportSwitchLongRelease() : ModelCommand("report-event")
    {
        AddArgument("event-name", "long-release");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchLongRelease() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003B, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::LongRelease::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.LongRelease report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event MultiPressOngoing
 */
class ReadSwitchMultiPressOngoing : public ModelCommand
{
public:
    ReadSwitchMultiPressOngoing() : ModelCommand("read-event")
    {
        AddArgument("event-name", "multi-press-ongoing");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressOngoing() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003B, 0x00000005);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::MultiPressOngoing::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.MultiPressOngoing report", 0, value);
    }
};

class ReportSwitchMultiPressOngoing : public ModelCommand
{
public:
    ReportSwitchMultiPressOngoing() : ModelCommand("report-event")
    {
        AddArgument("event-name", "multi-press-ongoing");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchMultiPressOngoing() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003B, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::MultiPressOngoing::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.MultiPressOngoing report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event MultiPressComplete
 */
class ReadSwitchMultiPressComplete : public ModelCommand
{
public:
    ReadSwitchMultiPressComplete() : ModelCommand("read-event")
    {
        AddArgument("event-name", "multi-press-complete");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressComplete() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000003B, 0x00000006);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::MultiPressComplete::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.MultiPressComplete report", 0, value);
    }
};

class ReportSwitchMultiPressComplete : public ModelCommand
{
public:
    ReportSwitchMultiPressComplete() : ModelCommand("report-event")
    {
        AddArgument("event-name", "multi-press-complete");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchMultiPressComplete() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000003B, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::Switch::Events::MultiPressComplete::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.MultiPressComplete report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadSwitchWildcard : public ModelCommand
{
public:
    ReadSwitchWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003B, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchWildcard : public ModelCommand
{
public:
    ReportSwitchWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003B, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPositions
 */
class ReadSwitchNumberOfPositions : public ModelCommand
{
public:
    ReadSwitchNumberOfPositions() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-positions");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchNumberOfPositions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003B, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.NumberOfPositions report", 0, value);
    }
};

class ReportSwitchNumberOfPositions : public ModelCommand
{
public:
    ReportSwitchNumberOfPositions() : ModelCommand("report")
    {
        AddArgument("attr-name", "number-of-positions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchNumberOfPositions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003B, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.NumberOfPositions report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPosition
 */
class ReadSwitchCurrentPosition : public ModelCommand
{
public:
    ReadSwitchCurrentPosition() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchCurrentPosition() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003B, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.CurrentPosition report", 0, value);
    }
};

class ReportSwitchCurrentPosition : public ModelCommand
{
public:
    ReportSwitchCurrentPosition() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchCurrentPosition() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003B, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.CurrentPosition report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MultiPressMax
 */
class ReadSwitchMultiPressMax : public ModelCommand
{
public:
    ReadSwitchMultiPressMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "multi-press-max");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003B, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.MultiPressMax report", 0, value);
    }
};

class ReportSwitchMultiPressMax : public ModelCommand
{
public:
    ReportSwitchMultiPressMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "multi-press-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchMultiPressMax() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003B, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.MultiPressMax report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadSwitchAttributeList : public ModelCommand
{
public:
    ReadSwitchAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003B, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadSwitchFeatureMap : public ModelCommand
{
public:
    ReadSwitchFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003B, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.FeatureMap report", 0, value);
    }
};

class ReportSwitchFeatureMap : public ModelCommand
{
public:
    ReportSwitchFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003B, 0x0000FFFC, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.FeatureMap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSwitchClusterRevision : public ModelCommand
{
public:
    ReadSwitchClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000003B, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.ClusterRevision report", 0, value);
    }
};

class ReportSwitchClusterRevision : public ModelCommand
{
public:
    ReportSwitchClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000003B, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Switch.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TargetNavigator                                             | 0x0505 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * NavigateTargetRequest                                             |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TargetNavigatorList                                               | 0x0000 |
| * CurrentNavigatorTarget                                            | 0x0001 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command NavigateTargetRequest
 */
class TargetNavigatorNavigateTargetRequest : public ModelCommand
{
public:
    TargetNavigatorNavigateTargetRequest() : ModelCommand("navigate-target-request")
    {
        AddArgument("Target", 0, UINT8_MAX, &mRequest.target);
        AddArgument("Data", &mRequest.data);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTargetNavigatorNavigateTargetResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TargetNavigator::Commands::NavigateTargetRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventTargetNavigatorWildcard : public ModelCommand
{
public:
    ReadEventTargetNavigatorWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventTargetNavigatorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000505, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventTargetNavigatorWildcard : public ModelCommand
{
public:
    ReportEventTargetNavigatorWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventTargetNavigatorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000505, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadTargetNavigatorWildcard : public ModelCommand
{
public:
    ReadTargetNavigatorWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000505, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportTargetNavigatorWildcard : public ModelCommand
{
public:
    ReportTargetNavigatorWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000505, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetNavigatorList
 */
class ReadTargetNavigatorTargetNavigatorList : public ModelCommand
{
public:
    ReadTargetNavigatorTargetNavigatorList() : ModelCommand("read")
    {
        AddArgument("attr-name", "target-navigator-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorTargetNavigatorList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000505, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TargetNavigator.TargetNavigatorList report", 0, value);
    }
};

class ReportTargetNavigatorTargetNavigatorList : public ModelCommand
{
public:
    ReportTargetNavigatorTargetNavigatorList() : ModelCommand("report")
    {
        AddArgument("attr-name", "target-navigator-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorTargetNavigatorList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000505, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TargetNavigator.TargetNavigatorList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentNavigatorTarget
 */
class ReadTargetNavigatorCurrentNavigatorTarget : public ModelCommand
{
public:
    ReadTargetNavigatorCurrentNavigatorTarget() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-navigator-target");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorCurrentNavigatorTarget() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000505, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TargetNavigator.CurrentNavigatorTarget report", 0, value);
    }
};

class ReportTargetNavigatorCurrentNavigatorTarget : public ModelCommand
{
public:
    ReportTargetNavigatorCurrentNavigatorTarget() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-navigator-target");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorCurrentNavigatorTarget() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000505, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TargetNavigator.CurrentNavigatorTarget report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTargetNavigatorAttributeList : public ModelCommand
{
public:
    ReadTargetNavigatorAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000505, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TargetNavigator.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadTargetNavigatorClusterRevision : public ModelCommand
{
public:
    ReadTargetNavigatorClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000505, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TargetNavigator.ClusterRevision report", 0, value);
    }
};

class ReportTargetNavigatorClusterRevision : public ModelCommand
{
public:
    ReportTargetNavigatorClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000505, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TargetNavigator.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TemperatureMeasurement                                      | 0x0402 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventTemperatureMeasurementWildcard : public ModelCommand
{
public:
    ReadEventTemperatureMeasurementWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventTemperatureMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000402, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventTemperatureMeasurementWildcard : public ModelCommand
{
public:
    ReportEventTemperatureMeasurementWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventTemperatureMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000402, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadTemperatureMeasurementWildcard : public ModelCommand
{
public:
    ReadTemperatureMeasurementWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000402, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportTemperatureMeasurementWildcard : public ModelCommand
{
public:
    ReportTemperatureMeasurementWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000402, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeasuredValue
 */
class ReadTemperatureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000402, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.MeasuredValue report", 0, value);
    }
};

class ReportTemperatureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportTemperatureMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000402, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.MeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadTemperatureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000402, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.MinMeasuredValue report", 0, value);
    }
};

class ReportTemperatureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportTemperatureMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000402, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.MinMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadTemperatureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000402, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.MaxMeasuredValue report", 0, value);
    }
};

class ReportTemperatureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportTemperatureMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000402, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.MaxMeasuredValue report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadTemperatureMeasurementTolerance : public ModelCommand
{
public:
    ReadTemperatureMeasurementTolerance() : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementTolerance() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000402, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.Tolerance report", 0, value);
    }
};

class ReportTemperatureMeasurementTolerance : public ModelCommand
{
public:
    ReportTemperatureMeasurementTolerance() : ModelCommand("report")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementTolerance() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000402, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.Tolerance report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTemperatureMeasurementAttributeList : public ModelCommand
{
public:
    ReadTemperatureMeasurementAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000402, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadTemperatureMeasurementClusterRevision : public ModelCommand
{
public:
    ReadTemperatureMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000402, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.ClusterRevision report", 0, value);
    }
};

class ReportTemperatureMeasurementClusterRevision : public ModelCommand
{
public:
    ReportTemperatureMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000402, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TemperatureMeasurement.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TestCluster                                                 | 0x050F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SimpleStructEchoRequest                                           |   0x11 |
| * Test                                                              |   0x00 |
| * TestAddArguments                                                  |   0x04 |
| * TestEmitTestEventRequest                                          |   0x14 |
| * TestEnumsRequest                                                  |   0x0E |
| * TestListInt8UArgumentRequest                                      |   0x0A |
| * TestListInt8UReverseRequest                                       |   0x0D |
| * TestListNestedStructListArgumentRequest                           |   0x0C |
| * TestListStructArgumentRequest                                     |   0x09 |
| * TestNestedStructArgumentRequest                                   |   0x08 |
| * TestNestedStructListArgumentRequest                               |   0x0B |
| * TestNotHandled                                                    |   0x01 |
| * TestNullableOptionalRequest                                       |   0x0F |
| * TestSimpleOptionalArgumentRequest                                 |   0x13 |
| * TestSpecific                                                      |   0x02 |
| * TestStructArgumentRequest                                         |   0x07 |
| * TestUnknownCommand                                                |   0x03 |
| * TimedInvokeRequest                                                |   0x12 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Boolean                                                           | 0x0000 |
| * Bitmap8                                                           | 0x0001 |
| * Bitmap16                                                          | 0x0002 |
| * Bitmap32                                                          | 0x0003 |
| * Bitmap64                                                          | 0x0004 |
| * Int8u                                                             | 0x0005 |
| * Int16u                                                            | 0x0006 |
| * Int24u                                                            | 0x0007 |
| * Int32u                                                            | 0x0008 |
| * Int40u                                                            | 0x0009 |
| * Int48u                                                            | 0x000A |
| * Int56u                                                            | 0x000B |
| * Int64u                                                            | 0x000C |
| * Int8s                                                             | 0x000D |
| * Int16s                                                            | 0x000E |
| * Int24s                                                            | 0x000F |
| * Int32s                                                            | 0x0010 |
| * Int40s                                                            | 0x0011 |
| * Int48s                                                            | 0x0012 |
| * Int56s                                                            | 0x0013 |
| * Int64s                                                            | 0x0014 |
| * Enum8                                                             | 0x0015 |
| * Enum16                                                            | 0x0016 |
| * FloatSingle                                                       | 0x0017 |
| * FloatDouble                                                       | 0x0018 |
| * OctetString                                                       | 0x0019 |
| * ListInt8u                                                         | 0x001A |
| * ListOctetString                                                   | 0x001B |
| * ListStructOctetString                                             | 0x001C |
| * LongOctetString                                                   | 0x001D |
| * CharString                                                        | 0x001E |
| * LongCharString                                                    | 0x001F |
| * EpochUs                                                           | 0x0020 |
| * EpochS                                                            | 0x0021 |
| * VendorId                                                          | 0x0022 |
| * ListNullablesAndOptionalsStruct                                   | 0x0023 |
| * EnumAttr                                                          | 0x0024 |
| * StructAttr                                                        | 0x0025 |
| * RangeRestrictedInt8u                                              | 0x0026 |
| * RangeRestrictedInt8s                                              | 0x0027 |
| * RangeRestrictedInt16u                                             | 0x0028 |
| * RangeRestrictedInt16s                                             | 0x0029 |
| * ListLongOctetString                                               | 0x002A |
| * TimedWriteBoolean                                                 | 0x0030 |
| * Unsupported                                                       | 0x00FF |
| * NullableBoolean                                                   | 0x8000 |
| * NullableBitmap8                                                   | 0x8001 |
| * NullableBitmap16                                                  | 0x8002 |
| * NullableBitmap32                                                  | 0x8003 |
| * NullableBitmap64                                                  | 0x8004 |
| * NullableInt8u                                                     | 0x8005 |
| * NullableInt16u                                                    | 0x8006 |
| * NullableInt24u                                                    | 0x8007 |
| * NullableInt32u                                                    | 0x8008 |
| * NullableInt40u                                                    | 0x8009 |
| * NullableInt48u                                                    | 0x800A |
| * NullableInt56u                                                    | 0x800B |
| * NullableInt64u                                                    | 0x800C |
| * NullableInt8s                                                     | 0x800D |
| * NullableInt16s                                                    | 0x800E |
| * NullableInt24s                                                    | 0x800F |
| * NullableInt32s                                                    | 0x8010 |
| * NullableInt40s                                                    | 0x8011 |
| * NullableInt48s                                                    | 0x8012 |
| * NullableInt56s                                                    | 0x8013 |
| * NullableInt64s                                                    | 0x8014 |
| * NullableEnum8                                                     | 0x8015 |
| * NullableEnum16                                                    | 0x8016 |
| * NullableFloatSingle                                               | 0x8017 |
| * NullableFloatDouble                                               | 0x8018 |
| * NullableOctetString                                               | 0x8019 |
| * NullableCharString                                                | 0x801E |
| * NullableEnumAttr                                                  | 0x8024 |
| * NullableStruct                                                    | 0x8025 |
| * NullableRangeRestrictedInt8u                                      | 0x8026 |
| * NullableRangeRestrictedInt8s                                      | 0x8027 |
| * NullableRangeRestrictedInt16u                                     | 0x8028 |
| * NullableRangeRestrictedInt16s                                     | 0x8029 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * TestEvent                                                         | 0x0001 |
\*----------------------------------------------------------------------------*/

/*
 * Command SimpleStructEchoRequest
 */
class TestClusterSimpleStructEchoRequest : public ModelCommand
{
public:
    TestClusterSimpleStructEchoRequest() : ModelCommand("simple-struct-echo-request")
    {
        // arg1 Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000011) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterSimpleStructResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::SimpleStructEchoRequest::Type mRequest;
};

/*
 * Command Test
 */
class TestClusterTest : public ModelCommand
{
public:
    TestClusterTest() : ModelCommand("test") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::Test::Type mRequest;
};

/*
 * Command TestAddArguments
 */
class TestClusterTestAddArguments : public ModelCommand
{
public:
    TestClusterTestAddArguments() : ModelCommand("test-add-arguments")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mRequest.arg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mRequest.arg2);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestAddArgumentsResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type mRequest;
};

/*
 * Command TestEmitTestEventRequest
 */
class TestClusterTestEmitTestEventRequest : public ModelCommand
{
public:
    TestClusterTestEmitTestEventRequest() : ModelCommand("test-emit-test-event-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mRequest.arg1);
        AddArgument("Arg2", 0, UINT8_MAX, reinterpret_cast<std::underlying_type_t<decltype(mRequest.arg2)> *>(&mRequest.arg2));
        AddArgument("Arg3", 0, 1, &mRequest.arg3);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000014) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestEmitTestEventResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestEmitTestEventRequest::Type mRequest;
};

/*
 * Command TestEnumsRequest
 */
class TestClusterTestEnumsRequest : public ModelCommand
{
public:
    TestClusterTestEnumsRequest() : ModelCommand("test-enums-request")
    {
        AddArgument("Arg1", 0, UINT16_MAX, &mRequest.arg1);
        AddArgument("Arg2", 0, UINT8_MAX, reinterpret_cast<std::underlying_type_t<decltype(mRequest.arg2)> *>(&mRequest.arg2));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000E) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestEnumsResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type mRequest;
};

/*
 * Command TestListInt8UArgumentRequest
 */
class TestClusterTestListInt8UArgumentRequest : public ModelCommand
{
public:
    TestClusterTestListInt8UArgumentRequest() : ModelCommand("test-list-int8uargument-request")
    {
        // arg1 Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type mRequest;
};

/*
 * Command TestListInt8UReverseRequest
 */
class TestClusterTestListInt8UReverseRequest : public ModelCommand
{
public:
    TestClusterTestListInt8UReverseRequest() : ModelCommand("test-list-int8ureverse-request")
    {
        // arg1 Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000D) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestListInt8UReverseResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type mRequest;
};

/*
 * Command TestListNestedStructListArgumentRequest
 */
class TestClusterTestListNestedStructListArgumentRequest : public ModelCommand
{
public:
    TestClusterTestListNestedStructListArgumentRequest() : ModelCommand("test-list-nested-struct-list-argument-request")
    {
        // arg1 Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000C) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type mRequest;
};

/*
 * Command TestListStructArgumentRequest
 */
class TestClusterTestListStructArgumentRequest : public ModelCommand
{
public:
    TestClusterTestListStructArgumentRequest() : ModelCommand("test-list-struct-argument-request")
    {
        // arg1 Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000009) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type mRequest;
};

/*
 * Command TestNestedStructArgumentRequest
 */
class TestClusterTestNestedStructArgumentRequest : public ModelCommand
{
public:
    TestClusterTestNestedStructArgumentRequest() : ModelCommand("test-nested-struct-argument-request")
    {
        // arg1 Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000008) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type mRequest;
};

/*
 * Command TestNestedStructListArgumentRequest
 */
class TestClusterTestNestedStructListArgumentRequest : public ModelCommand
{
public:
    TestClusterTestNestedStructListArgumentRequest() : ModelCommand("test-nested-struct-list-argument-request")
    {
        // arg1 Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type mRequest;
};

/*
 * Command TestNotHandled
 */
class TestClusterTestNotHandled : public ModelCommand
{
public:
    TestClusterTestNotHandled() : ModelCommand("test-not-handled") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type mRequest;
};

/*
 * Command TestNullableOptionalRequest
 */
class TestClusterTestNullableOptionalRequest : public ModelCommand
{
public:
    TestClusterTestNullableOptionalRequest() : ModelCommand("test-nullable-optional-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mRequest.arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000F) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestNullableOptionalResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type mRequest;
};

/*
 * Command TestSimpleOptionalArgumentRequest
 */
class TestClusterTestSimpleOptionalArgumentRequest : public ModelCommand
{
public:
    TestClusterTestSimpleOptionalArgumentRequest() : ModelCommand("test-simple-optional-argument-request")
    {
        AddArgument("Arg1", 0, 1, &mRequest.arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000013) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type mRequest;
};

/*
 * Command TestSpecific
 */
class TestClusterTestSpecific : public ModelCommand
{
public:
    TestClusterTestSpecific() : ModelCommand("test-specific") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestSpecificResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestSpecific::Type mRequest;
};

/*
 * Command TestStructArgumentRequest
 */
class TestClusterTestStructArgumentRequest : public ModelCommand
{
public:
    TestClusterTestStructArgumentRequest() : ModelCommand("test-struct-argument-request")
    {
        // arg1 Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000007) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type mRequest;
};

/*
 * Command TestUnknownCommand
 */
class TestClusterTestUnknownCommand : public ModelCommand
{
public:
    TestClusterTestUnknownCommand() : ModelCommand("test-unknown-command") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestUnknownCommand::Type mRequest;
};

/*
 * Command TimedInvokeRequest
 */
class TestClusterTimedInvokeRequest : public ModelCommand
{
public:
    TestClusterTimedInvokeRequest() : ModelCommand("timed-invoke-request") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000012) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventTestClusterWildcard : public ModelCommand
{
public:
    ReadEventTestClusterWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventTestClusterWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000050F, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventTestClusterWildcard : public ModelCommand
{
public:
    ReportEventTestClusterWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventTestClusterWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000050F, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event TestEvent
 */
class ReadTestClusterTestEvent : public ModelCommand
{
public:
    ReadTestClusterTestEvent() : ModelCommand("read-event")
    {
        AddArgument("event-name", "test-event");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterTestEvent() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x0000050F, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.TestEvent report", 0, value);
    }
};

class ReportTestClusterTestEvent : public ModelCommand
{
public:
    ReportTestClusterTestEvent() : ModelCommand("report-event")
    {
        AddArgument("event-name", "test-event");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterTestEvent() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x0000050F, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.TestEvent report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadTestClusterWildcard : public ModelCommand
{
public:
    ReadTestClusterWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterWildcard : public ModelCommand
{
public:
    ReportTestClusterWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Boolean
 */
class ReadTestClusterBoolean : public ModelCommand
{
public:
    ReadTestClusterBoolean() : ModelCommand("read")
    {
        AddArgument("attr-name", "boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBoolean() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Boolean report", 0, value);
    }
};

class WriteTestClusterBoolean : public ModelCommand
{
public:
    WriteTestClusterBoolean() : ModelCommand("write")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBoolean() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000000, mValue);
    }

private:
    bool mValue;
};

class ReportTestClusterBoolean : public ModelCommand
{
public:
    ReportTestClusterBoolean() : ModelCommand("report")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBoolean() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Boolean report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap8
 */
class ReadTestClusterBitmap8 : public ModelCommand
{
public:
    ReadTestClusterBitmap8() : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Bitmap8 report", 0, value);
    }
};

class WriteTestClusterBitmap8 : public ModelCommand
{
public:
    WriteTestClusterBitmap8() : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000001, mValue);
    }

private:
    uint8_t mValue;
};

class ReportTestClusterBitmap8 : public ModelCommand
{
public:
    ReportTestClusterBitmap8() : ModelCommand("report")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Bitmap8 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap16
 */
class ReadTestClusterBitmap16 : public ModelCommand
{
public:
    ReadTestClusterBitmap16() : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Bitmap16 report", 0, value);
    }
};

class WriteTestClusterBitmap16 : public ModelCommand
{
public:
    WriteTestClusterBitmap16() : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000002, mValue);
    }

private:
    uint16_t mValue;
};

class ReportTestClusterBitmap16 : public ModelCommand
{
public:
    ReportTestClusterBitmap16() : ModelCommand("report")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Bitmap16 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap32
 */
class ReadTestClusterBitmap32 : public ModelCommand
{
public:
    ReadTestClusterBitmap32() : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Bitmap32 report", 0, value);
    }
};

class WriteTestClusterBitmap32 : public ModelCommand
{
public:
    WriteTestClusterBitmap32() : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000003, mValue);
    }

private:
    uint32_t mValue;
};

class ReportTestClusterBitmap32 : public ModelCommand
{
public:
    ReportTestClusterBitmap32() : ModelCommand("report")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Bitmap32 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap64
 */
class ReadTestClusterBitmap64 : public ModelCommand
{
public:
    ReadTestClusterBitmap64() : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Bitmap64 report", 0, value);
    }
};

class WriteTestClusterBitmap64 : public ModelCommand
{
public:
    WriteTestClusterBitmap64() : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000004, mValue);
    }

private:
    uint64_t mValue;
};

class ReportTestClusterBitmap64 : public ModelCommand
{
public:
    ReportTestClusterBitmap64() : ModelCommand("report")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Bitmap64 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8u
 */
class ReadTestClusterInt8u : public ModelCommand
{
public:
    ReadTestClusterInt8u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int8u report", 0, value);
    }
};

class WriteTestClusterInt8u : public ModelCommand
{
public:
    WriteTestClusterInt8u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000005, mValue);
    }

private:
    uint8_t mValue;
};

class ReportTestClusterInt8u : public ModelCommand
{
public:
    ReportTestClusterInt8u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int8u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16u
 */
class ReadTestClusterInt16u : public ModelCommand
{
public:
    ReadTestClusterInt16u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int16u report", 0, value);
    }
};

class WriteTestClusterInt16u : public ModelCommand
{
public:
    WriteTestClusterInt16u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000006, mValue);
    }

private:
    uint16_t mValue;
};

class ReportTestClusterInt16u : public ModelCommand
{
public:
    ReportTestClusterInt16u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int16u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int24u
 */
class ReadTestClusterInt24u : public ModelCommand
{
public:
    ReadTestClusterInt24u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int24u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt24u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int24u report", 0, value);
    }
};

class WriteTestClusterInt24u : public ModelCommand
{
public:
    WriteTestClusterInt24u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int24u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt24u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000007, mValue);
    }

private:
    uint32_t mValue;
};

class ReportTestClusterInt24u : public ModelCommand
{
public:
    ReportTestClusterInt24u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int24u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt24u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int24u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32u
 */
class ReadTestClusterInt32u : public ModelCommand
{
public:
    ReadTestClusterInt32u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int32u report", 0, value);
    }
};

class WriteTestClusterInt32u : public ModelCommand
{
public:
    WriteTestClusterInt32u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000008, mValue);
    }

private:
    uint32_t mValue;
};

class ReportTestClusterInt32u : public ModelCommand
{
public:
    ReportTestClusterInt32u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt32u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int32u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int40u
 */
class ReadTestClusterInt40u : public ModelCommand
{
public:
    ReadTestClusterInt40u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int40u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt40u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000009);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int40u report", 0, value);
    }
};

class WriteTestClusterInt40u : public ModelCommand
{
public:
    WriteTestClusterInt40u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int40u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt40u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000009, mValue);
    }

private:
    uint64_t mValue;
};

class ReportTestClusterInt40u : public ModelCommand
{
public:
    ReportTestClusterInt40u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int40u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt40u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000009, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int40u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int48u
 */
class ReadTestClusterInt48u : public ModelCommand
{
public:
    ReadTestClusterInt48u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int48u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt48u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000000A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int48u report", 0, value);
    }
};

class WriteTestClusterInt48u : public ModelCommand
{
public:
    WriteTestClusterInt48u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int48u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt48u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000000A, mValue);
    }

private:
    uint64_t mValue;
};

class ReportTestClusterInt48u : public ModelCommand
{
public:
    ReportTestClusterInt48u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int48u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt48u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000000A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int48u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int56u
 */
class ReadTestClusterInt56u : public ModelCommand
{
public:
    ReadTestClusterInt56u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int56u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt56u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000000B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int56u report", 0, value);
    }
};

class WriteTestClusterInt56u : public ModelCommand
{
public:
    WriteTestClusterInt56u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int56u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt56u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000000B, mValue);
    }

private:
    uint64_t mValue;
};

class ReportTestClusterInt56u : public ModelCommand
{
public:
    ReportTestClusterInt56u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int56u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt56u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000000B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int56u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64u
 */
class ReadTestClusterInt64u : public ModelCommand
{
public:
    ReadTestClusterInt64u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000000C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int64u report", 0, value);
    }
};

class WriteTestClusterInt64u : public ModelCommand
{
public:
    WriteTestClusterInt64u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000000C, mValue);
    }

private:
    uint64_t mValue;
};

class ReportTestClusterInt64u : public ModelCommand
{
public:
    ReportTestClusterInt64u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt64u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000000C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int64u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8s
 */
class ReadTestClusterInt8s : public ModelCommand
{
public:
    ReadTestClusterInt8s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000000D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int8s report", 0, value);
    }
};

class WriteTestClusterInt8s : public ModelCommand
{
public:
    WriteTestClusterInt8s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000000D, mValue);
    }

private:
    int8_t mValue;
};

class ReportTestClusterInt8s : public ModelCommand
{
public:
    ReportTestClusterInt8s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000000D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int8s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16s
 */
class ReadTestClusterInt16s : public ModelCommand
{
public:
    ReadTestClusterInt16s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000000E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int16s report", 0, value);
    }
};

class WriteTestClusterInt16s : public ModelCommand
{
public:
    WriteTestClusterInt16s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000000E, mValue);
    }

private:
    int16_t mValue;
};

class ReportTestClusterInt16s : public ModelCommand
{
public:
    ReportTestClusterInt16s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000000E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int16s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int24s
 */
class ReadTestClusterInt24s : public ModelCommand
{
public:
    ReadTestClusterInt24s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int24s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt24s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000000F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int24s report", 0, value);
    }
};

class WriteTestClusterInt24s : public ModelCommand
{
public:
    WriteTestClusterInt24s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int24s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt24s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000000F, mValue);
    }

private:
    int32_t mValue;
};

class ReportTestClusterInt24s : public ModelCommand
{
public:
    ReportTestClusterInt24s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int24s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt24s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000000F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int24s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32s
 */
class ReadTestClusterInt32s : public ModelCommand
{
public:
    ReadTestClusterInt32s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int32s report", 0, value);
    }
};

class WriteTestClusterInt32s : public ModelCommand
{
public:
    WriteTestClusterInt32s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000010, mValue);
    }

private:
    int32_t mValue;
};

class ReportTestClusterInt32s : public ModelCommand
{
public:
    ReportTestClusterInt32s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt32s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int32s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int40s
 */
class ReadTestClusterInt40s : public ModelCommand
{
public:
    ReadTestClusterInt40s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int40s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt40s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int40s report", 0, value);
    }
};

class WriteTestClusterInt40s : public ModelCommand
{
public:
    WriteTestClusterInt40s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int40s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt40s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000011, mValue);
    }

private:
    int64_t mValue;
};

class ReportTestClusterInt40s : public ModelCommand
{
public:
    ReportTestClusterInt40s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int40s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt40s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int40s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int48s
 */
class ReadTestClusterInt48s : public ModelCommand
{
public:
    ReadTestClusterInt48s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int48s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt48s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int48s report", 0, value);
    }
};

class WriteTestClusterInt48s : public ModelCommand
{
public:
    WriteTestClusterInt48s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int48s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt48s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000012, mValue);
    }

private:
    int64_t mValue;
};

class ReportTestClusterInt48s : public ModelCommand
{
public:
    ReportTestClusterInt48s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int48s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt48s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int48s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int56s
 */
class ReadTestClusterInt56s : public ModelCommand
{
public:
    ReadTestClusterInt56s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int56s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt56s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000013);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int56s report", 0, value);
    }
};

class WriteTestClusterInt56s : public ModelCommand
{
public:
    WriteTestClusterInt56s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int56s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt56s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000013, mValue);
    }

private:
    int64_t mValue;
};

class ReportTestClusterInt56s : public ModelCommand
{
public:
    ReportTestClusterInt56s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int56s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt56s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000013, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int56s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64s
 */
class ReadTestClusterInt64s : public ModelCommand
{
public:
    ReadTestClusterInt64s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000014);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int64s report", 0, value);
    }
};

class WriteTestClusterInt64s : public ModelCommand
{
public:
    WriteTestClusterInt64s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000014, mValue);
    }

private:
    int64_t mValue;
};

class ReportTestClusterInt64s : public ModelCommand
{
public:
    ReportTestClusterInt64s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt64s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000014, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Int64s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum8
 */
class ReadTestClusterEnum8 : public ModelCommand
{
public:
    ReadTestClusterEnum8() : ModelCommand("read")
    {
        AddArgument("attr-name", "enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000015);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Enum8 report", 0, value);
    }
};

class WriteTestClusterEnum8 : public ModelCommand
{
public:
    WriteTestClusterEnum8() : ModelCommand("write")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000015, mValue);
    }

private:
    uint8_t mValue;
};

class ReportTestClusterEnum8 : public ModelCommand
{
public:
    ReportTestClusterEnum8() : ModelCommand("report")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEnum8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000015, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Enum8 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum16
 */
class ReadTestClusterEnum16 : public ModelCommand
{
public:
    ReadTestClusterEnum16() : ModelCommand("read")
    {
        AddArgument("attr-name", "enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000016);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Enum16 report", 0, value);
    }
};

class WriteTestClusterEnum16 : public ModelCommand
{
public:
    WriteTestClusterEnum16() : ModelCommand("write")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000016, mValue);
    }

private:
    uint16_t mValue;
};

class ReportTestClusterEnum16 : public ModelCommand
{
public:
    ReportTestClusterEnum16() : ModelCommand("report")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEnum16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000016, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Enum16 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FloatSingle
 */
class ReadTestClusterFloatSingle : public ModelCommand
{
public:
    ReadTestClusterFloatSingle() : ModelCommand("read")
    {
        AddArgument("attr-name", "float-single");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000017);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        float value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.FloatSingle report", 0, value);
    }
};

class WriteTestClusterFloatSingle : public ModelCommand
{
public:
    WriteTestClusterFloatSingle() : ModelCommand("write")
    {
        AddArgument("attr-name", "float-single");
        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000017, mValue);
    }

private:
    float mValue;
};

class ReportTestClusterFloatSingle : public ModelCommand
{
public:
    ReportTestClusterFloatSingle() : ModelCommand("report")
    {
        AddArgument("attr-name", "float-single");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000017, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        float value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.FloatSingle report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FloatDouble
 */
class ReadTestClusterFloatDouble : public ModelCommand
{
public:
    ReadTestClusterFloatDouble() : ModelCommand("read")
    {
        AddArgument("attr-name", "float-double");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000018);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        double value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.FloatDouble report", 0, value);
    }
};

class WriteTestClusterFloatDouble : public ModelCommand
{
public:
    WriteTestClusterFloatDouble() : ModelCommand("write")
    {
        AddArgument("attr-name", "float-double");
        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000018, mValue);
    }

private:
    double mValue;
};

class ReportTestClusterFloatDouble : public ModelCommand
{
public:
    ReportTestClusterFloatDouble() : ModelCommand("report")
    {
        AddArgument("attr-name", "float-double");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000018, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        double value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.FloatDouble report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OctetString
 */
class ReadTestClusterOctetString : public ModelCommand
{
public:
    ReadTestClusterOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000019);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.OctetString report", 0, value);
    }
};

class WriteTestClusterOctetString : public ModelCommand
{
public:
    WriteTestClusterOctetString() : ModelCommand("write")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000019, mValue);
    }

private:
    chip::ByteSpan mValue;
};

class ReportTestClusterOctetString : public ModelCommand
{
public:
    ReportTestClusterOctetString() : ModelCommand("report")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000019, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.OctetString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListInt8u
 */
class ReadTestClusterListInt8u : public ModelCommand
{
public:
    ReadTestClusterListInt8u() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000001A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListInt8u report", 0, value);
    }
};

class ReportTestClusterListInt8u : public ModelCommand
{
public:
    ReportTestClusterListInt8u() : ModelCommand("report")
    {
        AddArgument("attr-name", "list-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000001A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListInt8u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListOctetString
 */
class ReadTestClusterListOctetString : public ModelCommand
{
public:
    ReadTestClusterListOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000001B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ByteSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListOctetString report", 0, value);
    }
};

class ReportTestClusterListOctetString : public ModelCommand
{
public:
    ReportTestClusterListOctetString() : ModelCommand("report")
    {
        AddArgument("attr-name", "list-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000001B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ByteSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListOctetString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListStructOctetString
 */
class ReadTestClusterListStructOctetString : public ModelCommand
{
public:
    ReadTestClusterListStructOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000001C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListStructOctetString report", 0, value);
    }
};

class ReportTestClusterListStructOctetString : public ModelCommand
{
public:
    ReportTestClusterListStructOctetString() : ModelCommand("report")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000001C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListStructOctetString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongOctetString
 */
class ReadTestClusterLongOctetString : public ModelCommand
{
public:
    ReadTestClusterLongOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000001D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.LongOctetString report", 0, value);
    }
};

class WriteTestClusterLongOctetString : public ModelCommand
{
public:
    WriteTestClusterLongOctetString() : ModelCommand("write")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000001D, mValue);
    }

private:
    chip::ByteSpan mValue;
};

class ReportTestClusterLongOctetString : public ModelCommand
{
public:
    ReportTestClusterLongOctetString() : ModelCommand("report")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000001D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.LongOctetString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CharString
 */
class ReadTestClusterCharString : public ModelCommand
{
public:
    ReadTestClusterCharString() : ModelCommand("read")
    {
        AddArgument("attr-name", "char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000001E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.CharString report", 0, value);
    }
};

class WriteTestClusterCharString : public ModelCommand
{
public:
    WriteTestClusterCharString() : ModelCommand("write")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000001E, mValue);
    }

private:
    chip::CharSpan mValue;
};

class ReportTestClusterCharString : public ModelCommand
{
public:
    ReportTestClusterCharString() : ModelCommand("report")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000001E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.CharString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongCharString
 */
class ReadTestClusterLongCharString : public ModelCommand
{
public:
    ReadTestClusterLongCharString() : ModelCommand("read")
    {
        AddArgument("attr-name", "long-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000001F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.LongCharString report", 0, value);
    }
};

class WriteTestClusterLongCharString : public ModelCommand
{
public:
    WriteTestClusterLongCharString() : ModelCommand("write")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000001F, mValue);
    }

private:
    chip::CharSpan mValue;
};

class ReportTestClusterLongCharString : public ModelCommand
{
public:
    ReportTestClusterLongCharString() : ModelCommand("report")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000001F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.LongCharString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochUs
 */
class ReadTestClusterEpochUs : public ModelCommand
{
public:
    ReadTestClusterEpochUs() : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-us");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000020);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.EpochUs report", 0, value);
    }
};

class WriteTestClusterEpochUs : public ModelCommand
{
public:
    WriteTestClusterEpochUs() : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000020, mValue);
    }

private:
    uint64_t mValue;
};

class ReportTestClusterEpochUs : public ModelCommand
{
public:
    ReportTestClusterEpochUs() : ModelCommand("report")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000020, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.EpochUs report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochS
 */
class ReadTestClusterEpochS : public ModelCommand
{
public:
    ReadTestClusterEpochS() : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochS() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000021);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.EpochS report", 0, value);
    }
};

class WriteTestClusterEpochS : public ModelCommand
{
public:
    WriteTestClusterEpochS() : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochS() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000021, mValue);
    }

private:
    uint32_t mValue;
};

class ReportTestClusterEpochS : public ModelCommand
{
public:
    ReportTestClusterEpochS() : ModelCommand("report")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEpochS() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000021, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.EpochS report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorId
 */
class ReadTestClusterVendorId : public ModelCommand
{
public:
    ReadTestClusterVendorId() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterVendorId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000022);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::VendorId value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.VendorId report", 0, value);
    }
};

class WriteTestClusterVendorId : public ModelCommand
{
public:
    WriteTestClusterVendorId() : ModelCommand("write")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterVendorId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000022, mValue);
    }

private:
    chip::VendorId mValue;
};

class ReportTestClusterVendorId : public ModelCommand
{
public:
    ReportTestClusterVendorId() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterVendorId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000022, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::VendorId value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.VendorId report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListNullablesAndOptionalsStruct
 */
class ReadTestClusterListNullablesAndOptionalsStruct : public ModelCommand
{
public:
    ReadTestClusterListNullablesAndOptionalsStruct() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000023);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListNullablesAndOptionalsStruct report", 0, value);
    }
};

class ReportTestClusterListNullablesAndOptionalsStruct : public ModelCommand
{
public:
    ReportTestClusterListNullablesAndOptionalsStruct() : ModelCommand("report")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000023, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListNullablesAndOptionalsStruct report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnumAttr
 */
class ReadTestClusterEnumAttr : public ModelCommand
{
public:
    ReadTestClusterEnumAttr() : ModelCommand("read")
    {
        AddArgument("attr-name", "enum-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000024);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::TestCluster::SimpleEnum value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.EnumAttr report", 0, value);
    }
};

class WriteTestClusterEnumAttr : public ModelCommand
{
public:
    WriteTestClusterEnumAttr() : ModelCommand("write")
    {
        AddArgument("attr-name", "enum-attr");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000024, mValue);
    }

private:
    chip::app::Clusters::TestCluster::SimpleEnum mValue;
};

class ReportTestClusterEnumAttr : public ModelCommand
{
public:
    ReportTestClusterEnumAttr() : ModelCommand("report")
    {
        AddArgument("attr-name", "enum-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000024, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::Clusters::TestCluster::SimpleEnum value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.EnumAttr report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt8u
 */
class ReadTestClusterRangeRestrictedInt8u : public ModelCommand
{
public:
    ReadTestClusterRangeRestrictedInt8u() : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000026);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.RangeRestrictedInt8u report", 0, value);
    }
};

class WriteTestClusterRangeRestrictedInt8u : public ModelCommand
{
public:
    WriteTestClusterRangeRestrictedInt8u() : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000026, mValue);
    }

private:
    uint8_t mValue;
};

class ReportTestClusterRangeRestrictedInt8u : public ModelCommand
{
public:
    ReportTestClusterRangeRestrictedInt8u() : ModelCommand("report")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000026, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.RangeRestrictedInt8u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt8s
 */
class ReadTestClusterRangeRestrictedInt8s : public ModelCommand
{
public:
    ReadTestClusterRangeRestrictedInt8s() : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000027);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.RangeRestrictedInt8s report", 0, value);
    }
};

class WriteTestClusterRangeRestrictedInt8s : public ModelCommand
{
public:
    WriteTestClusterRangeRestrictedInt8s() : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000027, mValue);
    }

private:
    int8_t mValue;
};

class ReportTestClusterRangeRestrictedInt8s : public ModelCommand
{
public:
    ReportTestClusterRangeRestrictedInt8s() : ModelCommand("report")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000027, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.RangeRestrictedInt8s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt16u
 */
class ReadTestClusterRangeRestrictedInt16u : public ModelCommand
{
public:
    ReadTestClusterRangeRestrictedInt16u() : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000028);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.RangeRestrictedInt16u report", 0, value);
    }
};

class WriteTestClusterRangeRestrictedInt16u : public ModelCommand
{
public:
    WriteTestClusterRangeRestrictedInt16u() : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000028, mValue);
    }

private:
    uint16_t mValue;
};

class ReportTestClusterRangeRestrictedInt16u : public ModelCommand
{
public:
    ReportTestClusterRangeRestrictedInt16u() : ModelCommand("report")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000028, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.RangeRestrictedInt16u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt16s
 */
class ReadTestClusterRangeRestrictedInt16s : public ModelCommand
{
public:
    ReadTestClusterRangeRestrictedInt16s() : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000029);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.RangeRestrictedInt16s report", 0, value);
    }
};

class WriteTestClusterRangeRestrictedInt16s : public ModelCommand
{
public:
    WriteTestClusterRangeRestrictedInt16s() : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000029, mValue);
    }

private:
    int16_t mValue;
};

class ReportTestClusterRangeRestrictedInt16s : public ModelCommand
{
public:
    ReportTestClusterRangeRestrictedInt16s() : ModelCommand("report")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00000029, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.RangeRestrictedInt16s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListLongOctetString
 */
class ReadTestClusterListLongOctetString : public ModelCommand
{
public:
    ReadTestClusterListLongOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListLongOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000002A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::ByteSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ListLongOctetString report", 0, value);
    }
};

/*
 * Attribute TimedWriteBoolean
 */
class ReadTestClusterTimedWriteBoolean : public ModelCommand
{
public:
    ReadTestClusterTimedWriteBoolean() : ModelCommand("read")
    {
        AddArgument("attr-name", "timed-write-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00000030);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.TimedWriteBoolean report", 0, value);
    }
};

class WriteTestClusterTimedWriteBoolean : public ModelCommand
{
public:
    WriteTestClusterTimedWriteBoolean() : ModelCommand("write")
    {
        AddArgument("attr-name", "timed-write-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00000030, mValue);
    }

private:
    bool mValue;
};

/*
 * Attribute Unsupported
 */
class ReadTestClusterUnsupported : public ModelCommand
{
public:
    ReadTestClusterUnsupported() : ModelCommand("read")
    {
        AddArgument("attr-name", "unsupported");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x000000FF);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Unsupported report", 0, value);
    }
};

class WriteTestClusterUnsupported : public ModelCommand
{
public:
    WriteTestClusterUnsupported() : ModelCommand("write")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x000000FF, mValue);
    }

private:
    bool mValue;
};

class ReportTestClusterUnsupported : public ModelCommand
{
public:
    ReportTestClusterUnsupported() : ModelCommand("report")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x000000FF, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        bool value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.Unsupported report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBoolean
 */
class ReadTestClusterNullableBoolean : public ModelCommand
{
public:
    ReadTestClusterNullableBoolean() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<bool> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBoolean report", 0, value);
    }
};

class WriteTestClusterNullableBoolean : public ModelCommand
{
public:
    WriteTestClusterNullableBoolean() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008000, mValue);
    }

private:
    chip::app::DataModel::Nullable<bool> mValue;
};

class ReportTestClusterNullableBoolean : public ModelCommand
{
public:
    ReportTestClusterNullableBoolean() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<bool> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBoolean report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap8
 */
class ReadTestClusterNullableBitmap8 : public ModelCommand
{
public:
    ReadTestClusterNullableBitmap8() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBitmap8 report", 0, value);
    }
};

class WriteTestClusterNullableBitmap8 : public ModelCommand
{
public:
    WriteTestClusterNullableBitmap8() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008001, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint8_t> mValue;
};

class ReportTestClusterNullableBitmap8 : public ModelCommand
{
public:
    ReportTestClusterNullableBitmap8() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBitmap8 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap16
 */
class ReadTestClusterNullableBitmap16 : public ModelCommand
{
public:
    ReadTestClusterNullableBitmap16() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBitmap16 report", 0, value);
    }
};

class WriteTestClusterNullableBitmap16 : public ModelCommand
{
public:
    WriteTestClusterNullableBitmap16() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008002, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint16_t> mValue;
};

class ReportTestClusterNullableBitmap16 : public ModelCommand
{
public:
    ReportTestClusterNullableBitmap16() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBitmap16 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap32
 */
class ReadTestClusterNullableBitmap32 : public ModelCommand
{
public:
    ReadTestClusterNullableBitmap32() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBitmap32 report", 0, value);
    }
};

class WriteTestClusterNullableBitmap32 : public ModelCommand
{
public:
    WriteTestClusterNullableBitmap32() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008003, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint32_t> mValue;
};

class ReportTestClusterNullableBitmap32 : public ModelCommand
{
public:
    ReportTestClusterNullableBitmap32() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBitmap32 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap64
 */
class ReadTestClusterNullableBitmap64 : public ModelCommand
{
public:
    ReadTestClusterNullableBitmap64() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBitmap64 report", 0, value);
    }
};

class WriteTestClusterNullableBitmap64 : public ModelCommand
{
public:
    WriteTestClusterNullableBitmap64() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008004, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint64_t> mValue;
};

class ReportTestClusterNullableBitmap64 : public ModelCommand
{
public:
    ReportTestClusterNullableBitmap64() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableBitmap64 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8u
 */
class ReadTestClusterNullableInt8u : public ModelCommand
{
public:
    ReadTestClusterNullableInt8u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt8u report", 0, value);
    }
};

class WriteTestClusterNullableInt8u : public ModelCommand
{
public:
    WriteTestClusterNullableInt8u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008005, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint8_t> mValue;
};

class ReportTestClusterNullableInt8u : public ModelCommand
{
public:
    ReportTestClusterNullableInt8u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt8u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16u
 */
class ReadTestClusterNullableInt16u : public ModelCommand
{
public:
    ReadTestClusterNullableInt16u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt16u report", 0, value);
    }
};

class WriteTestClusterNullableInt16u : public ModelCommand
{
public:
    WriteTestClusterNullableInt16u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008006, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint16_t> mValue;
};

class ReportTestClusterNullableInt16u : public ModelCommand
{
public:
    ReportTestClusterNullableInt16u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt16u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt24u
 */
class ReadTestClusterNullableInt24u : public ModelCommand
{
public:
    ReadTestClusterNullableInt24u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int24u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt24u report", 0, value);
    }
};

class WriteTestClusterNullableInt24u : public ModelCommand
{
public:
    WriteTestClusterNullableInt24u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int24u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008007, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint32_t> mValue;
};

class ReportTestClusterNullableInt24u : public ModelCommand
{
public:
    ReportTestClusterNullableInt24u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int24u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt24u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32u
 */
class ReadTestClusterNullableInt32u : public ModelCommand
{
public:
    ReadTestClusterNullableInt32u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt32u report", 0, value);
    }
};

class WriteTestClusterNullableInt32u : public ModelCommand
{
public:
    WriteTestClusterNullableInt32u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008008, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint32_t> mValue;
};

class ReportTestClusterNullableInt32u : public ModelCommand
{
public:
    ReportTestClusterNullableInt32u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt32u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt40u
 */
class ReadTestClusterNullableInt40u : public ModelCommand
{
public:
    ReadTestClusterNullableInt40u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int40u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008009);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt40u report", 0, value);
    }
};

class WriteTestClusterNullableInt40u : public ModelCommand
{
public:
    WriteTestClusterNullableInt40u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int40u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008009, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint64_t> mValue;
};

class ReportTestClusterNullableInt40u : public ModelCommand
{
public:
    ReportTestClusterNullableInt40u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int40u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008009, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt40u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt48u
 */
class ReadTestClusterNullableInt48u : public ModelCommand
{
public:
    ReadTestClusterNullableInt48u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int48u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000800A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt48u report", 0, value);
    }
};

class WriteTestClusterNullableInt48u : public ModelCommand
{
public:
    WriteTestClusterNullableInt48u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int48u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000800A, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint64_t> mValue;
};

class ReportTestClusterNullableInt48u : public ModelCommand
{
public:
    ReportTestClusterNullableInt48u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int48u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000800A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt48u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt56u
 */
class ReadTestClusterNullableInt56u : public ModelCommand
{
public:
    ReadTestClusterNullableInt56u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int56u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000800B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt56u report", 0, value);
    }
};

class WriteTestClusterNullableInt56u : public ModelCommand
{
public:
    WriteTestClusterNullableInt56u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int56u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000800B, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint64_t> mValue;
};

class ReportTestClusterNullableInt56u : public ModelCommand
{
public:
    ReportTestClusterNullableInt56u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int56u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000800B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt56u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64u
 */
class ReadTestClusterNullableInt64u : public ModelCommand
{
public:
    ReadTestClusterNullableInt64u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000800C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt64u report", 0, value);
    }
};

class WriteTestClusterNullableInt64u : public ModelCommand
{
public:
    WriteTestClusterNullableInt64u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000800C, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint64_t> mValue;
};

class ReportTestClusterNullableInt64u : public ModelCommand
{
public:
    ReportTestClusterNullableInt64u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000800C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt64u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8s
 */
class ReadTestClusterNullableInt8s : public ModelCommand
{
public:
    ReadTestClusterNullableInt8s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000800D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt8s report", 0, value);
    }
};

class WriteTestClusterNullableInt8s : public ModelCommand
{
public:
    WriteTestClusterNullableInt8s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000800D, mValue);
    }

private:
    chip::app::DataModel::Nullable<int8_t> mValue;
};

class ReportTestClusterNullableInt8s : public ModelCommand
{
public:
    ReportTestClusterNullableInt8s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000800D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt8s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16s
 */
class ReadTestClusterNullableInt16s : public ModelCommand
{
public:
    ReadTestClusterNullableInt16s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000800E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt16s report", 0, value);
    }
};

class WriteTestClusterNullableInt16s : public ModelCommand
{
public:
    WriteTestClusterNullableInt16s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000800E, mValue);
    }

private:
    chip::app::DataModel::Nullable<int16_t> mValue;
};

class ReportTestClusterNullableInt16s : public ModelCommand
{
public:
    ReportTestClusterNullableInt16s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000800E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt16s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt24s
 */
class ReadTestClusterNullableInt24s : public ModelCommand
{
public:
    ReadTestClusterNullableInt24s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int24s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000800F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt24s report", 0, value);
    }
};

class WriteTestClusterNullableInt24s : public ModelCommand
{
public:
    WriteTestClusterNullableInt24s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int24s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000800F, mValue);
    }

private:
    chip::app::DataModel::Nullable<int32_t> mValue;
};

class ReportTestClusterNullableInt24s : public ModelCommand
{
public:
    ReportTestClusterNullableInt24s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int24s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000800F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt24s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32s
 */
class ReadTestClusterNullableInt32s : public ModelCommand
{
public:
    ReadTestClusterNullableInt32s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt32s report", 0, value);
    }
};

class WriteTestClusterNullableInt32s : public ModelCommand
{
public:
    WriteTestClusterNullableInt32s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008010, mValue);
    }

private:
    chip::app::DataModel::Nullable<int32_t> mValue;
};

class ReportTestClusterNullableInt32s : public ModelCommand
{
public:
    ReportTestClusterNullableInt32s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int32_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt32s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt40s
 */
class ReadTestClusterNullableInt40s : public ModelCommand
{
public:
    ReadTestClusterNullableInt40s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int40s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt40s report", 0, value);
    }
};

class WriteTestClusterNullableInt40s : public ModelCommand
{
public:
    WriteTestClusterNullableInt40s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int40s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008011, mValue);
    }

private:
    chip::app::DataModel::Nullable<int64_t> mValue;
};

class ReportTestClusterNullableInt40s : public ModelCommand
{
public:
    ReportTestClusterNullableInt40s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int40s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt40s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt48s
 */
class ReadTestClusterNullableInt48s : public ModelCommand
{
public:
    ReadTestClusterNullableInt48s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int48s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt48s report", 0, value);
    }
};

class WriteTestClusterNullableInt48s : public ModelCommand
{
public:
    WriteTestClusterNullableInt48s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int48s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008012, mValue);
    }

private:
    chip::app::DataModel::Nullable<int64_t> mValue;
};

class ReportTestClusterNullableInt48s : public ModelCommand
{
public:
    ReportTestClusterNullableInt48s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int48s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt48s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt56s
 */
class ReadTestClusterNullableInt56s : public ModelCommand
{
public:
    ReadTestClusterNullableInt56s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int56s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008013);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt56s report", 0, value);
    }
};

class WriteTestClusterNullableInt56s : public ModelCommand
{
public:
    WriteTestClusterNullableInt56s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int56s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008013, mValue);
    }

private:
    chip::app::DataModel::Nullable<int64_t> mValue;
};

class ReportTestClusterNullableInt56s : public ModelCommand
{
public:
    ReportTestClusterNullableInt56s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int56s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008013, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt56s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64s
 */
class ReadTestClusterNullableInt64s : public ModelCommand
{
public:
    ReadTestClusterNullableInt64s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008014);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt64s report", 0, value);
    }
};

class WriteTestClusterNullableInt64s : public ModelCommand
{
public:
    WriteTestClusterNullableInt64s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008014, mValue);
    }

private:
    chip::app::DataModel::Nullable<int64_t> mValue;
};

class ReportTestClusterNullableInt64s : public ModelCommand
{
public:
    ReportTestClusterNullableInt64s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008014, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int64_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableInt64s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum8
 */
class ReadTestClusterNullableEnum8 : public ModelCommand
{
public:
    ReadTestClusterNullableEnum8() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008015);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableEnum8 report", 0, value);
    }
};

class WriteTestClusterNullableEnum8 : public ModelCommand
{
public:
    WriteTestClusterNullableEnum8() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008015, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint8_t> mValue;
};

class ReportTestClusterNullableEnum8 : public ModelCommand
{
public:
    ReportTestClusterNullableEnum8() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008015, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableEnum8 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum16
 */
class ReadTestClusterNullableEnum16 : public ModelCommand
{
public:
    ReadTestClusterNullableEnum16() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008016);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableEnum16 report", 0, value);
    }
};

class WriteTestClusterNullableEnum16 : public ModelCommand
{
public:
    WriteTestClusterNullableEnum16() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008016, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint16_t> mValue;
};

class ReportTestClusterNullableEnum16 : public ModelCommand
{
public:
    ReportTestClusterNullableEnum16() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008016, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableEnum16 report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableFloatSingle
 */
class ReadTestClusterNullableFloatSingle : public ModelCommand
{
public:
    ReadTestClusterNullableFloatSingle() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-float-single");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008017);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<float> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableFloatSingle report", 0, value);
    }
};

class WriteTestClusterNullableFloatSingle : public ModelCommand
{
public:
    WriteTestClusterNullableFloatSingle() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-float-single");
        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008017, mValue);
    }

private:
    chip::app::DataModel::Nullable<float> mValue;
};

class ReportTestClusterNullableFloatSingle : public ModelCommand
{
public:
    ReportTestClusterNullableFloatSingle() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-float-single");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008017, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<float> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableFloatSingle report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableFloatDouble
 */
class ReadTestClusterNullableFloatDouble : public ModelCommand
{
public:
    ReadTestClusterNullableFloatDouble() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-float-double");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008018);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<double> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableFloatDouble report", 0, value);
    }
};

class WriteTestClusterNullableFloatDouble : public ModelCommand
{
public:
    WriteTestClusterNullableFloatDouble() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-float-double");
        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008018, mValue);
    }

private:
    chip::app::DataModel::Nullable<double> mValue;
};

class ReportTestClusterNullableFloatDouble : public ModelCommand
{
public:
    ReportTestClusterNullableFloatDouble() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-float-double");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008018, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<double> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableFloatDouble report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableOctetString
 */
class ReadTestClusterNullableOctetString : public ModelCommand
{
public:
    ReadTestClusterNullableOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008019);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::ByteSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableOctetString report", 0, value);
    }
};

class WriteTestClusterNullableOctetString : public ModelCommand
{
public:
    WriteTestClusterNullableOctetString() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008019, mValue);
    }

private:
    chip::app::DataModel::Nullable<chip::ByteSpan> mValue;
};

class ReportTestClusterNullableOctetString : public ModelCommand
{
public:
    ReportTestClusterNullableOctetString() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008019, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::ByteSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableOctetString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableCharString
 */
class ReadTestClusterNullableCharString : public ModelCommand
{
public:
    ReadTestClusterNullableCharString() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000801E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::CharSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableCharString report", 0, value);
    }
};

class WriteTestClusterNullableCharString : public ModelCommand
{
public:
    WriteTestClusterNullableCharString() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x0000801E, mValue);
    }

private:
    chip::app::DataModel::Nullable<chip::CharSpan> mValue;
};

class ReportTestClusterNullableCharString : public ModelCommand
{
public:
    ReportTestClusterNullableCharString() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000801E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::CharSpan> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableCharString report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnumAttr
 */
class ReadTestClusterNullableEnumAttr : public ModelCommand
{
public:
    ReadTestClusterNullableEnumAttr() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008024);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableEnumAttr report", 0, value);
    }
};

class WriteTestClusterNullableEnumAttr : public ModelCommand
{
public:
    WriteTestClusterNullableEnumAttr() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008024, mValue);
    }

private:
    chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> mValue;
};

class ReportTestClusterNullableEnumAttr : public ModelCommand
{
public:
    ReportTestClusterNullableEnumAttr() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008024, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableEnumAttr report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt8u
 */
class ReadTestClusterNullableRangeRestrictedInt8u : public ModelCommand
{
public:
    ReadTestClusterNullableRangeRestrictedInt8u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008026);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableRangeRestrictedInt8u report", 0, value);
    }
};

class WriteTestClusterNullableRangeRestrictedInt8u : public ModelCommand
{
public:
    WriteTestClusterNullableRangeRestrictedInt8u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008026, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint8_t> mValue;
};

class ReportTestClusterNullableRangeRestrictedInt8u : public ModelCommand
{
public:
    ReportTestClusterNullableRangeRestrictedInt8u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008026, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableRangeRestrictedInt8u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt8s
 */
class ReadTestClusterNullableRangeRestrictedInt8s : public ModelCommand
{
public:
    ReadTestClusterNullableRangeRestrictedInt8s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008027);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableRangeRestrictedInt8s report", 0, value);
    }
};

class WriteTestClusterNullableRangeRestrictedInt8s : public ModelCommand
{
public:
    WriteTestClusterNullableRangeRestrictedInt8s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008027, mValue);
    }

private:
    chip::app::DataModel::Nullable<int8_t> mValue;
};

class ReportTestClusterNullableRangeRestrictedInt8s : public ModelCommand
{
public:
    ReportTestClusterNullableRangeRestrictedInt8s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008027, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int8_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableRangeRestrictedInt8s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt16u
 */
class ReadTestClusterNullableRangeRestrictedInt16u : public ModelCommand
{
public:
    ReadTestClusterNullableRangeRestrictedInt16u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008028);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableRangeRestrictedInt16u report", 0, value);
    }
};

class WriteTestClusterNullableRangeRestrictedInt16u : public ModelCommand
{
public:
    WriteTestClusterNullableRangeRestrictedInt16u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008028, mValue);
    }

private:
    chip::app::DataModel::Nullable<uint16_t> mValue;
};

class ReportTestClusterNullableRangeRestrictedInt16u : public ModelCommand
{
public:
    ReportTestClusterNullableRangeRestrictedInt16u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008028, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableRangeRestrictedInt16u report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt16s
 */
class ReadTestClusterNullableRangeRestrictedInt16s : public ModelCommand
{
public:
    ReadTestClusterNullableRangeRestrictedInt16s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x00008029);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableRangeRestrictedInt16s report", 0, value);
    }
};

class WriteTestClusterNullableRangeRestrictedInt16s : public ModelCommand
{
public:
    WriteTestClusterNullableRangeRestrictedInt16s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x0000050F, 0x00008029, mValue);
    }

private:
    chip::app::DataModel::Nullable<int16_t> mValue;
};

class ReportTestClusterNullableRangeRestrictedInt16s : public ModelCommand
{
public:
    ReportTestClusterNullableRangeRestrictedInt16s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x00008029, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<int16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.NullableRangeRestrictedInt16s report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTestClusterAttributeList : public ModelCommand
{
public:
    ReadTestClusterAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadTestClusterClusterRevision : public ModelCommand
{
public:
    ReadTestClusterClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x0000050F, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ClusterRevision report", 0, value);
    }
};

class ReportTestClusterClusterRevision : public ModelCommand
{
public:
    ReportTestClusterClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x0000050F, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("TestCluster.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Thermostat                                                  | 0x0201 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ClearWeeklySchedule                                               |   0x03 |
| * GetRelayStatusLog                                                 |   0x04 |
| * GetWeeklySchedule                                                 |   0x02 |
| * SetWeeklySchedule                                                 |   0x01 |
| * SetpointRaiseLower                                                |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LocalTemperature                                                  | 0x0000 |
| * AbsMinHeatSetpointLimit                                           | 0x0003 |
| * AbsMaxHeatSetpointLimit                                           | 0x0004 |
| * AbsMinCoolSetpointLimit                                           | 0x0005 |
| * AbsMaxCoolSetpointLimit                                           | 0x0006 |
| * OccupiedCoolingSetpoint                                           | 0x0011 |
| * OccupiedHeatingSetpoint                                           | 0x0012 |
| * MinHeatSetpointLimit                                              | 0x0015 |
| * MaxHeatSetpointLimit                                              | 0x0016 |
| * MinCoolSetpointLimit                                              | 0x0017 |
| * MaxCoolSetpointLimit                                              | 0x0018 |
| * MinSetpointDeadBand                                               | 0x0019 |
| * ControlSequenceOfOperation                                        | 0x001B |
| * SystemMode                                                        | 0x001C |
| * StartOfWeek                                                       | 0x0020 |
| * NumberOfWeeklyTransitions                                         | 0x0021 |
| * NumberOfDailyTransitions                                          | 0x0022 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearWeeklySchedule
 */
class ThermostatClearWeeklySchedule : public ModelCommand
{
public:
    ThermostatClearWeeklySchedule() : ModelCommand("clear-weekly-schedule") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000003) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Thermostat::Commands::ClearWeeklySchedule::Type mRequest;
};

/*
 * Command GetRelayStatusLog
 */
class ThermostatGetRelayStatusLog : public ModelCommand
{
public:
    ThermostatGetRelayStatusLog() : ModelCommand("get-relay-status-log") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnThermostatGetRelayStatusLogResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Thermostat::Commands::GetRelayStatusLog::Type mRequest;
};

/*
 * Command GetWeeklySchedule
 */
class ThermostatGetWeeklySchedule : public ModelCommand
{
public:
    ThermostatGetWeeklySchedule() : ModelCommand("get-weekly-schedule")
    {
        AddArgument("DaysToReturn", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<chip::app::Clusters::Thermostat::DayOfWeek> *>(&mRequest.daysToReturn));
        AddArgument(
            "ModeToReturn", 0, UINT8_MAX,
            reinterpret_cast<std::underlying_type_t<chip::app::Clusters::Thermostat::ModeForSequence> *>(&mRequest.modeToReturn));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnThermostatGetWeeklyScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest, mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Thermostat::Commands::GetWeeklySchedule::Type mRequest;
};

/*
 * Command SetWeeklySchedule
 */
class ThermostatSetWeeklySchedule : public ModelCommand
{
public:
    ThermostatSetWeeklySchedule() : ModelCommand("set-weekly-schedule")
    {
        AddArgument("NumberOfTransitionsForSequence", 0, UINT8_MAX, &mRequest.numberOfTransitionsForSequence);
        AddArgument(
            "DayOfWeekForSequence", 0, UINT8_MAX,
            reinterpret_cast<std::underlying_type_t<chip::app::Clusters::Thermostat::DayOfWeek> *>(&mRequest.dayOfWeekForSequence));
        AddArgument("ModeForSequence", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<chip::app::Clusters::Thermostat::ModeForSequence> *>(
                        &mRequest.modeForSequence));
        // payload Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Thermostat::Commands::SetWeeklySchedule::Type mRequest;
};

/*
 * Command SetpointRaiseLower
 */
class ThermostatSetpointRaiseLower : public ModelCommand
{
public:
    ThermostatSetpointRaiseLower() : ModelCommand("setpoint-raise-lower")
    {
        AddArgument("Mode", 0, UINT8_MAX, reinterpret_cast<std::underlying_type_t<decltype(mRequest.mode)> *>(&mRequest.mode));
        AddArgument("Amount", INT8_MIN, INT8_MAX, &mRequest.amount);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::Thermostat::Commands::SetpointRaiseLower::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventThermostatWildcard : public ModelCommand
{
public:
    ReadEventThermostatWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventThermostatWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000201, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventThermostatWildcard : public ModelCommand
{
public:
    ReportEventThermostatWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventThermostatWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000201, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadThermostatWildcard : public ModelCommand
{
public:
    ReadThermostatWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatWildcard : public ModelCommand
{
public:
    ReportThermostatWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocalTemperature
 */
class ReadThermostatLocalTemperature : public ModelCommand
{
public:
    ReadThermostatLocalTemperature() : ModelCommand("read")
    {
        AddArgument("attr-name", "local-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatLocalTemperature() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.LocalTemperature report", 0, value);
    }
};

class ReportThermostatLocalTemperature : public ModelCommand
{
public:
    ReportThermostatLocalTemperature() : ModelCommand("report")
    {
        AddArgument("attr-name", "local-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatLocalTemperature() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.LocalTemperature report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinHeatSetpointLimit
 */
class ReadThermostatAbsMinHeatSetpointLimit : public ModelCommand
{
public:
    ReadThermostatAbsMinHeatSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AbsMinHeatSetpointLimit report", 0, value);
    }
};

class ReportThermostatAbsMinHeatSetpointLimit : public ModelCommand
{
public:
    ReportThermostatAbsMinHeatSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AbsMinHeatSetpointLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxHeatSetpointLimit
 */
class ReadThermostatAbsMaxHeatSetpointLimit : public ModelCommand
{
public:
    ReadThermostatAbsMaxHeatSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AbsMaxHeatSetpointLimit report", 0, value);
    }
};

class ReportThermostatAbsMaxHeatSetpointLimit : public ModelCommand
{
public:
    ReportThermostatAbsMaxHeatSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AbsMaxHeatSetpointLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinCoolSetpointLimit
 */
class ReadThermostatAbsMinCoolSetpointLimit : public ModelCommand
{
public:
    ReadThermostatAbsMinCoolSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AbsMinCoolSetpointLimit report", 0, value);
    }
};

class ReportThermostatAbsMinCoolSetpointLimit : public ModelCommand
{
public:
    ReportThermostatAbsMinCoolSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AbsMinCoolSetpointLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxCoolSetpointLimit
 */
class ReadThermostatAbsMaxCoolSetpointLimit : public ModelCommand
{
public:
    ReadThermostatAbsMaxCoolSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AbsMaxCoolSetpointLimit report", 0, value);
    }
};

class ReportThermostatAbsMaxCoolSetpointLimit : public ModelCommand
{
public:
    ReportThermostatAbsMaxCoolSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AbsMaxCoolSetpointLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedCoolingSetpoint
 */
class ReadThermostatOccupiedCoolingSetpoint : public ModelCommand
{
public:
    ReadThermostatOccupiedCoolingSetpoint() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.OccupiedCoolingSetpoint report", 0, value);
    }
};

class WriteThermostatOccupiedCoolingSetpoint : public ModelCommand
{
public:
    WriteThermostatOccupiedCoolingSetpoint() : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x00000011, mValue);
    }

private:
    int16_t mValue;
};

class ReportThermostatOccupiedCoolingSetpoint : public ModelCommand
{
public:
    ReportThermostatOccupiedCoolingSetpoint() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.OccupiedCoolingSetpoint report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedHeatingSetpoint
 */
class ReadThermostatOccupiedHeatingSetpoint : public ModelCommand
{
public:
    ReadThermostatOccupiedHeatingSetpoint() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.OccupiedHeatingSetpoint report", 0, value);
    }
};

class WriteThermostatOccupiedHeatingSetpoint : public ModelCommand
{
public:
    WriteThermostatOccupiedHeatingSetpoint() : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x00000012, mValue);
    }

private:
    int16_t mValue;
};

class ReportThermostatOccupiedHeatingSetpoint : public ModelCommand
{
public:
    ReportThermostatOccupiedHeatingSetpoint() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.OccupiedHeatingSetpoint report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinHeatSetpointLimit
 */
class ReadThermostatMinHeatSetpointLimit : public ModelCommand
{
public:
    ReadThermostatMinHeatSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000015);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MinHeatSetpointLimit report", 0, value);
    }
};

class WriteThermostatMinHeatSetpointLimit : public ModelCommand
{
public:
    WriteThermostatMinHeatSetpointLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x00000015, mValue);
    }

private:
    int16_t mValue;
};

class ReportThermostatMinHeatSetpointLimit : public ModelCommand
{
public:
    ReportThermostatMinHeatSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000015, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MinHeatSetpointLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxHeatSetpointLimit
 */
class ReadThermostatMaxHeatSetpointLimit : public ModelCommand
{
public:
    ReadThermostatMaxHeatSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000016);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MaxHeatSetpointLimit report", 0, value);
    }
};

class WriteThermostatMaxHeatSetpointLimit : public ModelCommand
{
public:
    WriteThermostatMaxHeatSetpointLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x00000016, mValue);
    }

private:
    int16_t mValue;
};

class ReportThermostatMaxHeatSetpointLimit : public ModelCommand
{
public:
    ReportThermostatMaxHeatSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000016, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MaxHeatSetpointLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCoolSetpointLimit
 */
class ReadThermostatMinCoolSetpointLimit : public ModelCommand
{
public:
    ReadThermostatMinCoolSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000017);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MinCoolSetpointLimit report", 0, value);
    }
};

class WriteThermostatMinCoolSetpointLimit : public ModelCommand
{
public:
    WriteThermostatMinCoolSetpointLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x00000017, mValue);
    }

private:
    int16_t mValue;
};

class ReportThermostatMinCoolSetpointLimit : public ModelCommand
{
public:
    ReportThermostatMinCoolSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000017, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MinCoolSetpointLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCoolSetpointLimit
 */
class ReadThermostatMaxCoolSetpointLimit : public ModelCommand
{
public:
    ReadThermostatMaxCoolSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000018);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MaxCoolSetpointLimit report", 0, value);
    }
};

class WriteThermostatMaxCoolSetpointLimit : public ModelCommand
{
public:
    WriteThermostatMaxCoolSetpointLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x00000018, mValue);
    }

private:
    int16_t mValue;
};

class ReportThermostatMaxCoolSetpointLimit : public ModelCommand
{
public:
    ReportThermostatMaxCoolSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000018, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MaxCoolSetpointLimit report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinSetpointDeadBand
 */
class ReadThermostatMinSetpointDeadBand : public ModelCommand
{
public:
    ReadThermostatMinSetpointDeadBand() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000019);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MinSetpointDeadBand report", 0, value);
    }
};

class WriteThermostatMinSetpointDeadBand : public ModelCommand
{
public:
    WriteThermostatMinSetpointDeadBand() : ModelCommand("write")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x00000019, mValue);
    }

private:
    int8_t mValue;
};

class ReportThermostatMinSetpointDeadBand : public ModelCommand
{
public:
    ReportThermostatMinSetpointDeadBand() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000019, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.MinSetpointDeadBand report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlSequenceOfOperation
 */
class ReadThermostatControlSequenceOfOperation : public ModelCommand
{
public:
    ReadThermostatControlSequenceOfOperation() : ModelCommand("read")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x0000001B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.ControlSequenceOfOperation report", 0, value);
    }
};

class WriteThermostatControlSequenceOfOperation : public ModelCommand
{
public:
    WriteThermostatControlSequenceOfOperation() : ModelCommand("write")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x0000001B, mValue);
    }

private:
    uint8_t mValue;
};

class ReportThermostatControlSequenceOfOperation : public ModelCommand
{
public:
    ReportThermostatControlSequenceOfOperation() : ModelCommand("report")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x0000001B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.ControlSequenceOfOperation report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SystemMode
 */
class ReadThermostatSystemMode : public ModelCommand
{
public:
    ReadThermostatSystemMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "system-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatSystemMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x0000001C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.SystemMode report", 0, value);
    }
};

class WriteThermostatSystemMode : public ModelCommand
{
public:
    WriteThermostatSystemMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatSystemMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000201, 0x0000001C, mValue);
    }

private:
    uint8_t mValue;
};

class ReportThermostatSystemMode : public ModelCommand
{
public:
    ReportThermostatSystemMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatSystemMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x0000001C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.SystemMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartOfWeek
 */
class ReadThermostatStartOfWeek : public ModelCommand
{
public:
    ReadThermostatStartOfWeek() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-of-week");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatStartOfWeek() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000020);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.StartOfWeek report", 0, value);
    }
};

class ReportThermostatStartOfWeek : public ModelCommand
{
public:
    ReportThermostatStartOfWeek() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-of-week");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatStartOfWeek() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000020, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.StartOfWeek report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfWeeklyTransitions
 */
class ReadThermostatNumberOfWeeklyTransitions : public ModelCommand
{
public:
    ReadThermostatNumberOfWeeklyTransitions() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfWeeklyTransitions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000021);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.NumberOfWeeklyTransitions report", 0, value);
    }
};

class ReportThermostatNumberOfWeeklyTransitions : public ModelCommand
{
public:
    ReportThermostatNumberOfWeeklyTransitions() : ModelCommand("report")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatNumberOfWeeklyTransitions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000021, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.NumberOfWeeklyTransitions report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfDailyTransitions
 */
class ReadThermostatNumberOfDailyTransitions : public ModelCommand
{
public:
    ReadThermostatNumberOfDailyTransitions() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfDailyTransitions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x00000022);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.NumberOfDailyTransitions report", 0, value);
    }
};

class ReportThermostatNumberOfDailyTransitions : public ModelCommand
{
public:
    ReportThermostatNumberOfDailyTransitions() : ModelCommand("report")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatNumberOfDailyTransitions() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x00000022, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.NumberOfDailyTransitions report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThermostatAttributeList : public ModelCommand
{
public:
    ReadThermostatAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadThermostatFeatureMap : public ModelCommand
{
public:
    ReadThermostatFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.FeatureMap report", 0, value);
    }
};

class ReportThermostatFeatureMap : public ModelCommand
{
public:
    ReportThermostatFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x0000FFFC, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.FeatureMap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatClusterRevision : public ModelCommand
{
public:
    ReadThermostatClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000201, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.ClusterRevision report", 0, value);
    }
};

class ReportThermostatClusterRevision : public ModelCommand
{
public:
    ReportThermostatClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000201, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("Thermostat.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThermostatUserInterfaceConfiguration                        | 0x0204 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TemperatureDisplayMode                                            | 0x0000 |
| * KeypadLockout                                                     | 0x0001 |
| * ScheduleProgrammingVisibility                                     | 0x0002 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventThermostatUserInterfaceConfigurationWildcard : public ModelCommand
{
public:
    ReadEventThermostatUserInterfaceConfigurationWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventThermostatUserInterfaceConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000204, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventThermostatUserInterfaceConfigurationWildcard : public ModelCommand
{
public:
    ReportEventThermostatUserInterfaceConfigurationWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventThermostatUserInterfaceConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000204, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadThermostatUserInterfaceConfigurationWildcard : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000204, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatUserInterfaceConfigurationWildcard : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000204, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TemperatureDisplayMode
 */
class ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "temperature-display-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000204, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.TemperatureDisplayMode report", 0, value);
    }
};

class WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand
{
public:
    WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000204, 0x00000000, mValue);
    }

private:
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000204, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.TemperatureDisplayMode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute KeypadLockout
 */
class ReadThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationKeypadLockout() : ModelCommand("read")
    {
        AddArgument("attr-name", "keypad-lockout");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000204, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.KeypadLockout report", 0, value);
    }
};

class WriteThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand
{
public:
    WriteThermostatUserInterfaceConfigurationKeypadLockout() : ModelCommand("write")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000204, 0x00000001, mValue);
    }

private:
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationKeypadLockout() : ModelCommand("report")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000204, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.KeypadLockout report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ScheduleProgrammingVisibility
 */
class ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() : ModelCommand("read")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000204, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.ScheduleProgrammingVisibility report", 0, value);
    }
};

class WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand
{
public:
    WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() : ModelCommand("write")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000204, 0x00000002, mValue);
    }

private:
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() : ModelCommand("report")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000204, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.ScheduleProgrammingVisibility report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThermostatUserInterfaceConfigurationAttributeList : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000204, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000204, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.ClusterRevision report", 0, value);
    }
};

class ReportThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000204, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThermostatUserInterfaceConfiguration.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThreadNetworkDiagnostics                                    | 0x0035 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Channel                                                           | 0x0000 |
| * RoutingRole                                                       | 0x0001 |
| * NetworkName                                                       | 0x0002 |
| * PanId                                                             | 0x0003 |
| * ExtendedPanId                                                     | 0x0004 |
| * MeshLocalPrefix                                                   | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * NeighborTableList                                                 | 0x0007 |
| * RouteTableList                                                    | 0x0008 |
| * PartitionId                                                       | 0x0009 |
| * Weighting                                                         | 0x000A |
| * DataVersion                                                       | 0x000B |
| * StableDataVersion                                                 | 0x000C |
| * LeaderRouterId                                                    | 0x000D |
| * DetachedRoleCount                                                 | 0x000E |
| * ChildRoleCount                                                    | 0x000F |
| * RouterRoleCount                                                   | 0x0010 |
| * LeaderRoleCount                                                   | 0x0011 |
| * AttachAttemptCount                                                | 0x0012 |
| * PartitionIdChangeCount                                            | 0x0013 |
| * BetterPartitionAttachAttemptCount                                 | 0x0014 |
| * ParentChangeCount                                                 | 0x0015 |
| * TxTotalCount                                                      | 0x0016 |
| * TxUnicastCount                                                    | 0x0017 |
| * TxBroadcastCount                                                  | 0x0018 |
| * TxAckRequestedCount                                               | 0x0019 |
| * TxAckedCount                                                      | 0x001A |
| * TxNoAckRequestedCount                                             | 0x001B |
| * TxDataCount                                                       | 0x001C |
| * TxDataPollCount                                                   | 0x001D |
| * TxBeaconCount                                                     | 0x001E |
| * TxBeaconRequestCount                                              | 0x001F |
| * TxOtherCount                                                      | 0x0020 |
| * TxRetryCount                                                      | 0x0021 |
| * TxDirectMaxRetryExpiryCount                                       | 0x0022 |
| * TxIndirectMaxRetryExpiryCount                                     | 0x0023 |
| * TxErrCcaCount                                                     | 0x0024 |
| * TxErrAbortCount                                                   | 0x0025 |
| * TxErrBusyChannelCount                                             | 0x0026 |
| * RxTotalCount                                                      | 0x0027 |
| * RxUnicastCount                                                    | 0x0028 |
| * RxBroadcastCount                                                  | 0x0029 |
| * RxDataCount                                                       | 0x002A |
| * RxDataPollCount                                                   | 0x002B |
| * RxBeaconCount                                                     | 0x002C |
| * RxBeaconRequestCount                                              | 0x002D |
| * RxOtherCount                                                      | 0x002E |
| * RxAddressFilteredCount                                            | 0x002F |
| * RxDestAddrFilteredCount                                           | 0x0030 |
| * RxDuplicatedCount                                                 | 0x0031 |
| * RxErrNoFrameCount                                                 | 0x0032 |
| * RxErrUnknownNeighborCount                                         | 0x0033 |
| * RxErrInvalidSrcAddrCount                                          | 0x0034 |
| * RxErrSecCount                                                     | 0x0035 |
| * RxErrFcsCount                                                     | 0x0036 |
| * RxErrOtherCount                                                   | 0x0037 |
| * ActiveTimestamp                                                   | 0x0038 |
| * PendingTimestamp                                                  | 0x0039 |
| * Delay                                                             | 0x003A |
| * SecurityPolicy                                                    | 0x003B |
| * ChannelMask                                                       | 0x003C |
| * OperationalDatasetComponents                                      | 0x003D |
| * ActiveNetworkFaultsList                                           | 0x003E |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * ConnectionStatus                                                  | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class ThreadNetworkDiagnosticsResetCounts : public ModelCommand
{
public:
    ThreadNetworkDiagnosticsResetCounts() : ModelCommand("reset-counts") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::ThreadNetworkDiagnostics::Commands::ResetCounts::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventThreadNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReadEventThreadNetworkDiagnosticsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventThreadNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000035, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventThreadNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReportEventThreadNetworkDiagnosticsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventThreadNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000035, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event ConnectionStatus
 */
class ReadThreadNetworkDiagnosticsConnectionStatus : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsConnectionStatus() : ModelCommand("read-event")
    {
        AddArgument("event-name", "connection-status");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsConnectionStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000035, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::ThreadNetworkDiagnostics::Events::ConnectionStatus::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ConnectionStatus report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsConnectionStatus : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsConnectionStatus() : ModelCommand("report-event")
    {
        AddArgument("event-name", "connection-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsConnectionStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000035, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::ThreadNetworkDiagnostics::Events::ConnectionStatus::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ConnectionStatus report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadThreadNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Channel
 */
class ReadThreadNetworkDiagnosticsChannel : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsChannel() : ModelCommand("read")
    {
        AddArgument("attr-name", "channel");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.Channel report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsChannel : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsChannel() : ModelCommand("report")
    {
        AddArgument("attr-name", "channel");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChannel() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.Channel report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RoutingRole
 */
class ReadThreadNetworkDiagnosticsRoutingRole : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRoutingRole() : ModelCommand("read")
    {
        AddArgument("attr-name", "routing-role");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRoutingRole() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RoutingRole report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRoutingRole : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRoutingRole() : ModelCommand("report")
    {
        AddArgument("attr-name", "routing-role");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRoutingRole() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RoutingRole report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NetworkName
 */
class ReadThreadNetworkDiagnosticsNetworkName : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsNetworkName() : ModelCommand("read")
    {
        AddArgument("attr-name", "network-name");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNetworkName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.NetworkName report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsNetworkName : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsNetworkName() : ModelCommand("report")
    {
        AddArgument("attr-name", "network-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsNetworkName() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.NetworkName report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PanId
 */
class ReadThreadNetworkDiagnosticsPanId : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsPanId() : ModelCommand("read")
    {
        AddArgument("attr-name", "pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPanId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.PanId report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsPanId : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsPanId() : ModelCommand("report")
    {
        AddArgument("attr-name", "pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPanId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.PanId report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ExtendedPanId
 */
class ReadThreadNetworkDiagnosticsExtendedPanId : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsExtendedPanId() : ModelCommand("read")
    {
        AddArgument("attr-name", "extended-pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsExtendedPanId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ExtendedPanId report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsExtendedPanId : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsExtendedPanId() : ModelCommand("report")
    {
        AddArgument("attr-name", "extended-pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsExtendedPanId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ExtendedPanId report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeshLocalPrefix
 */
class ReadThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsMeshLocalPrefix() : ModelCommand("read")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsMeshLocalPrefix() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.MeshLocalPrefix report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsMeshLocalPrefix() : ModelCommand("report")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsMeshLocalPrefix() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.MeshLocalPrefix report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadThreadNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsOverrunCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.OverrunCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsOverrunCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.OverrunCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NeighborTableList
 */
class ReadThreadNetworkDiagnosticsNeighborTableList : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsNeighborTableList() : ModelCommand("read")
    {
        AddArgument("attr-name", "neighbor-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNeighborTableList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.NeighborTableList report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsNeighborTableList : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsNeighborTableList() : ModelCommand("report")
    {
        AddArgument("attr-name", "neighbor-table-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsNeighborTableList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.NeighborTableList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouteTableList
 */
class ReadThreadNetworkDiagnosticsRouteTableList : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRouteTableList() : ModelCommand("read")
    {
        AddArgument("attr-name", "route-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouteTableList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RouteTableList report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRouteTableList : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRouteTableList() : ModelCommand("report")
    {
        AddArgument("attr-name", "route-table-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRouteTableList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RouteTableList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionId
 */
class ReadThreadNetworkDiagnosticsPartitionId : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsPartitionId() : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000009);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.PartitionId report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsPartitionId : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsPartitionId() : ModelCommand("report")
    {
        AddArgument("attr-name", "partition-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPartitionId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000009, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.PartitionId report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Weighting
 */
class ReadThreadNetworkDiagnosticsWeighting : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsWeighting() : ModelCommand("read")
    {
        AddArgument("attr-name", "weighting");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsWeighting() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000000A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.Weighting report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsWeighting : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsWeighting() : ModelCommand("report")
    {
        AddArgument("attr-name", "weighting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsWeighting() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000000A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.Weighting report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DataVersion
 */
class ReadThreadNetworkDiagnosticsDataVersion : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsDataVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDataVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000000B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.DataVersion report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsDataVersion : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsDataVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDataVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000000B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.DataVersion report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StableDataVersion
 */
class ReadThreadNetworkDiagnosticsStableDataVersion : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsStableDataVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "stable-data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsStableDataVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000000C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.StableDataVersion report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsStableDataVersion : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsStableDataVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "stable-data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsStableDataVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000000C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.StableDataVersion report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRouterId
 */
class ReadThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsLeaderRouterId() : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-router-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRouterId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000000D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.LeaderRouterId report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsLeaderRouterId() : ModelCommand("report")
    {
        AddArgument("attr-name", "leader-router-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsLeaderRouterId() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000000D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.LeaderRouterId report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DetachedRoleCount
 */
class ReadThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsDetachedRoleCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "detached-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDetachedRoleCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000000E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.DetachedRoleCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsDetachedRoleCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "detached-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDetachedRoleCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000000E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.DetachedRoleCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChildRoleCount
 */
class ReadThreadNetworkDiagnosticsChildRoleCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsChildRoleCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "child-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChildRoleCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000000F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ChildRoleCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsChildRoleCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsChildRoleCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "child-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChildRoleCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000000F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ChildRoleCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouterRoleCount
 */
class ReadThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRouterRoleCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "router-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouterRoleCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RouterRoleCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRouterRoleCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "router-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRouterRoleCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RouterRoleCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRoleCount
 */
class ReadThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsLeaderRoleCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRoleCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.LeaderRoleCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsLeaderRoleCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "leader-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsLeaderRoleCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.LeaderRoleCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsAttachAttemptCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttachAttemptCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.AttachAttemptCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsAttachAttemptCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsAttachAttemptCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.AttachAttemptCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionIdChangeCount
 */
class ReadThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsPartitionIdChangeCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionIdChangeCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000013);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.PartitionIdChangeCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsPartitionIdChangeCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "partition-id-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPartitionIdChangeCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000013, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.PartitionIdChangeCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BetterPartitionAttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000014);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.BetterPartitionAttachAttemptCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000014, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.BetterPartitionAttachAttemptCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ParentChangeCount
 */
class ReadThreadNetworkDiagnosticsParentChangeCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsParentChangeCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "parent-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsParentChangeCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000015);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ParentChangeCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsParentChangeCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsParentChangeCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "parent-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsParentChangeCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000015, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ParentChangeCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxTotalCount
 */
class ReadThreadNetworkDiagnosticsTxTotalCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxTotalCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxTotalCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000016);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxTotalCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxTotalCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxTotalCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxTotalCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000016, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxTotalCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxUnicastCount
 */
class ReadThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxUnicastCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxUnicastCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000017);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxUnicastCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxUnicastCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxUnicastCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000017, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxUnicastCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxBroadcastCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBroadcastCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000018);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxBroadcastCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxBroadcastCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBroadcastCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000018, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxBroadcastCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxAckRequestedCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckRequestedCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000019);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxAckRequestedCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxAckRequestedCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxAckRequestedCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000019, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxAckRequestedCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckedCount
 */
class ReadThreadNetworkDiagnosticsTxAckedCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxAckedCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-acked-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckedCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000001A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxAckedCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxAckedCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxAckedCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-acked-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxAckedCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000001A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxAckedCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxNoAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxNoAckRequestedCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxNoAckRequestedCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000001B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxNoAckRequestedCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxNoAckRequestedCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxNoAckRequestedCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000001B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxNoAckRequestedCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataCount
 */
class ReadThreadNetworkDiagnosticsTxDataCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxDataCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000001C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxDataCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxDataCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxDataCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDataCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000001C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxDataCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataPollCount
 */
class ReadThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxDataPollCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataPollCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000001D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxDataPollCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxDataPollCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDataPollCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000001D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxDataPollCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxBeaconCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000001E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxBeaconCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxBeaconCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBeaconCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000001E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxBeaconCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxBeaconRequestCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000001F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxBeaconRequestCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxBeaconRequestCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000001F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxBeaconRequestCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxOtherCount
 */
class ReadThreadNetworkDiagnosticsTxOtherCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxOtherCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxOtherCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000020);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxOtherCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxOtherCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxOtherCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxOtherCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000020, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxOtherCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxRetryCount
 */
class ReadThreadNetworkDiagnosticsTxRetryCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxRetryCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-retry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxRetryCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000021);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxRetryCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxRetryCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxRetryCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-retry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxRetryCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000021, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxRetryCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000022);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxDirectMaxRetryExpiryCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000022, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxDirectMaxRetryExpiryCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxIndirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000023);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxIndirectMaxRetryExpiryCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000023, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxIndirectMaxRetryExpiryCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCcaCount
 */
class ReadThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxErrCcaCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrCcaCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000024);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxErrCcaCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxErrCcaCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrCcaCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000024, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxErrCcaCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrAbortCount
 */
class ReadThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxErrAbortCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrAbortCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000025);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxErrAbortCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxErrAbortCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrAbortCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000025, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxErrAbortCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrBusyChannelCount
 */
class ReadThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxErrBusyChannelCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrBusyChannelCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000026);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxErrBusyChannelCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxErrBusyChannelCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrBusyChannelCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000026, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.TxErrBusyChannelCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxTotalCount
 */
class ReadThreadNetworkDiagnosticsRxTotalCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxTotalCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxTotalCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000027);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxTotalCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxTotalCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxTotalCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxTotalCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000027, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxTotalCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxUnicastCount
 */
class ReadThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxUnicastCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxUnicastCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000028);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxUnicastCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxUnicastCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxUnicastCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000028, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxUnicastCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxBroadcastCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBroadcastCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000029);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxBroadcastCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxBroadcastCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBroadcastCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000029, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxBroadcastCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataCount
 */
class ReadThreadNetworkDiagnosticsRxDataCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxDataCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000002A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxDataCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxDataCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxDataCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDataCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000002A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxDataCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataPollCount
 */
class ReadThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxDataPollCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataPollCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000002B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxDataPollCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxDataPollCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDataPollCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000002B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxDataPollCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxBeaconCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000002C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxBeaconCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxBeaconCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBeaconCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000002C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxBeaconCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxBeaconRequestCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000002D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxBeaconRequestCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxBeaconRequestCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000002D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxBeaconRequestCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxOtherCount
 */
class ReadThreadNetworkDiagnosticsRxOtherCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxOtherCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxOtherCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000002E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxOtherCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxOtherCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxOtherCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxOtherCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000002E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxOtherCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxAddressFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxAddressFilteredCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxAddressFilteredCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000002F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxAddressFilteredCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxAddressFilteredCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxAddressFilteredCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000002F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxAddressFilteredCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDestAddrFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000030);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxDestAddrFilteredCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000030, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxDestAddrFilteredCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDuplicatedCount
 */
class ReadThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxDuplicatedCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDuplicatedCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000031);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxDuplicatedCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxDuplicatedCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDuplicatedCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000031, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxDuplicatedCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrNoFrameCount
 */
class ReadThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrNoFrameCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrNoFrameCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000032);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrNoFrameCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrNoFrameCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrNoFrameCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000032, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrNoFrameCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrUnknownNeighborCount
 */
class ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000033);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrUnknownNeighborCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000033, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrUnknownNeighborCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrInvalidSrcAddrCount
 */
class ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000034);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrInvalidSrcAddrCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000034, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrInvalidSrcAddrCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrSecCount
 */
class ReadThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrSecCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrSecCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000035);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrSecCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrSecCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrSecCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000035, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrSecCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrFcsCount
 */
class ReadThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrFcsCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrFcsCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000036);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrFcsCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrFcsCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrFcsCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000036, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrFcsCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrOtherCount
 */
class ReadThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrOtherCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrOtherCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000037);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrOtherCount report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrOtherCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrOtherCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000037, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.RxErrOtherCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveTimestamp
 */
class ReadThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsActiveTimestamp() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveTimestamp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000038);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ActiveTimestamp report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsActiveTimestamp() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsActiveTimestamp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000038, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ActiveTimestamp report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PendingTimestamp
 */
class ReadThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsPendingTimestamp() : ModelCommand("read")
    {
        AddArgument("attr-name", "pending-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPendingTimestamp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x00000039);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.PendingTimestamp report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsPendingTimestamp() : ModelCommand("report")
    {
        AddArgument("attr-name", "pending-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPendingTimestamp() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x00000039, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.PendingTimestamp report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Delay
 */
class ReadThreadNetworkDiagnosticsDelay : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsDelay() : ModelCommand("read")
    {
        AddArgument("attr-name", "delay");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDelay() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000003A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.Delay report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsDelay : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsDelay() : ModelCommand("report")
    {
        AddArgument("attr-name", "delay");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDelay() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000003A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.Delay report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityPolicy
 */
class ReadThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsSecurityPolicy() : ModelCommand("read")
    {
        AddArgument("attr-name", "security-policy");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsSecurityPolicy() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000003B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.SecurityPolicy report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsSecurityPolicy() : ModelCommand("report")
    {
        AddArgument("attr-name", "security-policy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsSecurityPolicy() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000003B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.SecurityPolicy report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelMask
 */
class ReadThreadNetworkDiagnosticsChannelMask : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsChannelMask() : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-mask");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannelMask() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000003C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ChannelMask report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsChannelMask : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsChannelMask() : ModelCommand("report")
    {
        AddArgument("attr-name", "channel-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChannelMask() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000003C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ChannelMask report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalDatasetComponents
 */
class ReadThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsOperationalDatasetComponents() : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-dataset-components");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOperationalDatasetComponents() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000003D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<
            chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.OperationalDatasetComponents report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsOperationalDatasetComponents() : ModelCommand("report")
    {
        AddArgument("attr-name", "operational-dataset-components");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsOperationalDatasetComponents() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000003D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<
            chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType>
            value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.OperationalDatasetComponents report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveNetworkFaultsList
 */
class ReadThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsActiveNetworkFaultsList() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveNetworkFaultsList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000003E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ActiveNetworkFaultsList report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsActiveNetworkFaultsList() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-network-faults-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsActiveNetworkFaultsList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000003E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ActiveNetworkFaultsList report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThreadNetworkDiagnosticsAttributeList : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadThreadNetworkDiagnosticsFeatureMap : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.FeatureMap report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadThreadNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000035, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ClusterRevision report", 0, value);
    }
};

class ReportThreadNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000035, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("ThreadNetworkDiagnostics.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster UserLabel                                                   | 0x0041 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventUserLabelWildcard : public ModelCommand
{
public:
    ReadEventUserLabelWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventUserLabelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000041, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventUserLabelWildcard : public ModelCommand
{
public:
    ReportEventUserLabelWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventUserLabelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000041, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadUserLabelWildcard : public ModelCommand
{
public:
    ReadUserLabelWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000041, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportUserLabelWildcard : public ModelCommand
{
public:
    ReportUserLabelWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUserLabelWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000041, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LabelList
 */
class ReadUserLabelLabelList : public ModelCommand
{
public:
    ReadUserLabelLabelList() : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelLabelList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000041, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("UserLabel.LabelList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadUserLabelClusterRevision : public ModelCommand
{
public:
    ReadUserLabelClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000041, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("UserLabel.ClusterRevision report", 0, value);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster WakeOnLan                                                   | 0x0503 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * WakeOnLanMacAddress                                               | 0x0000 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Event Wildcard
 */
class ReadEventWakeOnLanWildcard : public ModelCommand
{
public:
    ReadEventWakeOnLanWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventWakeOnLanWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000503, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventWakeOnLanWildcard : public ModelCommand
{
public:
    ReportEventWakeOnLanWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventWakeOnLanWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000503, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadWakeOnLanWildcard : public ModelCommand
{
public:
    ReadWakeOnLanWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000503, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportWakeOnLanWildcard : public ModelCommand
{
public:
    ReportWakeOnLanWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000503, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WakeOnLanMacAddress
 */
class ReadWakeOnLanWakeOnLanMacAddress : public ModelCommand
{
public:
    ReadWakeOnLanWakeOnLanMacAddress() : ModelCommand("read")
    {
        AddArgument("attr-name", "wake-on-lan-mac-address");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanWakeOnLanMacAddress() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000503, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WakeOnLan.WakeOnLanMacAddress report", 0, value);
    }
};

class ReportWakeOnLanWakeOnLanMacAddress : public ModelCommand
{
public:
    ReportWakeOnLanWakeOnLanMacAddress() : ModelCommand("report")
    {
        AddArgument("attr-name", "wake-on-lan-mac-address");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanWakeOnLanMacAddress() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000503, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::CharSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WakeOnLan.WakeOnLanMacAddress report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWakeOnLanAttributeList : public ModelCommand
{
public:
    ReadWakeOnLanAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000503, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WakeOnLan.AttributeList report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadWakeOnLanClusterRevision : public ModelCommand
{
public:
    ReadWakeOnLanClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000503, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WakeOnLan.ClusterRevision report", 0, value);
    }
};

class ReportWakeOnLanClusterRevision : public ModelCommand
{
public:
    ReportWakeOnLanClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000503, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WakeOnLan.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WiFiNetworkDiagnostics                                      | 0x0036 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Bssid                                                             | 0x0000 |
| * SecurityType                                                      | 0x0001 |
| * WiFiVersion                                                       | 0x0002 |
| * ChannelNumber                                                     | 0x0003 |
| * Rssi                                                              | 0x0004 |
| * BeaconLostCount                                                   | 0x0005 |
| * BeaconRxCount                                                     | 0x0006 |
| * PacketMulticastRxCount                                            | 0x0007 |
| * PacketMulticastTxCount                                            | 0x0008 |
| * PacketUnicastRxCount                                              | 0x0009 |
| * PacketUnicastTxCount                                              | 0x000A |
| * CurrentMaxRate                                                    | 0x000B |
| * OverrunCount                                                      | 0x000C |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * Disconnection                                                     | 0x0000 |
| * AssociationFailure                                                | 0x0001 |
| * ConnectionStatus                                                  | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class WiFiNetworkDiagnosticsResetCounts : public ModelCommand
{
public:
    WiFiNetworkDiagnosticsResetCounts() : ModelCommand("reset-counts") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::WiFiNetworkDiagnostics::Commands::ResetCounts::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventWiFiNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReadEventWiFiNetworkDiagnosticsWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventWiFiNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000036, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventWiFiNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReportEventWiFiNetworkDiagnosticsWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventWiFiNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000036, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event Disconnection
 */
class ReadWiFiNetworkDiagnosticsDisconnection : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsDisconnection() : ModelCommand("read-event")
    {
        AddArgument("event-name", "disconnection");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsDisconnection() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000036, 0x00000000);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::WiFiNetworkDiagnostics::Events::Disconnection::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.Disconnection report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsDisconnection : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsDisconnection() : ModelCommand("report-event")
    {
        AddArgument("event-name", "disconnection");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsDisconnection() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000036, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::WiFiNetworkDiagnostics::Events::Disconnection::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.Disconnection report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event AssociationFailure
 */
class ReadWiFiNetworkDiagnosticsAssociationFailure : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsAssociationFailure() : ModelCommand("read-event")
    {
        AddArgument("event-name", "association-failure");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsAssociationFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000036, 0x00000001);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::WiFiNetworkDiagnostics::Events::AssociationFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.AssociationFailure report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsAssociationFailure : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsAssociationFailure() : ModelCommand("report-event")
    {
        AddArgument("event-name", "association-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsAssociationFailure() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000036, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::WiFiNetworkDiagnostics::Events::AssociationFailure::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.AssociationFailure report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ConnectionStatus
 */
class ReadWiFiNetworkDiagnosticsConnectionStatus : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsConnectionStatus() : ModelCommand("read-event")
    {
        AddArgument("event-name", "connection-status");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsConnectionStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000036, 0x00000002);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::WiFiNetworkDiagnostics::Events::ConnectionStatus::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.ConnectionStatus report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsConnectionStatus : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsConnectionStatus() : ModelCommand("report-event")
    {
        AddArgument("event-name", "connection-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsConnectionStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000036, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        chip::app::Clusters::WiFiNetworkDiagnostics::Events::ConnectionStatus::DecodableType value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.ConnectionStatus report", 0, value);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadWiFiNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsWildcard : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bssid
 */
class ReadWiFiNetworkDiagnosticsBssid : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsBssid() : ModelCommand("read")
    {
        AddArgument("attr-name", "bssid");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBssid() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.Bssid report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsBssid : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsBssid() : ModelCommand("report")
    {
        AddArgument("attr-name", "bssid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBssid() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::ByteSpan value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.Bssid report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityType
 */
class ReadWiFiNetworkDiagnosticsSecurityType : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsSecurityType() : ModelCommand("read")
    {
        AddArgument("attr-name", "security-type");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsSecurityType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000001);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.SecurityType report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsSecurityType : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsSecurityType() : ModelCommand("report")
    {
        AddArgument("attr-name", "security-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsSecurityType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000001, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.SecurityType report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WiFiVersion
 */
class ReadWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsWiFiVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "wi-fi-version");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsWiFiVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000002);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.WiFiVersion report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsWiFiVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "wi-fi-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsWiFiVersion() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000002, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.WiFiVersion report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelNumber
 */
class ReadWiFiNetworkDiagnosticsChannelNumber : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsChannelNumber() : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-number");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsChannelNumber() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.ChannelNumber report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsChannelNumber : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsChannelNumber() : ModelCommand("report")
    {
        AddArgument("attr-name", "channel-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsChannelNumber() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.ChannelNumber report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Rssi
 */
class ReadWiFiNetworkDiagnosticsRssi : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsRssi() : ModelCommand("read")
    {
        AddArgument("attr-name", "rssi");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsRssi() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.Rssi report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsRssi : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsRssi() : ModelCommand("report")
    {
        AddArgument("attr-name", "rssi");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsRssi() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        int8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.Rssi report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconLostCount
 */
class ReadWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsBeaconLostCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-lost-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconLostCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000005);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.BeaconLostCount report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsBeaconLostCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "beacon-lost-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBeaconLostCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000005, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.BeaconLostCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconRxCount
 */
class ReadWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsBeaconRxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconRxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000006);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.BeaconRxCount report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsBeaconRxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "beacon-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBeaconRxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000006, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.BeaconRxCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastRxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastRxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.PacketMulticastRxCount report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsPacketMulticastRxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketMulticastRxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.PacketMulticastRxCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastTxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastTxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.PacketMulticastTxCount report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsPacketMulticastTxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketMulticastTxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.PacketMulticastTxCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastRxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastRxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x00000009);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.PacketUnicastRxCount report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsPacketUnicastRxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketUnicastRxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x00000009, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.PacketUnicastRxCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastTxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastTxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x0000000A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.PacketUnicastTxCount report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsPacketUnicastTxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketUnicastTxCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x0000000A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.PacketUnicastTxCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMaxRate
 */
class ReadWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsCurrentMaxRate() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-max-rate");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsCurrentMaxRate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x0000000B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.CurrentMaxRate report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsCurrentMaxRate() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-max-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsCurrentMaxRate() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x0000000B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.CurrentMaxRate report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadWiFiNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsOverrunCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x0000000C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.OverrunCount report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsOverrunCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x0000000C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint64_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.OverrunCount report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWiFiNetworkDiagnosticsAttributeList : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadWiFiNetworkDiagnosticsFeatureMap : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.FeatureMap report", 0, value);
    }
};

/*
 * Attribute ClusterRevision
 */
class ReadWiFiNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000036, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.ClusterRevision report", 0, value);
    }
};

class ReportWiFiNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000036, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WiFiNetworkDiagnostics.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WindowCovering                                              | 0x0102 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * DownOrClose                                                       |   0x01 |
| * GoToLiftPercentage                                                |   0x05 |
| * GoToLiftValue                                                     |   0x04 |
| * GoToTiltPercentage                                                |   0x08 |
| * GoToTiltValue                                                     |   0x07 |
| * StopMotion                                                        |   0x02 |
| * UpOrOpen                                                          |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Type                                                              | 0x0000 |
| * CurrentPositionLift                                               | 0x0003 |
| * CurrentPositionTilt                                               | 0x0004 |
| * ConfigStatus                                                      | 0x0007 |
| * CurrentPositionLiftPercentage                                     | 0x0008 |
| * CurrentPositionTiltPercentage                                     | 0x0009 |
| * OperationalStatus                                                 | 0x000A |
| * TargetPositionLiftPercent100ths                                   | 0x000B |
| * TargetPositionTiltPercent100ths                                   | 0x000C |
| * EndProductType                                                    | 0x000D |
| * CurrentPositionLiftPercent100ths                                  | 0x000E |
| * CurrentPositionTiltPercent100ths                                  | 0x000F |
| * InstalledOpenLimitLift                                            | 0x0010 |
| * InstalledClosedLimitLift                                          | 0x0011 |
| * InstalledOpenLimitTilt                                            | 0x0012 |
| * InstalledClosedLimitTilt                                          | 0x0013 |
| * Mode                                                              | 0x0017 |
| * SafetyStatus                                                      | 0x001A |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command DownOrClose
 */
class WindowCoveringDownOrClose : public ModelCommand
{
public:
    WindowCoveringDownOrClose() : ModelCommand("down-or-close") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000001) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type mRequest;
};

/*
 * Command GoToLiftPercentage
 */
class WindowCoveringGoToLiftPercentage : public ModelCommand
{
public:
    WindowCoveringGoToLiftPercentage() : ModelCommand("go-to-lift-percentage")
    {
        AddArgument("LiftPercentageValue", 0, UINT8_MAX, &mRequest.liftPercentageValue);
        AddArgument("LiftPercent100thsValue", 0, UINT16_MAX, &mRequest.liftPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000005) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type mRequest;
};

/*
 * Command GoToLiftValue
 */
class WindowCoveringGoToLiftValue : public ModelCommand
{
public:
    WindowCoveringGoToLiftValue() : ModelCommand("go-to-lift-value")
    {
        AddArgument("LiftValue", 0, UINT16_MAX, &mRequest.liftValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000004) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::GoToLiftValue::Type mRequest;
};

/*
 * Command GoToTiltPercentage
 */
class WindowCoveringGoToTiltPercentage : public ModelCommand
{
public:
    WindowCoveringGoToTiltPercentage() : ModelCommand("go-to-tilt-percentage")
    {
        AddArgument("TiltPercentageValue", 0, UINT8_MAX, &mRequest.tiltPercentageValue);
        AddArgument("TiltPercent100thsValue", 0, UINT16_MAX, &mRequest.tiltPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000008) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type mRequest;
};

/*
 * Command GoToTiltValue
 */
class WindowCoveringGoToTiltValue : public ModelCommand
{
public:
    WindowCoveringGoToTiltValue() : ModelCommand("go-to-tilt-value")
    {
        AddArgument("TiltValue", 0, UINT16_MAX, &mRequest.tiltValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000007) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::GoToTiltValue::Type mRequest;
};

/*
 * Command StopMotion
 */
class WindowCoveringStopMotion : public ModelCommand
{
public:
    WindowCoveringStopMotion() : ModelCommand("stop-motion") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000002) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::StopMotion::Type mRequest;
};

/*
 * Command UpOrOpen
 */
class WindowCoveringUpOrOpen : public ModelCommand
{
public:
    WindowCoveringUpOrOpen() : ModelCommand("up-or-open") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000000) on endpoint %" PRIu16, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest,
                                               mTimedInteractionTimeoutMs);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type mRequest;
};

/*
 * Event Wildcard
 */
class ReadEventWindowCoveringWildcard : public ModelCommand
{
public:
    ReadEventWindowCoveringWildcard() : ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventWindowCoveringWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, 0x00000102, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventWindowCoveringWildcard : public ModelCommand
{
public:
    ReportEventWindowCoveringWildcard() : ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventWindowCoveringWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, 0x00000102, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute wildcard
 */
class ReadWindowCoveringWildcard : public ModelCommand
{
public:
    ReadWindowCoveringWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringWildcard : public ModelCommand
{
public:
    ReportWindowCoveringWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Type
 */
class ReadWindowCoveringType : public ModelCommand
{
public:
    ReadWindowCoveringType() : ModelCommand("read")
    {
        AddArgument("attr-name", "type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000000);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.Type report", 0, value);
    }
};

class ReportWindowCoveringType : public ModelCommand
{
public:
    ReportWindowCoveringType() : ModelCommand("report")
    {
        AddArgument("attr-name", "type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000000, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.Type report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLift
 */
class ReadWindowCoveringCurrentPositionLift : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionLift() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLift() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000003);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionLift report", 0, value);
    }
};

class ReportWindowCoveringCurrentPositionLift : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionLift() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLift() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000003, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionLift report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTilt
 */
class ReadWindowCoveringCurrentPositionTilt : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionTilt() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTilt() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000004);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionTilt report", 0, value);
    }
};

class ReportWindowCoveringCurrentPositionTilt : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionTilt() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTilt() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000004, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<uint16_t> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionTilt report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ConfigStatus
 */
class ReadWindowCoveringConfigStatus : public ModelCommand
{
public:
    ReadWindowCoveringConfigStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "config-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringConfigStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000007);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.ConfigStatus report", 0, value);
    }
};

class ReportWindowCoveringConfigStatus : public ModelCommand
{
public:
    ReportWindowCoveringConfigStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "config-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringConfigStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000007, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.ConfigStatus report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercentage
 */
class ReadWindowCoveringCurrentPositionLiftPercentage : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionLiftPercentage() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercentage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000008);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionLiftPercentage report", 0, value);
    }
};

class ReportWindowCoveringCurrentPositionLiftPercentage : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionLiftPercentage() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLiftPercentage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000008, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionLiftPercentage report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercentage
 */
class ReadWindowCoveringCurrentPositionTiltPercentage : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionTiltPercentage() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercentage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000009);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionTiltPercentage report", 0, value);
    }
};

class ReportWindowCoveringCurrentPositionTiltPercentage : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionTiltPercentage() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTiltPercentage() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000009, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionTiltPercentage report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalStatus
 */
class ReadWindowCoveringOperationalStatus : public ModelCommand
{
public:
    ReadWindowCoveringOperationalStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringOperationalStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000000A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.OperationalStatus report", 0, value);
    }
};

class ReportWindowCoveringOperationalStatus : public ModelCommand
{
public:
    ReportWindowCoveringOperationalStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "operational-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringOperationalStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000000A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.OperationalStatus report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionLiftPercent100ths
 */
class ReadWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand
{
public:
    ReadWindowCoveringTargetPositionLiftPercent100ths() : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000000B);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent100ths> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.TargetPositionLiftPercent100ths report", 0, value);
    }
};

class ReportWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand
{
public:
    ReportWindowCoveringTargetPositionLiftPercent100ths() : ModelCommand("report")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringTargetPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000000B, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent100ths> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.TargetPositionLiftPercent100ths report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionTiltPercent100ths
 */
class ReadWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand
{
public:
    ReadWindowCoveringTargetPositionTiltPercent100ths() : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000000C);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent100ths> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.TargetPositionTiltPercent100ths report", 0, value);
    }
};

class ReportWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand
{
public:
    ReportWindowCoveringTargetPositionTiltPercent100ths() : ModelCommand("report")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringTargetPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000000C, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent100ths> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.TargetPositionTiltPercent100ths report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndProductType
 */
class ReadWindowCoveringEndProductType : public ModelCommand
{
public:
    ReadWindowCoveringEndProductType() : ModelCommand("read")
    {
        AddArgument("attr-name", "end-product-type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringEndProductType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000000D);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.EndProductType report", 0, value);
    }
};

class ReportWindowCoveringEndProductType : public ModelCommand
{
public:
    ReportWindowCoveringEndProductType() : ModelCommand("report")
    {
        AddArgument("attr-name", "end-product-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringEndProductType() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000000D, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.EndProductType report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercent100ths
 */
class ReadWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionLiftPercent100ths() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000000E);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent100ths> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionLiftPercent100ths report", 0, value);
    }
};

class ReportWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionLiftPercent100ths() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000000E, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent100ths> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionLiftPercent100ths report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercent100ths
 */
class ReadWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionTiltPercent100ths() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000000F);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent100ths> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionTiltPercent100ths report", 0, value);
    }
};

class ReportWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionTiltPercent100ths() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000000F, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::Nullable<chip::Percent100ths> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.CurrentPositionTiltPercent100ths report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitLift
 */
class ReadWindowCoveringInstalledOpenLimitLift : public ModelCommand
{
public:
    ReadWindowCoveringInstalledOpenLimitLift() : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitLift() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000010);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.InstalledOpenLimitLift report", 0, value);
    }
};

class ReportWindowCoveringInstalledOpenLimitLift : public ModelCommand
{
public:
    ReportWindowCoveringInstalledOpenLimitLift() : ModelCommand("report")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledOpenLimitLift() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000010, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.InstalledOpenLimitLift report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitLift
 */
class ReadWindowCoveringInstalledClosedLimitLift : public ModelCommand
{
public:
    ReadWindowCoveringInstalledClosedLimitLift() : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitLift() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000011);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.InstalledClosedLimitLift report", 0, value);
    }
};

class ReportWindowCoveringInstalledClosedLimitLift : public ModelCommand
{
public:
    ReportWindowCoveringInstalledClosedLimitLift() : ModelCommand("report")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledClosedLimitLift() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000011, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.InstalledClosedLimitLift report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitTilt
 */
class ReadWindowCoveringInstalledOpenLimitTilt : public ModelCommand
{
public:
    ReadWindowCoveringInstalledOpenLimitTilt() : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitTilt() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000012);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.InstalledOpenLimitTilt report", 0, value);
    }
};

class ReportWindowCoveringInstalledOpenLimitTilt : public ModelCommand
{
public:
    ReportWindowCoveringInstalledOpenLimitTilt() : ModelCommand("report")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledOpenLimitTilt() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000012, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.InstalledOpenLimitTilt report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitTilt
 */
class ReadWindowCoveringInstalledClosedLimitTilt : public ModelCommand
{
public:
    ReadWindowCoveringInstalledClosedLimitTilt() : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitTilt() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000013);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.InstalledClosedLimitTilt report", 0, value);
    }
};

class ReportWindowCoveringInstalledClosedLimitTilt : public ModelCommand
{
public:
    ReportWindowCoveringInstalledClosedLimitTilt() : ModelCommand("report")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledClosedLimitTilt() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000013, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.InstalledClosedLimitTilt report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Mode
 */
class ReadWindowCoveringMode : public ModelCommand
{
public:
    ReadWindowCoveringMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "mode");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x00000017);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.Mode report", 0, value);
    }
};

class WriteWindowCoveringMode : public ModelCommand
{
public:
    WriteWindowCoveringMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteWindowCoveringMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, 0x00000102, 0x00000017, mValue);
    }

private:
    uint8_t mValue;
};

class ReportWindowCoveringMode : public ModelCommand
{
public:
    ReportWindowCoveringMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringMode() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x00000017, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint8_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.Mode report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SafetyStatus
 */
class ReadWindowCoveringSafetyStatus : public ModelCommand
{
public:
    ReadWindowCoveringSafetyStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringSafetyStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000001A);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.SafetyStatus report", 0, value);
    }
};

class ReportWindowCoveringSafetyStatus : public ModelCommand
{
public:
    ReportWindowCoveringSafetyStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringSafetyStatus() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000001A, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.SafetyStatus report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWindowCoveringAttributeList : public ModelCommand
{
public:
    ReadWindowCoveringAttributeList() : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringAttributeList() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000FFFB);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        chip::app::DataModel::DecodableList<chip::AttributeId> value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.AttributeList report", 0, value);
    }
};

/*
 * Attribute FeatureMap
 */
class ReadWindowCoveringFeatureMap : public ModelCommand
{
public:
    ReadWindowCoveringFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000FFFC);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.FeatureMap report", 0, value);
    }
};

class ReportWindowCoveringFeatureMap : public ModelCommand
{
public:
    ReportWindowCoveringFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringFeatureMap() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000FFFC, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint32_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.FeatureMap report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWindowCoveringClusterRevision : public ModelCommand
{
public:
    ReadWindowCoveringClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, 0x00000102, 0x0000FFFD);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.ClusterRevision report", 0, value);
    }
};

class ReportWindowCoveringClusterRevision : public ModelCommand
{
public:
    ReportWindowCoveringClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringClusterRevision() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, 0x00000102, 0x0000FFFD, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        uint16_t value;
        ReturnErrorOnFailure(chip::app::DataModel::Decode(*data, value));
        return LogValue("WindowCovering.ClusterRevision report", 0, value);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Event Wildcard
 */
class ReadEventWildcard : public ModelCommand
{
public:
    ReadEventWildcard() : ModelCommand("read-event")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, chip::kInvalidClusterId, chip::kInvalidEventId);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }
};

class ReportEventWildcard : public ModelCommand
{
public:
    ReportEventWildcard() : ModelCommand("report-event")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, chip::kInvalidClusterId, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnEventData(const chip::app::EventHeader & header, chip::TLV::TLVReader * data) override
    {
        LogEventHeader(header);
        // TODO: Generate a method that log the value based on the content of the data
        return CHIP_NO_ERROR;
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

class ReadWildcard : public ModelCommand
{
public:
    ReadWildcard() : ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, chip::kInvalidClusterId, chip::kInvalidAttributeId);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }
};

class ReportWildcard : public ModelCommand
{
public:
    ReportWildcard() : ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWildcard() {}

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, chip::kInvalidClusterId, chip::kInvalidAttributeId, mMinInterval,
                                  mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    CHIP_ERROR OnAttributeData(const chip::app::ConcreteDataAttributePath & path, chip::TLV::TLVReader * data) override
    {
        LogAttributePath(path);
        // TODO: Generate a method that Log the value based on the content of the ConcreteDataAttributePath
        return CHIP_NO_ERROR;
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Register all Clusters commands                                               |
\*----------------------------------------------------------------------------*/
void registerClusterAccessControl(Commands & commands)
{
    const char * clusterName = "AccessControl";

    commands_list clusterCommands = {
        make_unique<ReadAccessControlWildcard>(),        //
        make_unique<ReportAccessControlWildcard>(),      //
        make_unique<ReadAccessControlAcl>(),             //
        make_unique<ReadAccessControlExtension>(),       //
        make_unique<ReadAccessControlAttributeList>(),   //
        make_unique<ReadAccessControlClusterRevision>(), //
        make_unique<ReadEventAccessControlWildcard>(),   //
        make_unique<ReportEventAccessControlWildcard>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAccountLogin(Commands & commands)
{
    const char * clusterName = "AccountLogin";

    commands_list clusterCommands = {
        make_unique<AccountLoginGetSetupPINRequest>(),    //
        make_unique<AccountLoginLoginRequest>(),          //
        make_unique<AccountLoginLogoutRequest>(),         //
        make_unique<ReadAccountLoginWildcard>(),          //
        make_unique<ReportAccountLoginWildcard>(),        //
        make_unique<ReadAccountLoginAttributeList>(),     //
        make_unique<ReadAccountLoginClusterRevision>(),   //
        make_unique<ReportAccountLoginClusterRevision>(), //
        make_unique<ReadEventAccountLoginWildcard>(),     //
        make_unique<ReportEventAccountLoginWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAdministratorCommissioning(Commands & commands)
{
    const char * clusterName = "AdministratorCommissioning";

    commands_list clusterCommands = {
        make_unique<AdministratorCommissioningOpenBasicCommissioningWindow>(), //
        make_unique<AdministratorCommissioningOpenCommissioningWindow>(),      //
        make_unique<AdministratorCommissioningRevokeCommissioning>(),          //
        make_unique<ReadAdministratorCommissioningWildcard>(),                 //
        make_unique<ReportAdministratorCommissioningWildcard>(),               //
        make_unique<ReadAdministratorCommissioningWindowStatus>(),             //
        make_unique<ReadAdministratorCommissioningAdminFabricIndex>(),         //
        make_unique<ReadAdministratorCommissioningAdminVendorId>(),            //
        make_unique<ReadAdministratorCommissioningAttributeList>(),            //
        make_unique<ReadAdministratorCommissioningClusterRevision>(),          //
        make_unique<ReportAdministratorCommissioningClusterRevision>(),        //
        make_unique<ReadEventAdministratorCommissioningWildcard>(),            //
        make_unique<ReportEventAdministratorCommissioningWildcard>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationBasic(Commands & commands)
{
    const char * clusterName = "ApplicationBasic";

    commands_list clusterCommands = {
        make_unique<ReadApplicationBasicWildcard>(),             //
        make_unique<ReportApplicationBasicWildcard>(),           //
        make_unique<ReadApplicationBasicVendorName>(),           //
        make_unique<ReportApplicationBasicVendorName>(),         //
        make_unique<ReadApplicationBasicVendorId>(),             //
        make_unique<ReportApplicationBasicVendorId>(),           //
        make_unique<ReadApplicationBasicApplicationName>(),      //
        make_unique<ReportApplicationBasicApplicationName>(),    //
        make_unique<ReadApplicationBasicProductId>(),            //
        make_unique<ReportApplicationBasicProductId>(),          //
        make_unique<ReadApplicationBasicApplicationStatus>(),    //
        make_unique<ReportApplicationBasicApplicationStatus>(),  //
        make_unique<ReadApplicationBasicApplicationVersion>(),   //
        make_unique<ReportApplicationBasicApplicationVersion>(), //
        make_unique<ReadApplicationBasicAllowedVendorList>(),    //
        make_unique<ReadApplicationBasicAttributeList>(),        //
        make_unique<ReadApplicationBasicClusterRevision>(),      //
        make_unique<ReportApplicationBasicClusterRevision>(),    //
        make_unique<ReadEventApplicationBasicWildcard>(),        //
        make_unique<ReportEventApplicationBasicWildcard>(),      //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationLauncher(Commands & commands)
{
    const char * clusterName = "ApplicationLauncher";

    commands_list clusterCommands = {
        make_unique<ApplicationLauncherHideAppRequest>(),              //
        make_unique<ApplicationLauncherLaunchAppRequest>(),            //
        make_unique<ApplicationLauncherStopAppRequest>(),              //
        make_unique<ReadApplicationLauncherWildcard>(),                //
        make_unique<ReportApplicationLauncherWildcard>(),              //
        make_unique<ReadApplicationLauncherApplicationLauncherList>(), //
        make_unique<ReadApplicationLauncherAttributeList>(),           //
        make_unique<ReadApplicationLauncherClusterRevision>(),         //
        make_unique<ReportApplicationLauncherClusterRevision>(),       //
        make_unique<ReadEventApplicationLauncherWildcard>(),           //
        make_unique<ReportEventApplicationLauncherWildcard>(),         //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAudioOutput(Commands & commands)
{
    const char * clusterName = "AudioOutput";

    commands_list clusterCommands = {
        make_unique<AudioOutputRenameOutputRequest>(),      //
        make_unique<AudioOutputSelectOutputRequest>(),      //
        make_unique<ReadAudioOutputWildcard>(),             //
        make_unique<ReportAudioOutputWildcard>(),           //
        make_unique<ReadAudioOutputAudioOutputList>(),      //
        make_unique<ReadAudioOutputCurrentAudioOutput>(),   //
        make_unique<ReportAudioOutputCurrentAudioOutput>(), //
        make_unique<ReadAudioOutputAttributeList>(),        //
        make_unique<ReadAudioOutputClusterRevision>(),      //
        make_unique<ReportAudioOutputClusterRevision>(),    //
        make_unique<ReadEventAudioOutputWildcard>(),        //
        make_unique<ReportEventAudioOutputWildcard>(),      //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBarrierControl(Commands & commands)
{
    const char * clusterName = "BarrierControl";

    commands_list clusterCommands = {
        make_unique<BarrierControlBarrierControlGoToPercent>(), //
        make_unique<BarrierControlBarrierControlStop>(),        //
        make_unique<ReadBarrierControlWildcard>(),              //
        make_unique<ReportBarrierControlWildcard>(),            //
        make_unique<ReadBarrierControlBarrierMovingState>(),    //
        make_unique<ReportBarrierControlBarrierMovingState>(),  //
        make_unique<ReadBarrierControlBarrierSafetyStatus>(),   //
        make_unique<ReportBarrierControlBarrierSafetyStatus>(), //
        make_unique<ReadBarrierControlBarrierCapabilities>(),   //
        make_unique<ReportBarrierControlBarrierCapabilities>(), //
        make_unique<ReadBarrierControlBarrierPosition>(),       //
        make_unique<ReportBarrierControlBarrierPosition>(),     //
        make_unique<ReadBarrierControlAttributeList>(),         //
        make_unique<ReadBarrierControlClusterRevision>(),       //
        make_unique<ReportBarrierControlClusterRevision>(),     //
        make_unique<ReadEventBarrierControlWildcard>(),         //
        make_unique<ReportEventBarrierControlWildcard>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBasic(Commands & commands)
{
    const char * clusterName = "Basic";

    commands_list clusterCommands = {
        make_unique<BasicMfgSpecificPing>(),               //
        make_unique<ReadBasicWildcard>(),                  //
        make_unique<ReportBasicWildcard>(),                //
        make_unique<ReadBasicInteractionModelVersion>(),   //
        make_unique<ReportBasicInteractionModelVersion>(), //
        make_unique<ReadBasicVendorName>(),                //
        make_unique<ReportBasicVendorName>(),              //
        make_unique<ReadBasicVendorID>(),                  //
        make_unique<ReportBasicVendorID>(),                //
        make_unique<ReadBasicProductName>(),               //
        make_unique<ReportBasicProductName>(),             //
        make_unique<ReadBasicProductID>(),                 //
        make_unique<ReportBasicProductID>(),               //
        make_unique<ReadBasicNodeLabel>(),                 //
        make_unique<WriteBasicNodeLabel>(),                //
        make_unique<ReportBasicNodeLabel>(),               //
        make_unique<ReadBasicLocation>(),                  //
        make_unique<WriteBasicLocation>(),                 //
        make_unique<ReportBasicLocation>(),                //
        make_unique<ReadBasicHardwareVersion>(),           //
        make_unique<ReportBasicHardwareVersion>(),         //
        make_unique<ReadBasicHardwareVersionString>(),     //
        make_unique<ReportBasicHardwareVersionString>(),   //
        make_unique<ReadBasicSoftwareVersion>(),           //
        make_unique<ReportBasicSoftwareVersion>(),         //
        make_unique<ReadBasicSoftwareVersionString>(),     //
        make_unique<ReportBasicSoftwareVersionString>(),   //
        make_unique<ReadBasicManufacturingDate>(),         //
        make_unique<ReportBasicManufacturingDate>(),       //
        make_unique<ReadBasicPartNumber>(),                //
        make_unique<ReportBasicPartNumber>(),              //
        make_unique<ReadBasicProductURL>(),                //
        make_unique<ReportBasicProductURL>(),              //
        make_unique<ReadBasicProductLabel>(),              //
        make_unique<ReportBasicProductLabel>(),            //
        make_unique<ReadBasicSerialNumber>(),              //
        make_unique<ReportBasicSerialNumber>(),            //
        make_unique<ReadBasicLocalConfigDisabled>(),       //
        make_unique<WriteBasicLocalConfigDisabled>(),      //
        make_unique<ReportBasicLocalConfigDisabled>(),     //
        make_unique<ReadBasicReachable>(),                 //
        make_unique<ReportBasicReachable>(),               //
        make_unique<ReadBasicUniqueID>(),                  //
        make_unique<ReadBasicAttributeList>(),             //
        make_unique<ReadBasicClusterRevision>(),           //
        make_unique<ReportBasicClusterRevision>(),         //
        make_unique<ReadEventBasicWildcard>(),             //
        make_unique<ReportEventBasicWildcard>(),           //
        make_unique<ReadBasicStartUp>(),                   //
        make_unique<ReportBasicStartUp>(),                 //
        make_unique<ReadBasicShutDown>(),                  //
        make_unique<ReportBasicShutDown>(),                //
        make_unique<ReadBasicLeave>(),                     //
        make_unique<ReportBasicLeave>(),                   //
        make_unique<ReadBasicReachableChanged>(),          //
        make_unique<ReportBasicReachableChanged>(),        //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinaryInputBasic(Commands & commands)
{
    const char * clusterName = "BinaryInputBasic";

    commands_list clusterCommands = {
        make_unique<ReadBinaryInputBasicWildcard>(),          //
        make_unique<ReportBinaryInputBasicWildcard>(),        //
        make_unique<ReadBinaryInputBasicOutOfService>(),      //
        make_unique<WriteBinaryInputBasicOutOfService>(),     //
        make_unique<ReportBinaryInputBasicOutOfService>(),    //
        make_unique<ReadBinaryInputBasicPresentValue>(),      //
        make_unique<WriteBinaryInputBasicPresentValue>(),     //
        make_unique<ReportBinaryInputBasicPresentValue>(),    //
        make_unique<ReadBinaryInputBasicStatusFlags>(),       //
        make_unique<ReportBinaryInputBasicStatusFlags>(),     //
        make_unique<ReadBinaryInputBasicAttributeList>(),     //
        make_unique<ReadBinaryInputBasicClusterRevision>(),   //
        make_unique<ReportBinaryInputBasicClusterRevision>(), //
        make_unique<ReadEventBinaryInputBasicWildcard>(),     //
        make_unique<ReportEventBinaryInputBasicWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinding(Commands & commands)
{
    const char * clusterName = "Binding";

    commands_list clusterCommands = {
        make_unique<BindingBind>(),                  //
        make_unique<BindingUnbind>(),                //
        make_unique<ReadBindingWildcard>(),          //
        make_unique<ReportBindingWildcard>(),        //
        make_unique<ReadBindingAttributeList>(),     //
        make_unique<ReadBindingClusterRevision>(),   //
        make_unique<ReportBindingClusterRevision>(), //
        make_unique<ReadEventBindingWildcard>(),     //
        make_unique<ReportEventBindingWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBooleanState(Commands & commands)
{
    const char * clusterName = "BooleanState";

    commands_list clusterCommands = {
        make_unique<ReadBooleanStateWildcard>(),          //
        make_unique<ReportBooleanStateWildcard>(),        //
        make_unique<ReadBooleanStateStateValue>(),        //
        make_unique<ReportBooleanStateStateValue>(),      //
        make_unique<ReadBooleanStateAttributeList>(),     //
        make_unique<ReadBooleanStateClusterRevision>(),   //
        make_unique<ReportBooleanStateClusterRevision>(), //
        make_unique<ReadEventBooleanStateWildcard>(),     //
        make_unique<ReportEventBooleanStateWildcard>(),   //
        make_unique<ReadBooleanStateStateChange>(),       //
        make_unique<ReportBooleanStateStateChange>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedActions(Commands & commands)
{
    const char * clusterName = "BridgedActions";

    commands_list clusterCommands = {
        make_unique<BridgedActionsDisableAction>(),               //
        make_unique<BridgedActionsDisableActionWithDuration>(),   //
        make_unique<BridgedActionsEnableAction>(),                //
        make_unique<BridgedActionsEnableActionWithDuration>(),    //
        make_unique<BridgedActionsInstantAction>(),               //
        make_unique<BridgedActionsInstantActionWithTransition>(), //
        make_unique<BridgedActionsPauseAction>(),                 //
        make_unique<BridgedActionsPauseActionWithDuration>(),     //
        make_unique<BridgedActionsResumeAction>(),                //
        make_unique<BridgedActionsStartAction>(),                 //
        make_unique<BridgedActionsStartActionWithDuration>(),     //
        make_unique<BridgedActionsStopAction>(),                  //
        make_unique<ReadBridgedActionsWildcard>(),                //
        make_unique<ReportBridgedActionsWildcard>(),              //
        make_unique<ReadBridgedActionsActionList>(),              //
        make_unique<ReadBridgedActionsEndpointList>(),            //
        make_unique<ReadBridgedActionsSetupUrl>(),                //
        make_unique<ReportBridgedActionsSetupUrl>(),              //
        make_unique<ReadBridgedActionsAttributeList>(),           //
        make_unique<ReadBridgedActionsClusterRevision>(),         //
        make_unique<ReportBridgedActionsClusterRevision>(),       //
        make_unique<ReadEventBridgedActionsWildcard>(),           //
        make_unique<ReportEventBridgedActionsWildcard>(),         //
        make_unique<ReadBridgedActionsStateChanged>(),            //
        make_unique<ReportBridgedActionsStateChanged>(),          //
        make_unique<ReadBridgedActionsActionFailed>(),            //
        make_unique<ReportBridgedActionsActionFailed>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedDeviceBasic(Commands & commands)
{
    const char * clusterName = "BridgedDeviceBasic";

    commands_list clusterCommands = {
        make_unique<ReadBridgedDeviceBasicWildcard>(),          //
        make_unique<ReportBridgedDeviceBasicWildcard>(),        //
        make_unique<ReadBridgedDeviceBasicAttributeList>(),     //
        make_unique<ReadBridgedDeviceBasicClusterRevision>(),   //
        make_unique<ReportBridgedDeviceBasicClusterRevision>(), //
        make_unique<ReadEventBridgedDeviceBasicWildcard>(),     //
        make_unique<ReportEventBridgedDeviceBasicWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterChannel(Commands & commands)
{
    const char * clusterName = "Channel";

    commands_list clusterCommands = {
        make_unique<ChannelChangeChannelByNumberRequest>(), //
        make_unique<ChannelChangeChannelRequest>(),         //
        make_unique<ChannelSkipChannelRequest>(),           //
        make_unique<ReadChannelWildcard>(),                 //
        make_unique<ReportChannelWildcard>(),               //
        make_unique<ReadChannelChannelList>(),              //
        make_unique<ReadChannelAttributeList>(),            //
        make_unique<ReadChannelClusterRevision>(),          //
        make_unique<ReportChannelClusterRevision>(),        //
        make_unique<ReadEventChannelWildcard>(),            //
        make_unique<ReportEventChannelWildcard>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterColorControl(Commands & commands)
{
    const char * clusterName = "ColorControl";

    commands_list clusterCommands = {
        make_unique<ColorControlColorLoopSet>(),                          //
        make_unique<ColorControlEnhancedMoveHue>(),                       //
        make_unique<ColorControlEnhancedMoveToHue>(),                     //
        make_unique<ColorControlEnhancedMoveToHueAndSaturation>(),        //
        make_unique<ColorControlEnhancedStepHue>(),                       //
        make_unique<ColorControlMoveColor>(),                             //
        make_unique<ColorControlMoveColorTemperature>(),                  //
        make_unique<ColorControlMoveHue>(),                               //
        make_unique<ColorControlMoveSaturation>(),                        //
        make_unique<ColorControlMoveToColor>(),                           //
        make_unique<ColorControlMoveToColorTemperature>(),                //
        make_unique<ColorControlMoveToHue>(),                             //
        make_unique<ColorControlMoveToHueAndSaturation>(),                //
        make_unique<ColorControlMoveToSaturation>(),                      //
        make_unique<ColorControlStepColor>(),                             //
        make_unique<ColorControlStepColorTemperature>(),                  //
        make_unique<ColorControlStepHue>(),                               //
        make_unique<ColorControlStepSaturation>(),                        //
        make_unique<ColorControlStopMoveStep>(),                          //
        make_unique<ReadColorControlWildcard>(),                          //
        make_unique<ReportColorControlWildcard>(),                        //
        make_unique<ReadColorControlCurrentHue>(),                        //
        make_unique<ReportColorControlCurrentHue>(),                      //
        make_unique<ReadColorControlCurrentSaturation>(),                 //
        make_unique<ReportColorControlCurrentSaturation>(),               //
        make_unique<ReadColorControlRemainingTime>(),                     //
        make_unique<ReportColorControlRemainingTime>(),                   //
        make_unique<ReadColorControlCurrentX>(),                          //
        make_unique<ReportColorControlCurrentX>(),                        //
        make_unique<ReadColorControlCurrentY>(),                          //
        make_unique<ReportColorControlCurrentY>(),                        //
        make_unique<ReadColorControlDriftCompensation>(),                 //
        make_unique<ReportColorControlDriftCompensation>(),               //
        make_unique<ReadColorControlCompensationText>(),                  //
        make_unique<ReportColorControlCompensationText>(),                //
        make_unique<ReadColorControlColorTemperature>(),                  //
        make_unique<ReportColorControlColorTemperature>(),                //
        make_unique<ReadColorControlColorMode>(),                         //
        make_unique<ReportColorControlColorMode>(),                       //
        make_unique<ReadColorControlColorControlOptions>(),               //
        make_unique<WriteColorControlColorControlOptions>(),              //
        make_unique<ReportColorControlColorControlOptions>(),             //
        make_unique<ReadColorControlNumberOfPrimaries>(),                 //
        make_unique<ReportColorControlNumberOfPrimaries>(),               //
        make_unique<ReadColorControlPrimary1X>(),                         //
        make_unique<ReportColorControlPrimary1X>(),                       //
        make_unique<ReadColorControlPrimary1Y>(),                         //
        make_unique<ReportColorControlPrimary1Y>(),                       //
        make_unique<ReadColorControlPrimary1Intensity>(),                 //
        make_unique<ReportColorControlPrimary1Intensity>(),               //
        make_unique<ReadColorControlPrimary2X>(),                         //
        make_unique<ReportColorControlPrimary2X>(),                       //
        make_unique<ReadColorControlPrimary2Y>(),                         //
        make_unique<ReportColorControlPrimary2Y>(),                       //
        make_unique<ReadColorControlPrimary2Intensity>(),                 //
        make_unique<ReportColorControlPrimary2Intensity>(),               //
        make_unique<ReadColorControlPrimary3X>(),                         //
        make_unique<ReportColorControlPrimary3X>(),                       //
        make_unique<ReadColorControlPrimary3Y>(),                         //
        make_unique<ReportColorControlPrimary3Y>(),                       //
        make_unique<ReadColorControlPrimary3Intensity>(),                 //
        make_unique<ReportColorControlPrimary3Intensity>(),               //
        make_unique<ReadColorControlPrimary4X>(),                         //
        make_unique<ReportColorControlPrimary4X>(),                       //
        make_unique<ReadColorControlPrimary4Y>(),                         //
        make_unique<ReportColorControlPrimary4Y>(),                       //
        make_unique<ReadColorControlPrimary4Intensity>(),                 //
        make_unique<ReportColorControlPrimary4Intensity>(),               //
        make_unique<ReadColorControlPrimary5X>(),                         //
        make_unique<ReportColorControlPrimary5X>(),                       //
        make_unique<ReadColorControlPrimary5Y>(),                         //
        make_unique<ReportColorControlPrimary5Y>(),                       //
        make_unique<ReadColorControlPrimary5Intensity>(),                 //
        make_unique<ReportColorControlPrimary5Intensity>(),               //
        make_unique<ReadColorControlPrimary6X>(),                         //
        make_unique<ReportColorControlPrimary6X>(),                       //
        make_unique<ReadColorControlPrimary6Y>(),                         //
        make_unique<ReportColorControlPrimary6Y>(),                       //
        make_unique<ReadColorControlPrimary6Intensity>(),                 //
        make_unique<ReportColorControlPrimary6Intensity>(),               //
        make_unique<ReadColorControlWhitePointX>(),                       //
        make_unique<WriteColorControlWhitePointX>(),                      //
        make_unique<ReportColorControlWhitePointX>(),                     //
        make_unique<ReadColorControlWhitePointY>(),                       //
        make_unique<WriteColorControlWhitePointY>(),                      //
        make_unique<ReportColorControlWhitePointY>(),                     //
        make_unique<ReadColorControlColorPointRX>(),                      //
        make_unique<WriteColorControlColorPointRX>(),                     //
        make_unique<ReportColorControlColorPointRX>(),                    //
        make_unique<ReadColorControlColorPointRY>(),                      //
        make_unique<WriteColorControlColorPointRY>(),                     //
        make_unique<ReportColorControlColorPointRY>(),                    //
        make_unique<ReadColorControlColorPointRIntensity>(),              //
        make_unique<WriteColorControlColorPointRIntensity>(),             //
        make_unique<ReportColorControlColorPointRIntensity>(),            //
        make_unique<ReadColorControlColorPointGX>(),                      //
        make_unique<WriteColorControlColorPointGX>(),                     //
        make_unique<ReportColorControlColorPointGX>(),                    //
        make_unique<ReadColorControlColorPointGY>(),                      //
        make_unique<WriteColorControlColorPointGY>(),                     //
        make_unique<ReportColorControlColorPointGY>(),                    //
        make_unique<ReadColorControlColorPointGIntensity>(),              //
        make_unique<WriteColorControlColorPointGIntensity>(),             //
        make_unique<ReportColorControlColorPointGIntensity>(),            //
        make_unique<ReadColorControlColorPointBX>(),                      //
        make_unique<WriteColorControlColorPointBX>(),                     //
        make_unique<ReportColorControlColorPointBX>(),                    //
        make_unique<ReadColorControlColorPointBY>(),                      //
        make_unique<WriteColorControlColorPointBY>(),                     //
        make_unique<ReportColorControlColorPointBY>(),                    //
        make_unique<ReadColorControlColorPointBIntensity>(),              //
        make_unique<WriteColorControlColorPointBIntensity>(),             //
        make_unique<ReportColorControlColorPointBIntensity>(),            //
        make_unique<ReadColorControlEnhancedCurrentHue>(),                //
        make_unique<ReportColorControlEnhancedCurrentHue>(),              //
        make_unique<ReadColorControlEnhancedColorMode>(),                 //
        make_unique<ReportColorControlEnhancedColorMode>(),               //
        make_unique<ReadColorControlColorLoopActive>(),                   //
        make_unique<ReportColorControlColorLoopActive>(),                 //
        make_unique<ReadColorControlColorLoopDirection>(),                //
        make_unique<ReportColorControlColorLoopDirection>(),              //
        make_unique<ReadColorControlColorLoopTime>(),                     //
        make_unique<ReportColorControlColorLoopTime>(),                   //
        make_unique<ReadColorControlColorLoopStartEnhancedHue>(),         //
        make_unique<ReportColorControlColorLoopStartEnhancedHue>(),       //
        make_unique<ReadColorControlColorLoopStoredEnhancedHue>(),        //
        make_unique<ReportColorControlColorLoopStoredEnhancedHue>(),      //
        make_unique<ReadColorControlColorCapabilities>(),                 //
        make_unique<ReportColorControlColorCapabilities>(),               //
        make_unique<ReadColorControlColorTempPhysicalMin>(),              //
        make_unique<ReportColorControlColorTempPhysicalMin>(),            //
        make_unique<ReadColorControlColorTempPhysicalMax>(),              //
        make_unique<ReportColorControlColorTempPhysicalMax>(),            //
        make_unique<ReadColorControlCoupleColorTempToLevelMinMireds>(),   //
        make_unique<ReportColorControlCoupleColorTempToLevelMinMireds>(), //
        make_unique<ReadColorControlStartUpColorTemperatureMireds>(),     //
        make_unique<WriteColorControlStartUpColorTemperatureMireds>(),    //
        make_unique<ReportColorControlStartUpColorTemperatureMireds>(),   //
        make_unique<ReadColorControlAttributeList>(),                     //
        make_unique<ReadColorControlClusterRevision>(),                   //
        make_unique<ReportColorControlClusterRevision>(),                 //
        make_unique<ReadEventColorControlWildcard>(),                     //
        make_unique<ReportEventColorControlWildcard>(),                   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterContentLauncher(Commands & commands)
{
    const char * clusterName = "ContentLauncher";

    commands_list clusterCommands = {
        make_unique<ContentLauncherLaunchContentRequest>(),              //
        make_unique<ContentLauncherLaunchURLRequest>(),                  //
        make_unique<ReadContentLauncherWildcard>(),                      //
        make_unique<ReportContentLauncherWildcard>(),                    //
        make_unique<ReadContentLauncherAcceptHeaderList>(),              //
        make_unique<ReadContentLauncherSupportedStreamingProtocols>(),   //
        make_unique<WriteContentLauncherSupportedStreamingProtocols>(),  //
        make_unique<ReportContentLauncherSupportedStreamingProtocols>(), //
        make_unique<ReadContentLauncherAttributeList>(),                 //
        make_unique<ReadContentLauncherClusterRevision>(),               //
        make_unique<ReportContentLauncherClusterRevision>(),             //
        make_unique<ReadEventContentLauncherWildcard>(),                 //
        make_unique<ReportEventContentLauncherWildcard>(),               //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDescriptor(Commands & commands)
{
    const char * clusterName = "Descriptor";

    commands_list clusterCommands = {
        make_unique<ReadDescriptorWildcard>(),          //
        make_unique<ReportDescriptorWildcard>(),        //
        make_unique<ReadDescriptorDeviceList>(),        //
        make_unique<ReadDescriptorServerList>(),        //
        make_unique<ReadDescriptorClientList>(),        //
        make_unique<ReadDescriptorPartsList>(),         //
        make_unique<ReadDescriptorAttributeList>(),     //
        make_unique<ReadDescriptorClusterRevision>(),   //
        make_unique<ReportDescriptorClusterRevision>(), //
        make_unique<ReadEventDescriptorWildcard>(),     //
        make_unique<ReportEventDescriptorWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDiagnosticLogs(Commands & commands)
{
    const char * clusterName = "DiagnosticLogs";

    commands_list clusterCommands = {
        make_unique<DiagnosticLogsRetrieveLogsRequest>(), //
        make_unique<ReadDiagnosticLogsWildcard>(),        //
        make_unique<ReportDiagnosticLogsWildcard>(),      //
        make_unique<ReadDiagnosticLogsAttributeList>(),   //
        make_unique<ReadEventDiagnosticLogsWildcard>(),   //
        make_unique<ReportEventDiagnosticLogsWildcard>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDoorLock(Commands & commands)
{
    const char * clusterName = "DoorLock";

    commands_list clusterCommands = {
        make_unique<DoorLockClearCredential>(),                 //
        make_unique<DoorLockClearUser>(),                       //
        make_unique<DoorLockGetCredentialStatus>(),             //
        make_unique<DoorLockGetUser>(),                         //
        make_unique<DoorLockLockDoor>(),                        //
        make_unique<DoorLockSetCredential>(),                   //
        make_unique<DoorLockSetUser>(),                         //
        make_unique<DoorLockUnlockDoor>(),                      //
        make_unique<ReadDoorLockWildcard>(),                    //
        make_unique<ReportDoorLockWildcard>(),                  //
        make_unique<ReadDoorLockLockState>(),                   //
        make_unique<ReportDoorLockLockState>(),                 //
        make_unique<ReadDoorLockLockType>(),                    //
        make_unique<ReportDoorLockLockType>(),                  //
        make_unique<ReadDoorLockActuatorEnabled>(),             //
        make_unique<ReportDoorLockActuatorEnabled>(),           //
        make_unique<ReadDoorLockDoorState>(),                   //
        make_unique<ReportDoorLockDoorState>(),                 //
        make_unique<ReadDoorLockNumberOfTotalUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfPINUsersSupported>(),   //
        make_unique<ReadDoorLockMaxPINCodeLength>(),            //
        make_unique<ReadDoorLockMinPINCodeLength>(),            //
        make_unique<ReadDoorLockLanguage>(),                    //
        make_unique<WriteDoorLockLanguage>(),                   //
        make_unique<ReportDoorLockLanguage>(),                  //
        make_unique<ReadDoorLockAutoRelockTime>(),              //
        make_unique<WriteDoorLockAutoRelockTime>(),             //
        make_unique<ReportDoorLockAutoRelockTime>(),            //
        make_unique<ReadDoorLockSoundVolume>(),                 //
        make_unique<WriteDoorLockSoundVolume>(),                //
        make_unique<ReportDoorLockSoundVolume>(),               //
        make_unique<ReadDoorLockOperatingMode>(),               //
        make_unique<WriteDoorLockOperatingMode>(),              //
        make_unique<ReportDoorLockOperatingMode>(),             //
        make_unique<ReadDoorLockSupportedOperatingModes>(),     //
        make_unique<ReadDoorLockEnableOneTouchLocking>(),       //
        make_unique<WriteDoorLockEnableOneTouchLocking>(),      //
        make_unique<ReportDoorLockEnableOneTouchLocking>(),     //
        make_unique<ReadDoorLockEnablePrivacyModeButton>(),     //
        make_unique<WriteDoorLockEnablePrivacyModeButton>(),    //
        make_unique<ReportDoorLockEnablePrivacyModeButton>(),   //
        make_unique<ReadDoorLockWrongCodeEntryLimit>(),         //
        make_unique<WriteDoorLockWrongCodeEntryLimit>(),        //
        make_unique<ReportDoorLockWrongCodeEntryLimit>(),       //
        make_unique<ReadDoorLockAttributeList>(),               //
        make_unique<ReadDoorLockClusterRevision>(),             //
        make_unique<ReportDoorLockClusterRevision>(),           //
        make_unique<ReadEventDoorLockWildcard>(),               //
        make_unique<ReportEventDoorLockWildcard>(),             //
        make_unique<ReadDoorLockDoorLockAlarm>(),               //
        make_unique<ReportDoorLockDoorLockAlarm>(),             //
        make_unique<ReadDoorLockDoorStateChange>(),             //
        make_unique<ReportDoorLockDoorStateChange>(),           //
        make_unique<ReadDoorLockLockOperation>(),               //
        make_unique<ReportDoorLockLockOperation>(),             //
        make_unique<ReadDoorLockLockOperationError>(),          //
        make_unique<ReportDoorLockLockOperationError>(),        //
        make_unique<ReadDoorLockLockUserChange>(),              //
        make_unique<ReportDoorLockLockUserChange>(),            //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterElectricalMeasurement(Commands & commands)
{
    const char * clusterName = "ElectricalMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadElectricalMeasurementWildcard>(),           //
        make_unique<ReportElectricalMeasurementWildcard>(),         //
        make_unique<ReadElectricalMeasurementMeasurementType>(),    //
        make_unique<ReportElectricalMeasurementMeasurementType>(),  //
        make_unique<ReadElectricalMeasurementTotalActivePower>(),   //
        make_unique<ReportElectricalMeasurementTotalActivePower>(), //
        make_unique<ReadElectricalMeasurementRmsVoltage>(),         //
        make_unique<ReportElectricalMeasurementRmsVoltage>(),       //
        make_unique<ReadElectricalMeasurementRmsVoltageMin>(),      //
        make_unique<ReportElectricalMeasurementRmsVoltageMin>(),    //
        make_unique<ReadElectricalMeasurementRmsVoltageMax>(),      //
        make_unique<ReportElectricalMeasurementRmsVoltageMax>(),    //
        make_unique<ReadElectricalMeasurementRmsCurrent>(),         //
        make_unique<ReportElectricalMeasurementRmsCurrent>(),       //
        make_unique<ReadElectricalMeasurementRmsCurrentMin>(),      //
        make_unique<ReportElectricalMeasurementRmsCurrentMin>(),    //
        make_unique<ReadElectricalMeasurementRmsCurrentMax>(),      //
        make_unique<ReportElectricalMeasurementRmsCurrentMax>(),    //
        make_unique<ReadElectricalMeasurementActivePower>(),        //
        make_unique<ReportElectricalMeasurementActivePower>(),      //
        make_unique<ReadElectricalMeasurementActivePowerMin>(),     //
        make_unique<ReportElectricalMeasurementActivePowerMin>(),   //
        make_unique<ReadElectricalMeasurementActivePowerMax>(),     //
        make_unique<ReportElectricalMeasurementActivePowerMax>(),   //
        make_unique<ReadElectricalMeasurementAttributeList>(),      //
        make_unique<ReadElectricalMeasurementClusterRevision>(),    //
        make_unique<ReportElectricalMeasurementClusterRevision>(),  //
        make_unique<ReadEventElectricalMeasurementWildcard>(),      //
        make_unique<ReportEventElectricalMeasurementWildcard>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterEthernetNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "EthernetNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<EthernetNetworkDiagnosticsResetCounts>(),           //
        make_unique<ReadEthernetNetworkDiagnosticsWildcard>(),          //
        make_unique<ReportEthernetNetworkDiagnosticsWildcard>(),        //
        make_unique<ReadEthernetNetworkDiagnosticsPHYRate>(),           //
        make_unique<ReportEthernetNetworkDiagnosticsPHYRate>(),         //
        make_unique<ReadEthernetNetworkDiagnosticsFullDuplex>(),        //
        make_unique<ReportEthernetNetworkDiagnosticsFullDuplex>(),      //
        make_unique<ReadEthernetNetworkDiagnosticsPacketRxCount>(),     //
        make_unique<ReportEthernetNetworkDiagnosticsPacketRxCount>(),   //
        make_unique<ReadEthernetNetworkDiagnosticsPacketTxCount>(),     //
        make_unique<ReportEthernetNetworkDiagnosticsPacketTxCount>(),   //
        make_unique<ReadEthernetNetworkDiagnosticsTxErrCount>(),        //
        make_unique<ReportEthernetNetworkDiagnosticsTxErrCount>(),      //
        make_unique<ReadEthernetNetworkDiagnosticsCollisionCount>(),    //
        make_unique<ReportEthernetNetworkDiagnosticsCollisionCount>(),  //
        make_unique<ReadEthernetNetworkDiagnosticsOverrunCount>(),      //
        make_unique<ReportEthernetNetworkDiagnosticsOverrunCount>(),    //
        make_unique<ReadEthernetNetworkDiagnosticsCarrierDetect>(),     //
        make_unique<ReportEthernetNetworkDiagnosticsCarrierDetect>(),   //
        make_unique<ReadEthernetNetworkDiagnosticsTimeSinceReset>(),    //
        make_unique<ReportEthernetNetworkDiagnosticsTimeSinceReset>(),  //
        make_unique<ReadEthernetNetworkDiagnosticsAttributeList>(),     //
        make_unique<ReadEthernetNetworkDiagnosticsFeatureMap>(),        //
        make_unique<ReadEthernetNetworkDiagnosticsClusterRevision>(),   //
        make_unique<ReportEthernetNetworkDiagnosticsClusterRevision>(), //
        make_unique<ReadEventEthernetNetworkDiagnosticsWildcard>(),     //
        make_unique<ReportEventEthernetNetworkDiagnosticsWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFixedLabel(Commands & commands)
{
    const char * clusterName = "FixedLabel";

    commands_list clusterCommands = {
        make_unique<ReadFixedLabelWildcard>(),          //
        make_unique<ReportFixedLabelWildcard>(),        //
        make_unique<ReadFixedLabelLabelList>(),         //
        make_unique<ReadFixedLabelAttributeList>(),     //
        make_unique<ReadFixedLabelClusterRevision>(),   //
        make_unique<ReportFixedLabelClusterRevision>(), //
        make_unique<ReadEventFixedLabelWildcard>(),     //
        make_unique<ReportEventFixedLabelWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFlowMeasurement(Commands & commands)
{
    const char * clusterName = "FlowMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadFlowMeasurementWildcard>(),           //
        make_unique<ReportFlowMeasurementWildcard>(),         //
        make_unique<ReadFlowMeasurementMeasuredValue>(),      //
        make_unique<ReportFlowMeasurementMeasuredValue>(),    //
        make_unique<ReadFlowMeasurementMinMeasuredValue>(),   //
        make_unique<ReportFlowMeasurementMinMeasuredValue>(), //
        make_unique<ReadFlowMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportFlowMeasurementMaxMeasuredValue>(), //
        make_unique<ReadFlowMeasurementTolerance>(),          //
        make_unique<ReportFlowMeasurementTolerance>(),        //
        make_unique<ReadFlowMeasurementAttributeList>(),      //
        make_unique<ReadFlowMeasurementClusterRevision>(),    //
        make_unique<ReportFlowMeasurementClusterRevision>(),  //
        make_unique<ReadEventFlowMeasurementWildcard>(),      //
        make_unique<ReportEventFlowMeasurementWildcard>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralCommissioning(Commands & commands)
{
    const char * clusterName = "GeneralCommissioning";

    commands_list clusterCommands = {
        make_unique<GeneralCommissioningArmFailSafe>(),                    //
        make_unique<GeneralCommissioningCommissioningComplete>(),          //
        make_unique<GeneralCommissioningSetRegulatoryConfig>(),            //
        make_unique<ReadGeneralCommissioningWildcard>(),                   //
        make_unique<ReportGeneralCommissioningWildcard>(),                 //
        make_unique<ReadGeneralCommissioningBreadcrumb>(),                 //
        make_unique<WriteGeneralCommissioningBreadcrumb>(),                //
        make_unique<ReportGeneralCommissioningBreadcrumb>(),               //
        make_unique<ReadGeneralCommissioningBasicCommissioningInfoList>(), //
        make_unique<ReadGeneralCommissioningRegulatoryConfig>(),           //
        make_unique<ReadGeneralCommissioningLocationCapability>(),         //
        make_unique<ReadGeneralCommissioningAttributeList>(),              //
        make_unique<ReadGeneralCommissioningClusterRevision>(),            //
        make_unique<ReportGeneralCommissioningClusterRevision>(),          //
        make_unique<ReadEventGeneralCommissioningWildcard>(),              //
        make_unique<ReportEventGeneralCommissioningWildcard>(),            //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralDiagnostics(Commands & commands)
{
    const char * clusterName = "GeneralDiagnostics";

    commands_list clusterCommands = {
        make_unique<ReadGeneralDiagnosticsWildcard>(),                //
        make_unique<ReportGeneralDiagnosticsWildcard>(),              //
        make_unique<ReadGeneralDiagnosticsNetworkInterfaces>(),       //
        make_unique<ReadGeneralDiagnosticsRebootCount>(),             //
        make_unique<ReportGeneralDiagnosticsRebootCount>(),           //
        make_unique<ReadGeneralDiagnosticsUpTime>(),                  //
        make_unique<ReportGeneralDiagnosticsUpTime>(),                //
        make_unique<ReadGeneralDiagnosticsTotalOperationalHours>(),   //
        make_unique<ReportGeneralDiagnosticsTotalOperationalHours>(), //
        make_unique<ReadGeneralDiagnosticsBootReasons>(),             //
        make_unique<ReportGeneralDiagnosticsBootReasons>(),           //
        make_unique<ReadGeneralDiagnosticsActiveHardwareFaults>(),    //
        make_unique<ReadGeneralDiagnosticsActiveRadioFaults>(),       //
        make_unique<ReadGeneralDiagnosticsActiveNetworkFaults>(),     //
        make_unique<ReadGeneralDiagnosticsAttributeList>(),           //
        make_unique<ReadGeneralDiagnosticsClusterRevision>(),         //
        make_unique<ReportGeneralDiagnosticsClusterRevision>(),       //
        make_unique<ReadEventGeneralDiagnosticsWildcard>(),           //
        make_unique<ReportEventGeneralDiagnosticsWildcard>(),         //
        make_unique<ReadGeneralDiagnosticsHardwareFaultChange>(),     //
        make_unique<ReportGeneralDiagnosticsHardwareFaultChange>(),   //
        make_unique<ReadGeneralDiagnosticsRadioFaultChange>(),        //
        make_unique<ReportGeneralDiagnosticsRadioFaultChange>(),      //
        make_unique<ReadGeneralDiagnosticsNetworkFaultChange>(),      //
        make_unique<ReportGeneralDiagnosticsNetworkFaultChange>(),    //
        make_unique<ReadGeneralDiagnosticsBootReason>(),              //
        make_unique<ReportGeneralDiagnosticsBootReason>(),            //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroupKeyManagement(Commands & commands)
{
    const char * clusterName = "GroupKeyManagement";

    commands_list clusterCommands = {
        make_unique<GroupKeyManagementKeySetRead>(),                //
        make_unique<GroupKeyManagementKeySetReadAllIndices>(),      //
        make_unique<GroupKeyManagementKeySetRemove>(),              //
        make_unique<GroupKeyManagementKeySetWrite>(),               //
        make_unique<ReadGroupKeyManagementWildcard>(),              //
        make_unique<ReportGroupKeyManagementWildcard>(),            //
        make_unique<ReadGroupKeyManagementGroupKeyMap>(),           //
        make_unique<ReadGroupKeyManagementGroupTable>(),            //
        make_unique<ReadGroupKeyManagementMaxGroupsPerFabric>(),    //
        make_unique<ReadGroupKeyManagementMaxGroupKeysPerFabric>(), //
        make_unique<ReadGroupKeyManagementAttributeList>(),         //
        make_unique<ReadGroupKeyManagementClusterRevision>(),       //
        make_unique<ReportGroupKeyManagementClusterRevision>(),     //
        make_unique<ReadEventGroupKeyManagementWildcard>(),         //
        make_unique<ReportEventGroupKeyManagementWildcard>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroups(Commands & commands)
{
    const char * clusterName = "Groups";

    commands_list clusterCommands = {
        make_unique<GroupsAddGroup>(),              //
        make_unique<GroupsAddGroupIfIdentifying>(), //
        make_unique<GroupsGetGroupMembership>(),    //
        make_unique<GroupsRemoveAllGroups>(),       //
        make_unique<GroupsRemoveGroup>(),           //
        make_unique<GroupsViewGroup>(),             //
        make_unique<ReadGroupsWildcard>(),          //
        make_unique<ReportGroupsWildcard>(),        //
        make_unique<ReadGroupsNameSupport>(),       //
        make_unique<ReportGroupsNameSupport>(),     //
        make_unique<ReadGroupsAttributeList>(),     //
        make_unique<ReadGroupsClusterRevision>(),   //
        make_unique<ReportGroupsClusterRevision>(), //
        make_unique<ReadEventGroupsWildcard>(),     //
        make_unique<ReportEventGroupsWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIdentify(Commands & commands)
{
    const char * clusterName = "Identify";

    commands_list clusterCommands = {
        make_unique<IdentifyIdentify>(),              //
        make_unique<IdentifyIdentifyQuery>(),         //
        make_unique<IdentifyTriggerEffect>(),         //
        make_unique<ReadIdentifyWildcard>(),          //
        make_unique<ReportIdentifyWildcard>(),        //
        make_unique<ReadIdentifyIdentifyTime>(),      //
        make_unique<WriteIdentifyIdentifyTime>(),     //
        make_unique<ReportIdentifyIdentifyTime>(),    //
        make_unique<ReadIdentifyIdentifyType>(),      //
        make_unique<ReportIdentifyIdentifyType>(),    //
        make_unique<ReadIdentifyAttributeList>(),     //
        make_unique<ReadIdentifyClusterRevision>(),   //
        make_unique<ReportIdentifyClusterRevision>(), //
        make_unique<ReadEventIdentifyWildcard>(),     //
        make_unique<ReportEventIdentifyWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIlluminanceMeasurement(Commands & commands)
{
    const char * clusterName = "IlluminanceMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadIlluminanceMeasurementWildcard>(),           //
        make_unique<ReportIlluminanceMeasurementWildcard>(),         //
        make_unique<ReadIlluminanceMeasurementMeasuredValue>(),      //
        make_unique<ReportIlluminanceMeasurementMeasuredValue>(),    //
        make_unique<ReadIlluminanceMeasurementMinMeasuredValue>(),   //
        make_unique<ReportIlluminanceMeasurementMinMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportIlluminanceMeasurementMaxMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementTolerance>(),          //
        make_unique<ReportIlluminanceMeasurementTolerance>(),        //
        make_unique<ReadIlluminanceMeasurementLightSensorType>(),    //
        make_unique<ReportIlluminanceMeasurementLightSensorType>(),  //
        make_unique<ReadIlluminanceMeasurementAttributeList>(),      //
        make_unique<ReadIlluminanceMeasurementClusterRevision>(),    //
        make_unique<ReportIlluminanceMeasurementClusterRevision>(),  //
        make_unique<ReadEventIlluminanceMeasurementWildcard>(),      //
        make_unique<ReportEventIlluminanceMeasurementWildcard>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterKeypadInput(Commands & commands)
{
    const char * clusterName = "KeypadInput";

    commands_list clusterCommands = {
        make_unique<KeypadInputSendKeyRequest>(),        //
        make_unique<ReadKeypadInputWildcard>(),          //
        make_unique<ReportKeypadInputWildcard>(),        //
        make_unique<ReadKeypadInputAttributeList>(),     //
        make_unique<ReadKeypadInputClusterRevision>(),   //
        make_unique<ReportKeypadInputClusterRevision>(), //
        make_unique<ReadEventKeypadInputWildcard>(),     //
        make_unique<ReportEventKeypadInputWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLevelControl(Commands & commands)
{
    const char * clusterName = "LevelControl";

    commands_list clusterCommands = {
        make_unique<LevelControlMove>(),                      //
        make_unique<LevelControlMoveToLevel>(),               //
        make_unique<LevelControlMoveToLevelWithOnOff>(),      //
        make_unique<LevelControlMoveWithOnOff>(),             //
        make_unique<LevelControlStep>(),                      //
        make_unique<LevelControlStepWithOnOff>(),             //
        make_unique<LevelControlStop>(),                      //
        make_unique<LevelControlStopWithOnOff>(),             //
        make_unique<ReadLevelControlWildcard>(),              //
        make_unique<ReportLevelControlWildcard>(),            //
        make_unique<ReadLevelControlCurrentLevel>(),          //
        make_unique<ReportLevelControlCurrentLevel>(),        //
        make_unique<ReadLevelControlRemainingTime>(),         //
        make_unique<ReportLevelControlRemainingTime>(),       //
        make_unique<ReadLevelControlMinLevel>(),              //
        make_unique<ReportLevelControlMinLevel>(),            //
        make_unique<ReadLevelControlMaxLevel>(),              //
        make_unique<ReportLevelControlMaxLevel>(),            //
        make_unique<ReadLevelControlCurrentFrequency>(),      //
        make_unique<ReportLevelControlCurrentFrequency>(),    //
        make_unique<ReadLevelControlMinFrequency>(),          //
        make_unique<ReportLevelControlMinFrequency>(),        //
        make_unique<ReadLevelControlMaxFrequency>(),          //
        make_unique<ReportLevelControlMaxFrequency>(),        //
        make_unique<ReadLevelControlOptions>(),               //
        make_unique<WriteLevelControlOptions>(),              //
        make_unique<ReportLevelControlOptions>(),             //
        make_unique<ReadLevelControlOnOffTransitionTime>(),   //
        make_unique<WriteLevelControlOnOffTransitionTime>(),  //
        make_unique<ReportLevelControlOnOffTransitionTime>(), //
        make_unique<ReadLevelControlOnLevel>(),               //
        make_unique<WriteLevelControlOnLevel>(),              //
        make_unique<ReportLevelControlOnLevel>(),             //
        make_unique<ReadLevelControlOnTransitionTime>(),      //
        make_unique<WriteLevelControlOnTransitionTime>(),     //
        make_unique<ReportLevelControlOnTransitionTime>(),    //
        make_unique<ReadLevelControlOffTransitionTime>(),     //
        make_unique<WriteLevelControlOffTransitionTime>(),    //
        make_unique<ReportLevelControlOffTransitionTime>(),   //
        make_unique<ReadLevelControlDefaultMoveRate>(),       //
        make_unique<WriteLevelControlDefaultMoveRate>(),      //
        make_unique<ReportLevelControlDefaultMoveRate>(),     //
        make_unique<ReadLevelControlStartUpCurrentLevel>(),   //
        make_unique<WriteLevelControlStartUpCurrentLevel>(),  //
        make_unique<ReportLevelControlStartUpCurrentLevel>(), //
        make_unique<ReadLevelControlAttributeList>(),         //
        make_unique<ReadLevelControlFeatureMap>(),            //
        make_unique<ReadLevelControlClusterRevision>(),       //
        make_unique<ReportLevelControlClusterRevision>(),     //
        make_unique<ReadEventLevelControlWildcard>(),         //
        make_unique<ReportEventLevelControlWildcard>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLocalizationConfiguration(Commands & commands)
{
    const char * clusterName = "LocalizationConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadLocalizationConfigurationWildcard>(),         //
        make_unique<ReportLocalizationConfigurationWildcard>(),       //
        make_unique<ReadLocalizationConfigurationActiveLocale>(),     //
        make_unique<WriteLocalizationConfigurationActiveLocale>(),    //
        make_unique<ReadLocalizationConfigurationSupportedLocales>(), //
        make_unique<ReadEventLocalizationConfigurationWildcard>(),    //
        make_unique<ReportEventLocalizationConfigurationWildcard>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLowPower(Commands & commands)
{
    const char * clusterName = "LowPower";

    commands_list clusterCommands = {
        make_unique<LowPowerSleep>(),                 //
        make_unique<ReadLowPowerWildcard>(),          //
        make_unique<ReportLowPowerWildcard>(),        //
        make_unique<ReadLowPowerAttributeList>(),     //
        make_unique<ReadLowPowerClusterRevision>(),   //
        make_unique<ReportLowPowerClusterRevision>(), //
        make_unique<ReadEventLowPowerWildcard>(),     //
        make_unique<ReportEventLowPowerWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaInput(Commands & commands)
{
    const char * clusterName = "MediaInput";

    commands_list clusterCommands = {
        make_unique<MediaInputHideInputStatusRequest>(),  //
        make_unique<MediaInputRenameInputRequest>(),      //
        make_unique<MediaInputSelectInputRequest>(),      //
        make_unique<MediaInputShowInputStatusRequest>(),  //
        make_unique<ReadMediaInputWildcard>(),            //
        make_unique<ReportMediaInputWildcard>(),          //
        make_unique<ReadMediaInputMediaInputList>(),      //
        make_unique<ReadMediaInputCurrentMediaInput>(),   //
        make_unique<ReportMediaInputCurrentMediaInput>(), //
        make_unique<ReadMediaInputAttributeList>(),       //
        make_unique<ReadMediaInputClusterRevision>(),     //
        make_unique<ReportMediaInputClusterRevision>(),   //
        make_unique<ReadEventMediaInputWildcard>(),       //
        make_unique<ReportEventMediaInputWildcard>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaPlayback(Commands & commands)
{
    const char * clusterName = "MediaPlayback";

    commands_list clusterCommands = {
        make_unique<MediaPlaybackFastForwardRequest>(),    //
        make_unique<MediaPlaybackNextRequest>(),           //
        make_unique<MediaPlaybackPauseRequest>(),          //
        make_unique<MediaPlaybackPlayRequest>(),           //
        make_unique<MediaPlaybackPreviousRequest>(),       //
        make_unique<MediaPlaybackRewindRequest>(),         //
        make_unique<MediaPlaybackSeekRequest>(),           //
        make_unique<MediaPlaybackSkipBackwardRequest>(),   //
        make_unique<MediaPlaybackSkipForwardRequest>(),    //
        make_unique<MediaPlaybackStartOverRequest>(),      //
        make_unique<MediaPlaybackStopRequest>(),           //
        make_unique<ReadMediaPlaybackWildcard>(),          //
        make_unique<ReportMediaPlaybackWildcard>(),        //
        make_unique<ReadMediaPlaybackPlaybackState>(),     //
        make_unique<ReportMediaPlaybackPlaybackState>(),   //
        make_unique<ReadMediaPlaybackStartTime>(),         //
        make_unique<ReportMediaPlaybackStartTime>(),       //
        make_unique<ReadMediaPlaybackDuration>(),          //
        make_unique<ReportMediaPlaybackDuration>(),        //
        make_unique<ReadMediaPlaybackPlaybackSpeed>(),     //
        make_unique<ReadMediaPlaybackSeekRangeEnd>(),      //
        make_unique<ReportMediaPlaybackSeekRangeEnd>(),    //
        make_unique<ReadMediaPlaybackSeekRangeStart>(),    //
        make_unique<ReportMediaPlaybackSeekRangeStart>(),  //
        make_unique<ReadMediaPlaybackAttributeList>(),     //
        make_unique<ReadMediaPlaybackClusterRevision>(),   //
        make_unique<ReportMediaPlaybackClusterRevision>(), //
        make_unique<ReadEventMediaPlaybackWildcard>(),     //
        make_unique<ReportEventMediaPlaybackWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterModeSelect(Commands & commands)
{
    const char * clusterName = "ModeSelect";

    commands_list clusterCommands = {
        make_unique<ModeSelectChangeToMode>(),          //
        make_unique<ReadModeSelectWildcard>(),          //
        make_unique<ReportModeSelectWildcard>(),        //
        make_unique<ReadModeSelectCurrentMode>(),       //
        make_unique<ReportModeSelectCurrentMode>(),     //
        make_unique<ReadModeSelectSupportedModes>(),    //
        make_unique<ReadModeSelectOnMode>(),            //
        make_unique<WriteModeSelectOnMode>(),           //
        make_unique<ReportModeSelectOnMode>(),          //
        make_unique<ReadModeSelectStartUpMode>(),       //
        make_unique<ReportModeSelectStartUpMode>(),     //
        make_unique<ReadModeSelectDescription>(),       //
        make_unique<ReportModeSelectDescription>(),     //
        make_unique<ReadModeSelectAttributeList>(),     //
        make_unique<ReadModeSelectClusterRevision>(),   //
        make_unique<ReportModeSelectClusterRevision>(), //
        make_unique<ReadEventModeSelectWildcard>(),     //
        make_unique<ReportEventModeSelectWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterNetworkCommissioning(Commands & commands)
{
    const char * clusterName = "NetworkCommissioning";

    commands_list clusterCommands = {
        make_unique<NetworkCommissioningAddOrUpdateThreadNetwork>(),  //
        make_unique<NetworkCommissioningAddOrUpdateWiFiNetwork>(),    //
        make_unique<NetworkCommissioningConnectNetwork>(),            //
        make_unique<NetworkCommissioningRemoveNetwork>(),             //
        make_unique<NetworkCommissioningReorderNetwork>(),            //
        make_unique<NetworkCommissioningScanNetworks>(),              //
        make_unique<ReadNetworkCommissioningWildcard>(),              //
        make_unique<ReportNetworkCommissioningWildcard>(),            //
        make_unique<ReadNetworkCommissioningMaxNetworks>(),           //
        make_unique<ReadNetworkCommissioningNetworks>(),              //
        make_unique<ReadNetworkCommissioningScanMaxTimeSeconds>(),    //
        make_unique<ReadNetworkCommissioningConnectMaxTimeSeconds>(), //
        make_unique<ReadNetworkCommissioningInterfaceEnabled>(),      //
        make_unique<WriteNetworkCommissioningInterfaceEnabled>(),     //
        make_unique<ReadNetworkCommissioningLastNetworkingStatus>(),  //
        make_unique<ReadNetworkCommissioningLastNetworkID>(),         //
        make_unique<ReadNetworkCommissioningLastConnectErrorValue>(), //
        make_unique<ReadNetworkCommissioningFeatureMap>(),            //
        make_unique<ReportNetworkCommissioningFeatureMap>(),          //
        make_unique<ReadNetworkCommissioningClusterRevision>(),       //
        make_unique<ReportNetworkCommissioningClusterRevision>(),     //
        make_unique<ReadEventNetworkCommissioningWildcard>(),         //
        make_unique<ReportEventNetworkCommissioningWildcard>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateProvider(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateProvider";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateProviderApplyUpdateRequest>(),    //
        make_unique<OtaSoftwareUpdateProviderNotifyUpdateApplied>(),   //
        make_unique<OtaSoftwareUpdateProviderQueryImage>(),            //
        make_unique<ReadOtaSoftwareUpdateProviderWildcard>(),          //
        make_unique<ReportOtaSoftwareUpdateProviderWildcard>(),        //
        make_unique<ReadOtaSoftwareUpdateProviderAttributeList>(),     //
        make_unique<ReadOtaSoftwareUpdateProviderClusterRevision>(),   //
        make_unique<ReportOtaSoftwareUpdateProviderClusterRevision>(), //
        make_unique<ReadEventOtaSoftwareUpdateProviderWildcard>(),     //
        make_unique<ReportEventOtaSoftwareUpdateProviderWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateRequestor(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateRequestor";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateRequestorAnnounceOtaProvider>(),       //
        make_unique<ReadOtaSoftwareUpdateRequestorWildcard>(),              //
        make_unique<ReportOtaSoftwareUpdateRequestorWildcard>(),            //
        make_unique<ReadOtaSoftwareUpdateRequestorDefaultOtaProviders>(),   //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdatePossible>(),        //
        make_unique<ReportOtaSoftwareUpdateRequestorUpdatePossible>(),      //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdateState>(),           //
        make_unique<ReportOtaSoftwareUpdateRequestorUpdateState>(),         //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdateStateProgress>(),   //
        make_unique<ReportOtaSoftwareUpdateRequestorUpdateStateProgress>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorAttributeList>(),         //
        make_unique<ReadOtaSoftwareUpdateRequestorClusterRevision>(),       //
        make_unique<ReportOtaSoftwareUpdateRequestorClusterRevision>(),     //
        make_unique<ReadEventOtaSoftwareUpdateRequestorWildcard>(),         //
        make_unique<ReportEventOtaSoftwareUpdateRequestorWildcard>(),       //
        make_unique<ReadOtaSoftwareUpdateRequestorStateTransition>(),       //
        make_unique<ReportOtaSoftwareUpdateRequestorStateTransition>(),     //
        make_unique<ReadOtaSoftwareUpdateRequestorVersionApplied>(),        //
        make_unique<ReportOtaSoftwareUpdateRequestorVersionApplied>(),      //
        make_unique<ReadOtaSoftwareUpdateRequestorDownloadError>(),         //
        make_unique<ReportOtaSoftwareUpdateRequestorDownloadError>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOccupancySensing(Commands & commands)
{
    const char * clusterName = "OccupancySensing";

    commands_list clusterCommands = {
        make_unique<ReadOccupancySensingWildcard>(),                    //
        make_unique<ReportOccupancySensingWildcard>(),                  //
        make_unique<ReadOccupancySensingOccupancy>(),                   //
        make_unique<ReportOccupancySensingOccupancy>(),                 //
        make_unique<ReadOccupancySensingOccupancySensorType>(),         //
        make_unique<ReportOccupancySensingOccupancySensorType>(),       //
        make_unique<ReadOccupancySensingOccupancySensorTypeBitmap>(),   //
        make_unique<ReportOccupancySensingOccupancySensorTypeBitmap>(), //
        make_unique<ReadOccupancySensingAttributeList>(),               //
        make_unique<ReadOccupancySensingClusterRevision>(),             //
        make_unique<ReportOccupancySensingClusterRevision>(),           //
        make_unique<ReadEventOccupancySensingWildcard>(),               //
        make_unique<ReportEventOccupancySensingWildcard>(),             //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOff(Commands & commands)
{
    const char * clusterName = "OnOff";

    commands_list clusterCommands = {
        make_unique<OnOffOff>(),                      //
        make_unique<OnOffOffWithEffect>(),            //
        make_unique<OnOffOn>(),                       //
        make_unique<OnOffOnWithRecallGlobalScene>(),  //
        make_unique<OnOffOnWithTimedOff>(),           //
        make_unique<OnOffToggle>(),                   //
        make_unique<ReadOnOffWildcard>(),             //
        make_unique<ReportOnOffWildcard>(),           //
        make_unique<ReadOnOffOnOff>(),                //
        make_unique<ReportOnOffOnOff>(),              //
        make_unique<ReadOnOffGlobalSceneControl>(),   //
        make_unique<ReportOnOffGlobalSceneControl>(), //
        make_unique<ReadOnOffOnTime>(),               //
        make_unique<WriteOnOffOnTime>(),              //
        make_unique<ReportOnOffOnTime>(),             //
        make_unique<ReadOnOffOffWaitTime>(),          //
        make_unique<WriteOnOffOffWaitTime>(),         //
        make_unique<ReportOnOffOffWaitTime>(),        //
        make_unique<ReadOnOffStartUpOnOff>(),         //
        make_unique<WriteOnOffStartUpOnOff>(),        //
        make_unique<ReportOnOffStartUpOnOff>(),       //
        make_unique<ReadOnOffAttributeList>(),        //
        make_unique<ReadOnOffFeatureMap>(),           //
        make_unique<ReportOnOffFeatureMap>(),         //
        make_unique<ReadOnOffClusterRevision>(),      //
        make_unique<ReportOnOffClusterRevision>(),    //
        make_unique<ReadEventOnOffWildcard>(),        //
        make_unique<ReportEventOnOffWildcard>(),      //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOffSwitchConfiguration(Commands & commands)
{
    const char * clusterName = "OnOffSwitchConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadOnOffSwitchConfigurationWildcard>(),          //
        make_unique<ReportOnOffSwitchConfigurationWildcard>(),        //
        make_unique<ReadOnOffSwitchConfigurationSwitchType>(),        //
        make_unique<ReportOnOffSwitchConfigurationSwitchType>(),      //
        make_unique<ReadOnOffSwitchConfigurationSwitchActions>(),     //
        make_unique<WriteOnOffSwitchConfigurationSwitchActions>(),    //
        make_unique<ReportOnOffSwitchConfigurationSwitchActions>(),   //
        make_unique<ReadOnOffSwitchConfigurationAttributeList>(),     //
        make_unique<ReadOnOffSwitchConfigurationClusterRevision>(),   //
        make_unique<ReportOnOffSwitchConfigurationClusterRevision>(), //
        make_unique<ReadEventOnOffSwitchConfigurationWildcard>(),     //
        make_unique<ReportEventOnOffSwitchConfigurationWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOperationalCredentials(Commands & commands)
{
    const char * clusterName = "OperationalCredentials";

    commands_list clusterCommands = {
        make_unique<OperationalCredentialsAddNOC>(),                       //
        make_unique<OperationalCredentialsAddTrustedRootCertificate>(),    //
        make_unique<OperationalCredentialsAttestationRequest>(),           //
        make_unique<OperationalCredentialsCertificateChainRequest>(),      //
        make_unique<OperationalCredentialsOpCSRRequest>(),                 //
        make_unique<OperationalCredentialsRemoveFabric>(),                 //
        make_unique<OperationalCredentialsRemoveTrustedRootCertificate>(), //
        make_unique<OperationalCredentialsUpdateFabricLabel>(),            //
        make_unique<OperationalCredentialsUpdateNOC>(),                    //
        make_unique<ReadOperationalCredentialsWildcard>(),                 //
        make_unique<ReportOperationalCredentialsWildcard>(),               //
        make_unique<ReadOperationalCredentialsFabricsList>(),              //
        make_unique<ReadOperationalCredentialsSupportedFabrics>(),         //
        make_unique<ReportOperationalCredentialsSupportedFabrics>(),       //
        make_unique<ReadOperationalCredentialsCommissionedFabrics>(),      //
        make_unique<ReportOperationalCredentialsCommissionedFabrics>(),    //
        make_unique<ReadOperationalCredentialsTrustedRootCertificates>(),  //
        make_unique<ReadOperationalCredentialsCurrentFabricIndex>(),       //
        make_unique<ReportOperationalCredentialsCurrentFabricIndex>(),     //
        make_unique<ReadOperationalCredentialsAttributeList>(),            //
        make_unique<ReadOperationalCredentialsClusterRevision>(),          //
        make_unique<ReportOperationalCredentialsClusterRevision>(),        //
        make_unique<ReadEventOperationalCredentialsWildcard>(),            //
        make_unique<ReportEventOperationalCredentialsWildcard>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSource(Commands & commands)
{
    const char * clusterName = "PowerSource";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceWildcard>(),                  //
        make_unique<ReportPowerSourceWildcard>(),                //
        make_unique<ReadPowerSourceStatus>(),                    //
        make_unique<ReportPowerSourceStatus>(),                  //
        make_unique<ReadPowerSourceOrder>(),                     //
        make_unique<ReportPowerSourceOrder>(),                   //
        make_unique<ReadPowerSourceDescription>(),               //
        make_unique<ReportPowerSourceDescription>(),             //
        make_unique<ReadPowerSourceBatteryVoltage>(),            //
        make_unique<ReportPowerSourceBatteryVoltage>(),          //
        make_unique<ReadPowerSourceBatteryPercentRemaining>(),   //
        make_unique<ReportPowerSourceBatteryPercentRemaining>(), //
        make_unique<ReadPowerSourceBatteryTimeRemaining>(),      //
        make_unique<ReportPowerSourceBatteryTimeRemaining>(),    //
        make_unique<ReadPowerSourceBatteryChargeLevel>(),        //
        make_unique<ReportPowerSourceBatteryChargeLevel>(),      //
        make_unique<ReadPowerSourceActiveBatteryFaults>(),       //
        make_unique<ReadPowerSourceBatteryChargeState>(),        //
        make_unique<ReportPowerSourceBatteryChargeState>(),      //
        make_unique<ReadPowerSourceAttributeList>(),             //
        make_unique<ReadPowerSourceFeatureMap>(),                //
        make_unique<ReportPowerSourceFeatureMap>(),              //
        make_unique<ReadPowerSourceClusterRevision>(),           //
        make_unique<ReportPowerSourceClusterRevision>(),         //
        make_unique<ReadEventPowerSourceWildcard>(),             //
        make_unique<ReportEventPowerSourceWildcard>(),           //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSourceConfiguration(Commands & commands)
{
    const char * clusterName = "PowerSourceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceConfigurationWildcard>(),        //
        make_unique<ReportPowerSourceConfigurationWildcard>(),      //
        make_unique<ReadPowerSourceConfigurationSources>(),         //
        make_unique<ReadPowerSourceConfigurationAttributeList>(),   //
        make_unique<ReadPowerSourceConfigurationClusterRevision>(), //
        make_unique<ReadEventPowerSourceConfigurationWildcard>(),   //
        make_unique<ReportEventPowerSourceConfigurationWildcard>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPressureMeasurement(Commands & commands)
{
    const char * clusterName = "PressureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadPressureMeasurementWildcard>(),           //
        make_unique<ReportPressureMeasurementWildcard>(),         //
        make_unique<ReadPressureMeasurementMeasuredValue>(),      //
        make_unique<ReportPressureMeasurementMeasuredValue>(),    //
        make_unique<ReadPressureMeasurementMinMeasuredValue>(),   //
        make_unique<ReportPressureMeasurementMinMeasuredValue>(), //
        make_unique<ReadPressureMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportPressureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadPressureMeasurementAttributeList>(),      //
        make_unique<ReadPressureMeasurementClusterRevision>(),    //
        make_unique<ReportPressureMeasurementClusterRevision>(),  //
        make_unique<ReadEventPressureMeasurementWildcard>(),      //
        make_unique<ReportEventPressureMeasurementWildcard>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPumpConfigurationAndControl(Commands & commands)
{
    const char * clusterName = "PumpConfigurationAndControl";

    commands_list clusterCommands = {
        make_unique<ReadPumpConfigurationAndControlWildcard>(),                    //
        make_unique<ReportPumpConfigurationAndControlWildcard>(),                  //
        make_unique<ReadPumpConfigurationAndControlMaxPressure>(),                 //
        make_unique<ReportPumpConfigurationAndControlMaxPressure>(),               //
        make_unique<ReadPumpConfigurationAndControlMaxSpeed>(),                    //
        make_unique<ReportPumpConfigurationAndControlMaxSpeed>(),                  //
        make_unique<ReadPumpConfigurationAndControlMaxFlow>(),                     //
        make_unique<ReportPumpConfigurationAndControlMaxFlow>(),                   //
        make_unique<ReadPumpConfigurationAndControlMinConstPressure>(),            //
        make_unique<ReportPumpConfigurationAndControlMinConstPressure>(),          //
        make_unique<ReadPumpConfigurationAndControlMaxConstPressure>(),            //
        make_unique<ReportPumpConfigurationAndControlMaxConstPressure>(),          //
        make_unique<ReadPumpConfigurationAndControlMinCompPressure>(),             //
        make_unique<ReportPumpConfigurationAndControlMinCompPressure>(),           //
        make_unique<ReadPumpConfigurationAndControlMaxCompPressure>(),             //
        make_unique<ReportPumpConfigurationAndControlMaxCompPressure>(),           //
        make_unique<ReadPumpConfigurationAndControlMinConstSpeed>(),               //
        make_unique<ReportPumpConfigurationAndControlMinConstSpeed>(),             //
        make_unique<ReadPumpConfigurationAndControlMaxConstSpeed>(),               //
        make_unique<ReportPumpConfigurationAndControlMaxConstSpeed>(),             //
        make_unique<ReadPumpConfigurationAndControlMinConstFlow>(),                //
        make_unique<ReportPumpConfigurationAndControlMinConstFlow>(),              //
        make_unique<ReadPumpConfigurationAndControlMaxConstFlow>(),                //
        make_unique<ReportPumpConfigurationAndControlMaxConstFlow>(),              //
        make_unique<ReadPumpConfigurationAndControlMinConstTemp>(),                //
        make_unique<ReportPumpConfigurationAndControlMinConstTemp>(),              //
        make_unique<ReadPumpConfigurationAndControlMaxConstTemp>(),                //
        make_unique<ReportPumpConfigurationAndControlMaxConstTemp>(),              //
        make_unique<ReadPumpConfigurationAndControlPumpStatus>(),                  //
        make_unique<ReportPumpConfigurationAndControlPumpStatus>(),                //
        make_unique<ReadPumpConfigurationAndControlEffectiveOperationMode>(),      //
        make_unique<ReportPumpConfigurationAndControlEffectiveOperationMode>(),    //
        make_unique<ReadPumpConfigurationAndControlEffectiveControlMode>(),        //
        make_unique<ReportPumpConfigurationAndControlEffectiveControlMode>(),      //
        make_unique<ReadPumpConfigurationAndControlCapacity>(),                    //
        make_unique<ReportPumpConfigurationAndControlCapacity>(),                  //
        make_unique<ReadPumpConfigurationAndControlSpeed>(),                       //
        make_unique<ReportPumpConfigurationAndControlSpeed>(),                     //
        make_unique<ReadPumpConfigurationAndControlLifetimeRunningHours>(),        //
        make_unique<WritePumpConfigurationAndControlLifetimeRunningHours>(),       //
        make_unique<ReportPumpConfigurationAndControlLifetimeRunningHours>(),      //
        make_unique<ReadPumpConfigurationAndControlPower>(),                       //
        make_unique<ReportPumpConfigurationAndControlPower>(),                     //
        make_unique<ReadPumpConfigurationAndControlLifetimeEnergyConsumed>(),      //
        make_unique<WritePumpConfigurationAndControlLifetimeEnergyConsumed>(),     //
        make_unique<ReportPumpConfigurationAndControlLifetimeEnergyConsumed>(),    //
        make_unique<ReadPumpConfigurationAndControlOperationMode>(),               //
        make_unique<WritePumpConfigurationAndControlOperationMode>(),              //
        make_unique<ReportPumpConfigurationAndControlOperationMode>(),             //
        make_unique<ReadPumpConfigurationAndControlControlMode>(),                 //
        make_unique<WritePumpConfigurationAndControlControlMode>(),                //
        make_unique<ReportPumpConfigurationAndControlControlMode>(),               //
        make_unique<ReadPumpConfigurationAndControlAlarmMask>(),                   //
        make_unique<ReportPumpConfigurationAndControlAlarmMask>(),                 //
        make_unique<ReadPumpConfigurationAndControlAttributeList>(),               //
        make_unique<ReadPumpConfigurationAndControlFeatureMap>(),                  //
        make_unique<ReportPumpConfigurationAndControlFeatureMap>(),                //
        make_unique<ReadPumpConfigurationAndControlClusterRevision>(),             //
        make_unique<ReportPumpConfigurationAndControlClusterRevision>(),           //
        make_unique<ReadEventPumpConfigurationAndControlWildcard>(),               //
        make_unique<ReportEventPumpConfigurationAndControlWildcard>(),             //
        make_unique<ReadPumpConfigurationAndControlSupplyVoltageLow>(),            //
        make_unique<ReportPumpConfigurationAndControlSupplyVoltageLow>(),          //
        make_unique<ReadPumpConfigurationAndControlSupplyVoltageHigh>(),           //
        make_unique<ReportPumpConfigurationAndControlSupplyVoltageHigh>(),         //
        make_unique<ReadPumpConfigurationAndControlPowerMissingPhase>(),           //
        make_unique<ReportPumpConfigurationAndControlPowerMissingPhase>(),         //
        make_unique<ReadPumpConfigurationAndControlSystemPressureLow>(),           //
        make_unique<ReportPumpConfigurationAndControlSystemPressureLow>(),         //
        make_unique<ReadPumpConfigurationAndControlSystemPressureHigh>(),          //
        make_unique<ReportPumpConfigurationAndControlSystemPressureHigh>(),        //
        make_unique<ReadPumpConfigurationAndControlDryRunning>(),                  //
        make_unique<ReportPumpConfigurationAndControlDryRunning>(),                //
        make_unique<ReadPumpConfigurationAndControlMotorTemperatureHigh>(),        //
        make_unique<ReportPumpConfigurationAndControlMotorTemperatureHigh>(),      //
        make_unique<ReadPumpConfigurationAndControlPumpMotorFatalFailure>(),       //
        make_unique<ReportPumpConfigurationAndControlPumpMotorFatalFailure>(),     //
        make_unique<ReadPumpConfigurationAndControlElectronicTemperatureHigh>(),   //
        make_unique<ReportPumpConfigurationAndControlElectronicTemperatureHigh>(), //
        make_unique<ReadPumpConfigurationAndControlPumpBlocked>(),                 //
        make_unique<ReportPumpConfigurationAndControlPumpBlocked>(),               //
        make_unique<ReadPumpConfigurationAndControlSensorFailure>(),               //
        make_unique<ReportPumpConfigurationAndControlSensorFailure>(),             //
        make_unique<ReadPumpConfigurationAndControlElectronicNonFatalFailure>(),   //
        make_unique<ReportPumpConfigurationAndControlElectronicNonFatalFailure>(), //
        make_unique<ReadPumpConfigurationAndControlElectronicFatalFailure>(),      //
        make_unique<ReportPumpConfigurationAndControlElectronicFatalFailure>(),    //
        make_unique<ReadPumpConfigurationAndControlGeneralFault>(),                //
        make_unique<ReportPumpConfigurationAndControlGeneralFault>(),              //
        make_unique<ReadPumpConfigurationAndControlLeakage>(),                     //
        make_unique<ReportPumpConfigurationAndControlLeakage>(),                   //
        make_unique<ReadPumpConfigurationAndControlAirDetection>(),                //
        make_unique<ReportPumpConfigurationAndControlAirDetection>(),              //
        make_unique<ReadPumpConfigurationAndControlTurbineOperation>(),            //
        make_unique<ReportPumpConfigurationAndControlTurbineOperation>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterRelativeHumidityMeasurement(Commands & commands)
{
    const char * clusterName = "RelativeHumidityMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadRelativeHumidityMeasurementWildcard>(),           //
        make_unique<ReportRelativeHumidityMeasurementWildcard>(),         //
        make_unique<ReadRelativeHumidityMeasurementMeasuredValue>(),      //
        make_unique<ReportRelativeHumidityMeasurementMeasuredValue>(),    //
        make_unique<ReadRelativeHumidityMeasurementMinMeasuredValue>(),   //
        make_unique<ReportRelativeHumidityMeasurementMinMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportRelativeHumidityMeasurementMaxMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementTolerance>(),          //
        make_unique<ReportRelativeHumidityMeasurementTolerance>(),        //
        make_unique<ReadRelativeHumidityMeasurementAttributeList>(),      //
        make_unique<ReadRelativeHumidityMeasurementClusterRevision>(),    //
        make_unique<ReportRelativeHumidityMeasurementClusterRevision>(),  //
        make_unique<ReadEventRelativeHumidityMeasurementWildcard>(),      //
        make_unique<ReportEventRelativeHumidityMeasurementWildcard>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterScenes(Commands & commands)
{
    const char * clusterName = "Scenes";

    commands_list clusterCommands = {
        make_unique<ScenesAddScene>(),              //
        make_unique<ScenesGetSceneMembership>(),    //
        make_unique<ScenesRecallScene>(),           //
        make_unique<ScenesRemoveAllScenes>(),       //
        make_unique<ScenesRemoveScene>(),           //
        make_unique<ScenesStoreScene>(),            //
        make_unique<ScenesViewScene>(),             //
        make_unique<ReadScenesWildcard>(),          //
        make_unique<ReportScenesWildcard>(),        //
        make_unique<ReadScenesSceneCount>(),        //
        make_unique<ReportScenesSceneCount>(),      //
        make_unique<ReadScenesCurrentScene>(),      //
        make_unique<ReportScenesCurrentScene>(),    //
        make_unique<ReadScenesCurrentGroup>(),      //
        make_unique<ReportScenesCurrentGroup>(),    //
        make_unique<ReadScenesSceneValid>(),        //
        make_unique<ReportScenesSceneValid>(),      //
        make_unique<ReadScenesNameSupport>(),       //
        make_unique<ReportScenesNameSupport>(),     //
        make_unique<ReadScenesAttributeList>(),     //
        make_unique<ReadScenesClusterRevision>(),   //
        make_unique<ReportScenesClusterRevision>(), //
        make_unique<ReadEventScenesWildcard>(),     //
        make_unique<ReportEventScenesWildcard>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSoftwareDiagnostics(Commands & commands)
{
    const char * clusterName = "SoftwareDiagnostics";

    commands_list clusterCommands = {
        make_unique<SoftwareDiagnosticsResetWatermarks>(),                //
        make_unique<ReadSoftwareDiagnosticsWildcard>(),                   //
        make_unique<ReportSoftwareDiagnosticsWildcard>(),                 //
        make_unique<ReadSoftwareDiagnosticsThreadMetrics>(),              //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapFree>(),            //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapFree>(),          //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapUsed>(),            //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapUsed>(),          //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapHighWatermark>(),   //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapHighWatermark>(), //
        make_unique<ReadSoftwareDiagnosticsAttributeList>(),              //
        make_unique<ReadSoftwareDiagnosticsFeatureMap>(),                 //
        make_unique<ReadSoftwareDiagnosticsClusterRevision>(),            //
        make_unique<ReportSoftwareDiagnosticsClusterRevision>(),          //
        make_unique<ReadEventSoftwareDiagnosticsWildcard>(),              //
        make_unique<ReportEventSoftwareDiagnosticsWildcard>(),            //
        make_unique<ReadSoftwareDiagnosticsSoftwareFault>(),              //
        make_unique<ReportSoftwareDiagnosticsSoftwareFault>(),            //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSwitch(Commands & commands)
{
    const char * clusterName = "Switch";

    commands_list clusterCommands = {
        make_unique<ReadSwitchWildcard>(),             //
        make_unique<ReportSwitchWildcard>(),           //
        make_unique<ReadSwitchNumberOfPositions>(),    //
        make_unique<ReportSwitchNumberOfPositions>(),  //
        make_unique<ReadSwitchCurrentPosition>(),      //
        make_unique<ReportSwitchCurrentPosition>(),    //
        make_unique<ReadSwitchMultiPressMax>(),        //
        make_unique<ReportSwitchMultiPressMax>(),      //
        make_unique<ReadSwitchAttributeList>(),        //
        make_unique<ReadSwitchFeatureMap>(),           //
        make_unique<ReportSwitchFeatureMap>(),         //
        make_unique<ReadSwitchClusterRevision>(),      //
        make_unique<ReportSwitchClusterRevision>(),    //
        make_unique<ReadEventSwitchWildcard>(),        //
        make_unique<ReportEventSwitchWildcard>(),      //
        make_unique<ReadSwitchSwitchLatched>(),        //
        make_unique<ReportSwitchSwitchLatched>(),      //
        make_unique<ReadSwitchInitialPress>(),         //
        make_unique<ReportSwitchInitialPress>(),       //
        make_unique<ReadSwitchLongPress>(),            //
        make_unique<ReportSwitchLongPress>(),          //
        make_unique<ReadSwitchShortRelease>(),         //
        make_unique<ReportSwitchShortRelease>(),       //
        make_unique<ReadSwitchLongRelease>(),          //
        make_unique<ReportSwitchLongRelease>(),        //
        make_unique<ReadSwitchMultiPressOngoing>(),    //
        make_unique<ReportSwitchMultiPressOngoing>(),  //
        make_unique<ReadSwitchMultiPressComplete>(),   //
        make_unique<ReportSwitchMultiPressComplete>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTargetNavigator(Commands & commands)
{
    const char * clusterName = "TargetNavigator";

    commands_list clusterCommands = {
        make_unique<TargetNavigatorNavigateTargetRequest>(),        //
        make_unique<ReadTargetNavigatorWildcard>(),                 //
        make_unique<ReportTargetNavigatorWildcard>(),               //
        make_unique<ReadTargetNavigatorTargetNavigatorList>(),      //
        make_unique<ReadTargetNavigatorCurrentNavigatorTarget>(),   //
        make_unique<ReportTargetNavigatorCurrentNavigatorTarget>(), //
        make_unique<ReadTargetNavigatorAttributeList>(),            //
        make_unique<ReadTargetNavigatorClusterRevision>(),          //
        make_unique<ReportTargetNavigatorClusterRevision>(),        //
        make_unique<ReadEventTargetNavigatorWildcard>(),            //
        make_unique<ReportEventTargetNavigatorWildcard>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTemperatureMeasurement(Commands & commands)
{
    const char * clusterName = "TemperatureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadTemperatureMeasurementWildcard>(),           //
        make_unique<ReportTemperatureMeasurementWildcard>(),         //
        make_unique<ReadTemperatureMeasurementMeasuredValue>(),      //
        make_unique<ReportTemperatureMeasurementMeasuredValue>(),    //
        make_unique<ReadTemperatureMeasurementMinMeasuredValue>(),   //
        make_unique<ReportTemperatureMeasurementMinMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportTemperatureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementTolerance>(),          //
        make_unique<ReportTemperatureMeasurementTolerance>(),        //
        make_unique<ReadTemperatureMeasurementAttributeList>(),      //
        make_unique<ReadTemperatureMeasurementClusterRevision>(),    //
        make_unique<ReportTemperatureMeasurementClusterRevision>(),  //
        make_unique<ReadEventTemperatureMeasurementWildcard>(),      //
        make_unique<ReportEventTemperatureMeasurementWildcard>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTestCluster(Commands & commands)
{
    const char * clusterName = "TestCluster";

    commands_list clusterCommands = {
        make_unique<TestClusterSimpleStructEchoRequest>(),                 //
        make_unique<TestClusterTest>(),                                    //
        make_unique<TestClusterTestAddArguments>(),                        //
        make_unique<TestClusterTestEmitTestEventRequest>(),                //
        make_unique<TestClusterTestEnumsRequest>(),                        //
        make_unique<TestClusterTestListInt8UArgumentRequest>(),            //
        make_unique<TestClusterTestListInt8UReverseRequest>(),             //
        make_unique<TestClusterTestListNestedStructListArgumentRequest>(), //
        make_unique<TestClusterTestListStructArgumentRequest>(),           //
        make_unique<TestClusterTestNestedStructArgumentRequest>(),         //
        make_unique<TestClusterTestNestedStructListArgumentRequest>(),     //
        make_unique<TestClusterTestNotHandled>(),                          //
        make_unique<TestClusterTestNullableOptionalRequest>(),             //
        make_unique<TestClusterTestSimpleOptionalArgumentRequest>(),       //
        make_unique<TestClusterTestSpecific>(),                            //
        make_unique<TestClusterTestStructArgumentRequest>(),               //
        make_unique<TestClusterTestUnknownCommand>(),                      //
        make_unique<TestClusterTimedInvokeRequest>(),                      //
        make_unique<ReadTestClusterWildcard>(),                            //
        make_unique<ReportTestClusterWildcard>(),                          //
        make_unique<ReadTestClusterBoolean>(),                             //
        make_unique<WriteTestClusterBoolean>(),                            //
        make_unique<ReportTestClusterBoolean>(),                           //
        make_unique<ReadTestClusterBitmap8>(),                             //
        make_unique<WriteTestClusterBitmap8>(),                            //
        make_unique<ReportTestClusterBitmap8>(),                           //
        make_unique<ReadTestClusterBitmap16>(),                            //
        make_unique<WriteTestClusterBitmap16>(),                           //
        make_unique<ReportTestClusterBitmap16>(),                          //
        make_unique<ReadTestClusterBitmap32>(),                            //
        make_unique<WriteTestClusterBitmap32>(),                           //
        make_unique<ReportTestClusterBitmap32>(),                          //
        make_unique<ReadTestClusterBitmap64>(),                            //
        make_unique<WriteTestClusterBitmap64>(),                           //
        make_unique<ReportTestClusterBitmap64>(),                          //
        make_unique<ReadTestClusterInt8u>(),                               //
        make_unique<WriteTestClusterInt8u>(),                              //
        make_unique<ReportTestClusterInt8u>(),                             //
        make_unique<ReadTestClusterInt16u>(),                              //
        make_unique<WriteTestClusterInt16u>(),                             //
        make_unique<ReportTestClusterInt16u>(),                            //
        make_unique<ReadTestClusterInt24u>(),                              //
        make_unique<WriteTestClusterInt24u>(),                             //
        make_unique<ReportTestClusterInt24u>(),                            //
        make_unique<ReadTestClusterInt32u>(),                              //
        make_unique<WriteTestClusterInt32u>(),                             //
        make_unique<ReportTestClusterInt32u>(),                            //
        make_unique<ReadTestClusterInt40u>(),                              //
        make_unique<WriteTestClusterInt40u>(),                             //
        make_unique<ReportTestClusterInt40u>(),                            //
        make_unique<ReadTestClusterInt48u>(),                              //
        make_unique<WriteTestClusterInt48u>(),                             //
        make_unique<ReportTestClusterInt48u>(),                            //
        make_unique<ReadTestClusterInt56u>(),                              //
        make_unique<WriteTestClusterInt56u>(),                             //
        make_unique<ReportTestClusterInt56u>(),                            //
        make_unique<ReadTestClusterInt64u>(),                              //
        make_unique<WriteTestClusterInt64u>(),                             //
        make_unique<ReportTestClusterInt64u>(),                            //
        make_unique<ReadTestClusterInt8s>(),                               //
        make_unique<WriteTestClusterInt8s>(),                              //
        make_unique<ReportTestClusterInt8s>(),                             //
        make_unique<ReadTestClusterInt16s>(),                              //
        make_unique<WriteTestClusterInt16s>(),                             //
        make_unique<ReportTestClusterInt16s>(),                            //
        make_unique<ReadTestClusterInt24s>(),                              //
        make_unique<WriteTestClusterInt24s>(),                             //
        make_unique<ReportTestClusterInt24s>(),                            //
        make_unique<ReadTestClusterInt32s>(),                              //
        make_unique<WriteTestClusterInt32s>(),                             //
        make_unique<ReportTestClusterInt32s>(),                            //
        make_unique<ReadTestClusterInt40s>(),                              //
        make_unique<WriteTestClusterInt40s>(),                             //
        make_unique<ReportTestClusterInt40s>(),                            //
        make_unique<ReadTestClusterInt48s>(),                              //
        make_unique<WriteTestClusterInt48s>(),                             //
        make_unique<ReportTestClusterInt48s>(),                            //
        make_unique<ReadTestClusterInt56s>(),                              //
        make_unique<WriteTestClusterInt56s>(),                             //
        make_unique<ReportTestClusterInt56s>(),                            //
        make_unique<ReadTestClusterInt64s>(),                              //
        make_unique<WriteTestClusterInt64s>(),                             //
        make_unique<ReportTestClusterInt64s>(),                            //
        make_unique<ReadTestClusterEnum8>(),                               //
        make_unique<WriteTestClusterEnum8>(),                              //
        make_unique<ReportTestClusterEnum8>(),                             //
        make_unique<ReadTestClusterEnum16>(),                              //
        make_unique<WriteTestClusterEnum16>(),                             //
        make_unique<ReportTestClusterEnum16>(),                            //
        make_unique<ReadTestClusterFloatSingle>(),                         //
        make_unique<WriteTestClusterFloatSingle>(),                        //
        make_unique<ReportTestClusterFloatSingle>(),                       //
        make_unique<ReadTestClusterFloatDouble>(),                         //
        make_unique<WriteTestClusterFloatDouble>(),                        //
        make_unique<ReportTestClusterFloatDouble>(),                       //
        make_unique<ReadTestClusterOctetString>(),                         //
        make_unique<WriteTestClusterOctetString>(),                        //
        make_unique<ReportTestClusterOctetString>(),                       //
        make_unique<ReadTestClusterListInt8u>(),                           //
        make_unique<ReadTestClusterListOctetString>(),                     //
        make_unique<ReadTestClusterListStructOctetString>(),               //
        make_unique<ReadTestClusterLongOctetString>(),                     //
        make_unique<WriteTestClusterLongOctetString>(),                    //
        make_unique<ReportTestClusterLongOctetString>(),                   //
        make_unique<ReadTestClusterCharString>(),                          //
        make_unique<WriteTestClusterCharString>(),                         //
        make_unique<ReportTestClusterCharString>(),                        //
        make_unique<ReadTestClusterLongCharString>(),                      //
        make_unique<WriteTestClusterLongCharString>(),                     //
        make_unique<ReportTestClusterLongCharString>(),                    //
        make_unique<ReadTestClusterEpochUs>(),                             //
        make_unique<WriteTestClusterEpochUs>(),                            //
        make_unique<ReportTestClusterEpochUs>(),                           //
        make_unique<ReadTestClusterEpochS>(),                              //
        make_unique<WriteTestClusterEpochS>(),                             //
        make_unique<ReportTestClusterEpochS>(),                            //
        make_unique<ReadTestClusterVendorId>(),                            //
        make_unique<WriteTestClusterVendorId>(),                           //
        make_unique<ReportTestClusterVendorId>(),                          //
        make_unique<ReadTestClusterListNullablesAndOptionalsStruct>(),     //
        make_unique<ReadTestClusterEnumAttr>(),                            //
        make_unique<WriteTestClusterEnumAttr>(),                           //
        make_unique<ReportTestClusterEnumAttr>(),                          //
        make_unique<ReadTestClusterRangeRestrictedInt8u>(),                //
        make_unique<WriteTestClusterRangeRestrictedInt8u>(),               //
        make_unique<ReportTestClusterRangeRestrictedInt8u>(),              //
        make_unique<ReadTestClusterRangeRestrictedInt8s>(),                //
        make_unique<WriteTestClusterRangeRestrictedInt8s>(),               //
        make_unique<ReportTestClusterRangeRestrictedInt8s>(),              //
        make_unique<ReadTestClusterRangeRestrictedInt16u>(),               //
        make_unique<WriteTestClusterRangeRestrictedInt16u>(),              //
        make_unique<ReportTestClusterRangeRestrictedInt16u>(),             //
        make_unique<ReadTestClusterRangeRestrictedInt16s>(),               //
        make_unique<WriteTestClusterRangeRestrictedInt16s>(),              //
        make_unique<ReportTestClusterRangeRestrictedInt16s>(),             //
        make_unique<ReadTestClusterListLongOctetString>(),                 //
        make_unique<ReadTestClusterTimedWriteBoolean>(),                   //
        make_unique<WriteTestClusterTimedWriteBoolean>(),                  //
        make_unique<ReadTestClusterUnsupported>(),                         //
        make_unique<WriteTestClusterUnsupported>(),                        //
        make_unique<ReportTestClusterUnsupported>(),                       //
        make_unique<ReadTestClusterNullableBoolean>(),                     //
        make_unique<WriteTestClusterNullableBoolean>(),                    //
        make_unique<ReportTestClusterNullableBoolean>(),                   //
        make_unique<ReadTestClusterNullableBitmap8>(),                     //
        make_unique<WriteTestClusterNullableBitmap8>(),                    //
        make_unique<ReportTestClusterNullableBitmap8>(),                   //
        make_unique<ReadTestClusterNullableBitmap16>(),                    //
        make_unique<WriteTestClusterNullableBitmap16>(),                   //
        make_unique<ReportTestClusterNullableBitmap16>(),                  //
        make_unique<ReadTestClusterNullableBitmap32>(),                    //
        make_unique<WriteTestClusterNullableBitmap32>(),                   //
        make_unique<ReportTestClusterNullableBitmap32>(),                  //
        make_unique<ReadTestClusterNullableBitmap64>(),                    //
        make_unique<WriteTestClusterNullableBitmap64>(),                   //
        make_unique<ReportTestClusterNullableBitmap64>(),                  //
        make_unique<ReadTestClusterNullableInt8u>(),                       //
        make_unique<WriteTestClusterNullableInt8u>(),                      //
        make_unique<ReportTestClusterNullableInt8u>(),                     //
        make_unique<ReadTestClusterNullableInt16u>(),                      //
        make_unique<WriteTestClusterNullableInt16u>(),                     //
        make_unique<ReportTestClusterNullableInt16u>(),                    //
        make_unique<ReadTestClusterNullableInt24u>(),                      //
        make_unique<WriteTestClusterNullableInt24u>(),                     //
        make_unique<ReportTestClusterNullableInt24u>(),                    //
        make_unique<ReadTestClusterNullableInt32u>(),                      //
        make_unique<WriteTestClusterNullableInt32u>(),                     //
        make_unique<ReportTestClusterNullableInt32u>(),                    //
        make_unique<ReadTestClusterNullableInt40u>(),                      //
        make_unique<WriteTestClusterNullableInt40u>(),                     //
        make_unique<ReportTestClusterNullableInt40u>(),                    //
        make_unique<ReadTestClusterNullableInt48u>(),                      //
        make_unique<WriteTestClusterNullableInt48u>(),                     //
        make_unique<ReportTestClusterNullableInt48u>(),                    //
        make_unique<ReadTestClusterNullableInt56u>(),                      //
        make_unique<WriteTestClusterNullableInt56u>(),                     //
        make_unique<ReportTestClusterNullableInt56u>(),                    //
        make_unique<ReadTestClusterNullableInt64u>(),                      //
        make_unique<WriteTestClusterNullableInt64u>(),                     //
        make_unique<ReportTestClusterNullableInt64u>(),                    //
        make_unique<ReadTestClusterNullableInt8s>(),                       //
        make_unique<WriteTestClusterNullableInt8s>(),                      //
        make_unique<ReportTestClusterNullableInt8s>(),                     //
        make_unique<ReadTestClusterNullableInt16s>(),                      //
        make_unique<WriteTestClusterNullableInt16s>(),                     //
        make_unique<ReportTestClusterNullableInt16s>(),                    //
        make_unique<ReadTestClusterNullableInt24s>(),                      //
        make_unique<WriteTestClusterNullableInt24s>(),                     //
        make_unique<ReportTestClusterNullableInt24s>(),                    //
        make_unique<ReadTestClusterNullableInt32s>(),                      //
        make_unique<WriteTestClusterNullableInt32s>(),                     //
        make_unique<ReportTestClusterNullableInt32s>(),                    //
        make_unique<ReadTestClusterNullableInt40s>(),                      //
        make_unique<WriteTestClusterNullableInt40s>(),                     //
        make_unique<ReportTestClusterNullableInt40s>(),                    //
        make_unique<ReadTestClusterNullableInt48s>(),                      //
        make_unique<WriteTestClusterNullableInt48s>(),                     //
        make_unique<ReportTestClusterNullableInt48s>(),                    //
        make_unique<ReadTestClusterNullableInt56s>(),                      //
        make_unique<WriteTestClusterNullableInt56s>(),                     //
        make_unique<ReportTestClusterNullableInt56s>(),                    //
        make_unique<ReadTestClusterNullableInt64s>(),                      //
        make_unique<WriteTestClusterNullableInt64s>(),                     //
        make_unique<ReportTestClusterNullableInt64s>(),                    //
        make_unique<ReadTestClusterNullableEnum8>(),                       //
        make_unique<WriteTestClusterNullableEnum8>(),                      //
        make_unique<ReportTestClusterNullableEnum8>(),                     //
        make_unique<ReadTestClusterNullableEnum16>(),                      //
        make_unique<WriteTestClusterNullableEnum16>(),                     //
        make_unique<ReportTestClusterNullableEnum16>(),                    //
        make_unique<ReadTestClusterNullableFloatSingle>(),                 //
        make_unique<WriteTestClusterNullableFloatSingle>(),                //
        make_unique<ReportTestClusterNullableFloatSingle>(),               //
        make_unique<ReadTestClusterNullableFloatDouble>(),                 //
        make_unique<WriteTestClusterNullableFloatDouble>(),                //
        make_unique<ReportTestClusterNullableFloatDouble>(),               //
        make_unique<ReadTestClusterNullableOctetString>(),                 //
        make_unique<WriteTestClusterNullableOctetString>(),                //
        make_unique<ReportTestClusterNullableOctetString>(),               //
        make_unique<ReadTestClusterNullableCharString>(),                  //
        make_unique<WriteTestClusterNullableCharString>(),                 //
        make_unique<ReportTestClusterNullableCharString>(),                //
        make_unique<ReadTestClusterNullableEnumAttr>(),                    //
        make_unique<WriteTestClusterNullableEnumAttr>(),                   //
        make_unique<ReportTestClusterNullableEnumAttr>(),                  //
        make_unique<ReadTestClusterNullableRangeRestrictedInt8u>(),        //
        make_unique<WriteTestClusterNullableRangeRestrictedInt8u>(),       //
        make_unique<ReportTestClusterNullableRangeRestrictedInt8u>(),      //
        make_unique<ReadTestClusterNullableRangeRestrictedInt8s>(),        //
        make_unique<WriteTestClusterNullableRangeRestrictedInt8s>(),       //
        make_unique<ReportTestClusterNullableRangeRestrictedInt8s>(),      //
        make_unique<ReadTestClusterNullableRangeRestrictedInt16u>(),       //
        make_unique<WriteTestClusterNullableRangeRestrictedInt16u>(),      //
        make_unique<ReportTestClusterNullableRangeRestrictedInt16u>(),     //
        make_unique<ReadTestClusterNullableRangeRestrictedInt16s>(),       //
        make_unique<WriteTestClusterNullableRangeRestrictedInt16s>(),      //
        make_unique<ReportTestClusterNullableRangeRestrictedInt16s>(),     //
        make_unique<ReadTestClusterAttributeList>(),                       //
        make_unique<ReadTestClusterClusterRevision>(),                     //
        make_unique<ReportTestClusterClusterRevision>(),                   //
        make_unique<ReadEventTestClusterWildcard>(),                       //
        make_unique<ReportEventTestClusterWildcard>(),                     //
        make_unique<ReadTestClusterTestEvent>(),                           //
        make_unique<ReportTestClusterTestEvent>(),                         //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostat(Commands & commands)
{
    const char * clusterName = "Thermostat";

    commands_list clusterCommands = {
        make_unique<ThermostatClearWeeklySchedule>(),              //
        make_unique<ThermostatGetRelayStatusLog>(),                //
        make_unique<ThermostatGetWeeklySchedule>(),                //
        make_unique<ThermostatSetWeeklySchedule>(),                //
        make_unique<ThermostatSetpointRaiseLower>(),               //
        make_unique<ReadThermostatWildcard>(),                     //
        make_unique<ReportThermostatWildcard>(),                   //
        make_unique<ReadThermostatLocalTemperature>(),             //
        make_unique<ReportThermostatLocalTemperature>(),           //
        make_unique<ReadThermostatAbsMinHeatSetpointLimit>(),      //
        make_unique<ReportThermostatAbsMinHeatSetpointLimit>(),    //
        make_unique<ReadThermostatAbsMaxHeatSetpointLimit>(),      //
        make_unique<ReportThermostatAbsMaxHeatSetpointLimit>(),    //
        make_unique<ReadThermostatAbsMinCoolSetpointLimit>(),      //
        make_unique<ReportThermostatAbsMinCoolSetpointLimit>(),    //
        make_unique<ReadThermostatAbsMaxCoolSetpointLimit>(),      //
        make_unique<ReportThermostatAbsMaxCoolSetpointLimit>(),    //
        make_unique<ReadThermostatOccupiedCoolingSetpoint>(),      //
        make_unique<WriteThermostatOccupiedCoolingSetpoint>(),     //
        make_unique<ReportThermostatOccupiedCoolingSetpoint>(),    //
        make_unique<ReadThermostatOccupiedHeatingSetpoint>(),      //
        make_unique<WriteThermostatOccupiedHeatingSetpoint>(),     //
        make_unique<ReportThermostatOccupiedHeatingSetpoint>(),    //
        make_unique<ReadThermostatMinHeatSetpointLimit>(),         //
        make_unique<WriteThermostatMinHeatSetpointLimit>(),        //
        make_unique<ReportThermostatMinHeatSetpointLimit>(),       //
        make_unique<ReadThermostatMaxHeatSetpointLimit>(),         //
        make_unique<WriteThermostatMaxHeatSetpointLimit>(),        //
        make_unique<ReportThermostatMaxHeatSetpointLimit>(),       //
        make_unique<ReadThermostatMinCoolSetpointLimit>(),         //
        make_unique<WriteThermostatMinCoolSetpointLimit>(),        //
        make_unique<ReportThermostatMinCoolSetpointLimit>(),       //
        make_unique<ReadThermostatMaxCoolSetpointLimit>(),         //
        make_unique<WriteThermostatMaxCoolSetpointLimit>(),        //
        make_unique<ReportThermostatMaxCoolSetpointLimit>(),       //
        make_unique<ReadThermostatMinSetpointDeadBand>(),          //
        make_unique<WriteThermostatMinSetpointDeadBand>(),         //
        make_unique<ReportThermostatMinSetpointDeadBand>(),        //
        make_unique<ReadThermostatControlSequenceOfOperation>(),   //
        make_unique<WriteThermostatControlSequenceOfOperation>(),  //
        make_unique<ReportThermostatControlSequenceOfOperation>(), //
        make_unique<ReadThermostatSystemMode>(),                   //
        make_unique<WriteThermostatSystemMode>(),                  //
        make_unique<ReportThermostatSystemMode>(),                 //
        make_unique<ReadThermostatStartOfWeek>(),                  //
        make_unique<ReportThermostatStartOfWeek>(),                //
        make_unique<ReadThermostatNumberOfWeeklyTransitions>(),    //
        make_unique<ReportThermostatNumberOfWeeklyTransitions>(),  //
        make_unique<ReadThermostatNumberOfDailyTransitions>(),     //
        make_unique<ReportThermostatNumberOfDailyTransitions>(),   //
        make_unique<ReadThermostatAttributeList>(),                //
        make_unique<ReadThermostatFeatureMap>(),                   //
        make_unique<ReportThermostatFeatureMap>(),                 //
        make_unique<ReadThermostatClusterRevision>(),              //
        make_unique<ReportThermostatClusterRevision>(),            //
        make_unique<ReadEventThermostatWildcard>(),                //
        make_unique<ReportEventThermostatWildcard>(),              //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostatUserInterfaceConfiguration(Commands & commands)
{
    const char * clusterName = "ThermostatUserInterfaceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadThermostatUserInterfaceConfigurationWildcard>(),                        //
        make_unique<ReportThermostatUserInterfaceConfigurationWildcard>(),                      //
        make_unique<ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode>(),          //
        make_unique<WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode>(),         //
        make_unique<ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode>(),        //
        make_unique<ReadThermostatUserInterfaceConfigurationKeypadLockout>(),                   //
        make_unique<WriteThermostatUserInterfaceConfigurationKeypadLockout>(),                  //
        make_unique<ReportThermostatUserInterfaceConfigurationKeypadLockout>(),                 //
        make_unique<ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(),   //
        make_unique<WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(),  //
        make_unique<ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationAttributeList>(),                   //
        make_unique<ReadThermostatUserInterfaceConfigurationClusterRevision>(),                 //
        make_unique<ReportThermostatUserInterfaceConfigurationClusterRevision>(),               //
        make_unique<ReadEventThermostatUserInterfaceConfigurationWildcard>(),                   //
        make_unique<ReportEventThermostatUserInterfaceConfigurationWildcard>(),                 //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThreadNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "ThreadNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<ThreadNetworkDiagnosticsResetCounts>(),                             //
        make_unique<ReadThreadNetworkDiagnosticsWildcard>(),                            //
        make_unique<ReportThreadNetworkDiagnosticsWildcard>(),                          //
        make_unique<ReadThreadNetworkDiagnosticsChannel>(),                             //
        make_unique<ReportThreadNetworkDiagnosticsChannel>(),                           //
        make_unique<ReadThreadNetworkDiagnosticsRoutingRole>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsRoutingRole>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsNetworkName>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsNetworkName>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsPanId>(),                               //
        make_unique<ReportThreadNetworkDiagnosticsPanId>(),                             //
        make_unique<ReadThreadNetworkDiagnosticsExtendedPanId>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsExtendedPanId>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsMeshLocalPrefix>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsMeshLocalPrefix>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsOverrunCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsOverrunCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsNeighborTableList>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsRouteTableList>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsPartitionId>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsPartitionId>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsWeighting>(),                           //
        make_unique<ReportThreadNetworkDiagnosticsWeighting>(),                         //
        make_unique<ReadThreadNetworkDiagnosticsDataVersion>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsDataVersion>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsStableDataVersion>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsStableDataVersion>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRouterId>(),                      //
        make_unique<ReportThreadNetworkDiagnosticsLeaderRouterId>(),                    //
        make_unique<ReadThreadNetworkDiagnosticsDetachedRoleCount>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsDetachedRoleCount>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsChildRoleCount>(),                      //
        make_unique<ReportThreadNetworkDiagnosticsChildRoleCount>(),                    //
        make_unique<ReadThreadNetworkDiagnosticsRouterRoleCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsRouterRoleCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRoleCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsLeaderRoleCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsAttachAttemptCount>(),                  //
        make_unique<ReportThreadNetworkDiagnosticsAttachAttemptCount>(),                //
        make_unique<ReadThreadNetworkDiagnosticsPartitionIdChangeCount>(),              //
        make_unique<ReportThreadNetworkDiagnosticsPartitionIdChangeCount>(),            //
        make_unique<ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(),   //
        make_unique<ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsParentChangeCount>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsParentChangeCount>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsTxTotalCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsTxTotalCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsTxUnicastCount>(),                      //
        make_unique<ReportThreadNetworkDiagnosticsTxUnicastCount>(),                    //
        make_unique<ReadThreadNetworkDiagnosticsTxBroadcastCount>(),                    //
        make_unique<ReportThreadNetworkDiagnosticsTxBroadcastCount>(),                  //
        make_unique<ReadThreadNetworkDiagnosticsTxAckRequestedCount>(),                 //
        make_unique<ReportThreadNetworkDiagnosticsTxAckRequestedCount>(),               //
        make_unique<ReadThreadNetworkDiagnosticsTxAckedCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsTxAckedCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsTxNoAckRequestedCount>(),               //
        make_unique<ReportThreadNetworkDiagnosticsTxNoAckRequestedCount>(),             //
        make_unique<ReadThreadNetworkDiagnosticsTxDataCount>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsTxDataCount>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsTxDataPollCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsTxDataPollCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsTxBeaconCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconRequestCount>(),                //
        make_unique<ReportThreadNetworkDiagnosticsTxBeaconRequestCount>(),              //
        make_unique<ReadThreadNetworkDiagnosticsTxOtherCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsTxOtherCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsTxRetryCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsTxRetryCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(),         //
        make_unique<ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(),       //
        make_unique<ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(),       //
        make_unique<ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(),     //
        make_unique<ReadThreadNetworkDiagnosticsTxErrCcaCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsTxErrCcaCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsTxErrAbortCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsTxErrAbortCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsTxErrBusyChannelCount>(),               //
        make_unique<ReportThreadNetworkDiagnosticsTxErrBusyChannelCount>(),             //
        make_unique<ReadThreadNetworkDiagnosticsRxTotalCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsRxTotalCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsRxUnicastCount>(),                      //
        make_unique<ReportThreadNetworkDiagnosticsRxUnicastCount>(),                    //
        make_unique<ReadThreadNetworkDiagnosticsRxBroadcastCount>(),                    //
        make_unique<ReportThreadNetworkDiagnosticsRxBroadcastCount>(),                  //
        make_unique<ReadThreadNetworkDiagnosticsRxDataCount>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsRxDataCount>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsRxDataPollCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsRxDataPollCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsRxBeaconCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconRequestCount>(),                //
        make_unique<ReportThreadNetworkDiagnosticsRxBeaconRequestCount>(),              //
        make_unique<ReadThreadNetworkDiagnosticsRxOtherCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsRxOtherCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsRxAddressFilteredCount>(),              //
        make_unique<ReportThreadNetworkDiagnosticsRxAddressFilteredCount>(),            //
        make_unique<ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount>(),             //
        make_unique<ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount>(),           //
        make_unique<ReadThreadNetworkDiagnosticsRxDuplicatedCount>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsRxDuplicatedCount>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsRxErrNoFrameCount>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsRxErrNoFrameCount>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(),           //
        make_unique<ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(),         //
        make_unique<ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(),            //
        make_unique<ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(),          //
        make_unique<ReadThreadNetworkDiagnosticsRxErrSecCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsRxErrSecCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsRxErrFcsCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsRxErrFcsCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsRxErrOtherCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsRxErrOtherCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsActiveTimestamp>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsActiveTimestamp>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsPendingTimestamp>(),                    //
        make_unique<ReportThreadNetworkDiagnosticsPendingTimestamp>(),                  //
        make_unique<ReadThreadNetworkDiagnosticsDelay>(),                               //
        make_unique<ReportThreadNetworkDiagnosticsDelay>(),                             //
        make_unique<ReadThreadNetworkDiagnosticsSecurityPolicy>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsChannelMask>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsChannelMask>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsOperationalDatasetComponents>(),        //
        make_unique<ReadThreadNetworkDiagnosticsActiveNetworkFaultsList>(),             //
        make_unique<ReadThreadNetworkDiagnosticsAttributeList>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsFeatureMap>(),                          //
        make_unique<ReadThreadNetworkDiagnosticsClusterRevision>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsClusterRevision>(),                   //
        make_unique<ReadEventThreadNetworkDiagnosticsWildcard>(),                       //
        make_unique<ReportEventThreadNetworkDiagnosticsWildcard>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsConnectionStatus>(),                    //
        make_unique<ReportThreadNetworkDiagnosticsConnectionStatus>(),                  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterUserLabel(Commands & commands)
{
    const char * clusterName = "UserLabel";

    commands_list clusterCommands = {
        make_unique<ReadUserLabelWildcard>(),        //
        make_unique<ReportUserLabelWildcard>(),      //
        make_unique<ReadUserLabelLabelList>(),       //
        make_unique<ReadUserLabelClusterRevision>(), //
        make_unique<ReadEventUserLabelWildcard>(),   //
        make_unique<ReportEventUserLabelWildcard>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWakeOnLan(Commands & commands)
{
    const char * clusterName = "WakeOnLan";

    commands_list clusterCommands = {
        make_unique<ReadWakeOnLanWildcard>(),              //
        make_unique<ReportWakeOnLanWildcard>(),            //
        make_unique<ReadWakeOnLanWakeOnLanMacAddress>(),   //
        make_unique<ReportWakeOnLanWakeOnLanMacAddress>(), //
        make_unique<ReadWakeOnLanAttributeList>(),         //
        make_unique<ReadWakeOnLanClusterRevision>(),       //
        make_unique<ReportWakeOnLanClusterRevision>(),     //
        make_unique<ReadEventWakeOnLanWildcard>(),         //
        make_unique<ReportEventWakeOnLanWildcard>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWiFiNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "WiFiNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<WiFiNetworkDiagnosticsResetCounts>(),                  //
        make_unique<ReadWiFiNetworkDiagnosticsWildcard>(),                 //
        make_unique<ReportWiFiNetworkDiagnosticsWildcard>(),               //
        make_unique<ReadWiFiNetworkDiagnosticsBssid>(),                    //
        make_unique<ReportWiFiNetworkDiagnosticsBssid>(),                  //
        make_unique<ReadWiFiNetworkDiagnosticsSecurityType>(),             //
        make_unique<ReportWiFiNetworkDiagnosticsSecurityType>(),           //
        make_unique<ReadWiFiNetworkDiagnosticsWiFiVersion>(),              //
        make_unique<ReportWiFiNetworkDiagnosticsWiFiVersion>(),            //
        make_unique<ReadWiFiNetworkDiagnosticsChannelNumber>(),            //
        make_unique<ReportWiFiNetworkDiagnosticsChannelNumber>(),          //
        make_unique<ReadWiFiNetworkDiagnosticsRssi>(),                     //
        make_unique<ReportWiFiNetworkDiagnosticsRssi>(),                   //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconLostCount>(),          //
        make_unique<ReportWiFiNetworkDiagnosticsBeaconLostCount>(),        //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconRxCount>(),            //
        make_unique<ReportWiFiNetworkDiagnosticsBeaconRxCount>(),          //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastRxCount>(),   //
        make_unique<ReportWiFiNetworkDiagnosticsPacketMulticastRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastTxCount>(),   //
        make_unique<ReportWiFiNetworkDiagnosticsPacketMulticastTxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastRxCount>(),     //
        make_unique<ReportWiFiNetworkDiagnosticsPacketUnicastRxCount>(),   //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastTxCount>(),     //
        make_unique<ReportWiFiNetworkDiagnosticsPacketUnicastTxCount>(),   //
        make_unique<ReadWiFiNetworkDiagnosticsCurrentMaxRate>(),           //
        make_unique<ReportWiFiNetworkDiagnosticsCurrentMaxRate>(),         //
        make_unique<ReadWiFiNetworkDiagnosticsOverrunCount>(),             //
        make_unique<ReportWiFiNetworkDiagnosticsOverrunCount>(),           //
        make_unique<ReadWiFiNetworkDiagnosticsAttributeList>(),            //
        make_unique<ReadWiFiNetworkDiagnosticsFeatureMap>(),               //
        make_unique<ReadWiFiNetworkDiagnosticsClusterRevision>(),          //
        make_unique<ReportWiFiNetworkDiagnosticsClusterRevision>(),        //
        make_unique<ReadEventWiFiNetworkDiagnosticsWildcard>(),            //
        make_unique<ReportEventWiFiNetworkDiagnosticsWildcard>(),          //
        make_unique<ReadWiFiNetworkDiagnosticsDisconnection>(),            //
        make_unique<ReportWiFiNetworkDiagnosticsDisconnection>(),          //
        make_unique<ReadWiFiNetworkDiagnosticsAssociationFailure>(),       //
        make_unique<ReportWiFiNetworkDiagnosticsAssociationFailure>(),     //
        make_unique<ReadWiFiNetworkDiagnosticsConnectionStatus>(),         //
        make_unique<ReportWiFiNetworkDiagnosticsConnectionStatus>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWindowCovering(Commands & commands)
{
    const char * clusterName = "WindowCovering";

    commands_list clusterCommands = {
        make_unique<WindowCoveringDownOrClose>(),                            //
        make_unique<WindowCoveringGoToLiftPercentage>(),                     //
        make_unique<WindowCoveringGoToLiftValue>(),                          //
        make_unique<WindowCoveringGoToTiltPercentage>(),                     //
        make_unique<WindowCoveringGoToTiltValue>(),                          //
        make_unique<WindowCoveringStopMotion>(),                             //
        make_unique<WindowCoveringUpOrOpen>(),                               //
        make_unique<ReadWindowCoveringWildcard>(),                           //
        make_unique<ReportWindowCoveringWildcard>(),                         //
        make_unique<ReadWindowCoveringType>(),                               //
        make_unique<ReportWindowCoveringType>(),                             //
        make_unique<ReadWindowCoveringCurrentPositionLift>(),                //
        make_unique<ReportWindowCoveringCurrentPositionLift>(),              //
        make_unique<ReadWindowCoveringCurrentPositionTilt>(),                //
        make_unique<ReportWindowCoveringCurrentPositionTilt>(),              //
        make_unique<ReadWindowCoveringConfigStatus>(),                       //
        make_unique<ReportWindowCoveringConfigStatus>(),                     //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercentage>(),      //
        make_unique<ReportWindowCoveringCurrentPositionLiftPercentage>(),    //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercentage>(),      //
        make_unique<ReportWindowCoveringCurrentPositionTiltPercentage>(),    //
        make_unique<ReadWindowCoveringOperationalStatus>(),                  //
        make_unique<ReportWindowCoveringOperationalStatus>(),                //
        make_unique<ReadWindowCoveringTargetPositionLiftPercent100ths>(),    //
        make_unique<ReportWindowCoveringTargetPositionLiftPercent100ths>(),  //
        make_unique<ReadWindowCoveringTargetPositionTiltPercent100ths>(),    //
        make_unique<ReportWindowCoveringTargetPositionTiltPercent100ths>(),  //
        make_unique<ReadWindowCoveringEndProductType>(),                     //
        make_unique<ReportWindowCoveringEndProductType>(),                   //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercent100ths>(),   //
        make_unique<ReportWindowCoveringCurrentPositionLiftPercent100ths>(), //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercent100ths>(),   //
        make_unique<ReportWindowCoveringCurrentPositionTiltPercent100ths>(), //
        make_unique<ReadWindowCoveringInstalledOpenLimitLift>(),             //
        make_unique<ReportWindowCoveringInstalledOpenLimitLift>(),           //
        make_unique<ReadWindowCoveringInstalledClosedLimitLift>(),           //
        make_unique<ReportWindowCoveringInstalledClosedLimitLift>(),         //
        make_unique<ReadWindowCoveringInstalledOpenLimitTilt>(),             //
        make_unique<ReportWindowCoveringInstalledOpenLimitTilt>(),           //
        make_unique<ReadWindowCoveringInstalledClosedLimitTilt>(),           //
        make_unique<ReportWindowCoveringInstalledClosedLimitTilt>(),         //
        make_unique<ReadWindowCoveringMode>(),                               //
        make_unique<WriteWindowCoveringMode>(),                              //
        make_unique<ReportWindowCoveringMode>(),                             //
        make_unique<ReadWindowCoveringSafetyStatus>(),                       //
        make_unique<ReportWindowCoveringSafetyStatus>(),                     //
        make_unique<ReadWindowCoveringAttributeList>(),                      //
        make_unique<ReadWindowCoveringFeatureMap>(),                         //
        make_unique<ReportWindowCoveringFeatureMap>(),                       //
        make_unique<ReadWindowCoveringClusterRevision>(),                    //
        make_unique<ReportWindowCoveringClusterRevision>(),                  //
        make_unique<ReadEventWindowCoveringWildcard>(),                      //
        make_unique<ReportEventWindowCoveringWildcard>(),                    //
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterWildcard(Commands & commands)
{
    const char * clusterName = "0xffffffff";

    commands_list clusterCommands = {
        make_unique<ReadWildcard>(),        //
        make_unique<ReportWildcard>(),      //
        make_unique<ReadEventWildcard>(),   //
        make_unique<ReportEventWildcard>(), //
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusters(Commands & commands)
{
    registerClusterWildcard(commands);
    registerClusterAccessControl(commands);
    registerClusterAccountLogin(commands);
    registerClusterAdministratorCommissioning(commands);
    registerClusterApplicationBasic(commands);
    registerClusterApplicationLauncher(commands);
    registerClusterAudioOutput(commands);
    registerClusterBarrierControl(commands);
    registerClusterBasic(commands);
    registerClusterBinaryInputBasic(commands);
    registerClusterBinding(commands);
    registerClusterBooleanState(commands);
    registerClusterBridgedActions(commands);
    registerClusterBridgedDeviceBasic(commands);
    registerClusterChannel(commands);
    registerClusterColorControl(commands);
    registerClusterContentLauncher(commands);
    registerClusterDescriptor(commands);
    registerClusterDiagnosticLogs(commands);
    registerClusterDoorLock(commands);
    registerClusterElectricalMeasurement(commands);
    registerClusterEthernetNetworkDiagnostics(commands);
    registerClusterFixedLabel(commands);
    registerClusterFlowMeasurement(commands);
    registerClusterGeneralCommissioning(commands);
    registerClusterGeneralDiagnostics(commands);
    registerClusterGroupKeyManagement(commands);
    registerClusterGroups(commands);
    registerClusterIdentify(commands);
    registerClusterIlluminanceMeasurement(commands);
    registerClusterKeypadInput(commands);
    registerClusterLevelControl(commands);
    registerClusterLocalizationConfiguration(commands);
    registerClusterLowPower(commands);
    registerClusterMediaInput(commands);
    registerClusterMediaPlayback(commands);
    registerClusterModeSelect(commands);
    registerClusterNetworkCommissioning(commands);
    registerClusterOtaSoftwareUpdateProvider(commands);
    registerClusterOtaSoftwareUpdateRequestor(commands);
    registerClusterOccupancySensing(commands);
    registerClusterOnOff(commands);
    registerClusterOnOffSwitchConfiguration(commands);
    registerClusterOperationalCredentials(commands);
    registerClusterPowerSource(commands);
    registerClusterPowerSourceConfiguration(commands);
    registerClusterPressureMeasurement(commands);
    registerClusterPumpConfigurationAndControl(commands);
    registerClusterRelativeHumidityMeasurement(commands);
    registerClusterScenes(commands);
    registerClusterSoftwareDiagnostics(commands);
    registerClusterSwitch(commands);
    registerClusterTargetNavigator(commands);
    registerClusterTemperatureMeasurement(commands);
    registerClusterTestCluster(commands);
    registerClusterThermostat(commands);
    registerClusterThermostatUserInterfaceConfiguration(commands);
    registerClusterThreadNetworkDiagnostics(commands);
    registerClusterUserLabel(commands);
    registerClusterWakeOnLan(commands);
    registerClusterWiFiNetworkDiagnostics(commands);
    registerClusterWindowCovering(commands);
}
