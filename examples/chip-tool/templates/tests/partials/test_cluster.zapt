{{#chip_tests tests}}
class {{filename}}Suite: public TestCommand
{
  public:
    {{#if ../credsIssuerConfigArg}}
    {{filename}}Suite(CredentialIssuerCommands * credsIssuerConfig): TestCommand("{{filename}}", credsIssuerConfig), mTestIndex(0)
    {{else}}
    {{filename}}Suite(): TestCommand("{{filename}}"), mTestIndex(0)
    {{/if}}
    {
        {{#chip_tests_config}}
          {{#if (isString type)}}
          AddArgument("{{name}}", &m{{asUpperCamelCase name}});
          {{else}}
          AddArgument("{{name}}", {{asTypeMinValue type}}, {{asTypeMaxValue type}}, &m{{asUpperCamelCase name}});
          {{/if}}
        {{/chip_tests_config}}
    }

    ~{{filename}}Suite()
    {
        {{>teardownSaveAs}}
    }

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
      CHIP_ERROR err = CHIP_NO_ERROR;

      if (0 == mTestIndex)
      {
          ChipLogProgress(chipTool, " **** Test Start: {{filename}}\n");
      }

      if (mTestCount == mTestIndex)
      {
          ChipLogProgress(chipTool, " **** Test Complete: {{filename}}\n");
          InteractionModel::Shutdown();
          SetCommandExitStatus(CHIP_NO_ERROR);
          return;
      }

      // Ensure we increment mTestIndex before we start running the relevant
      // command.  That way if we lose the timeslice after we send the message
      // but before our function call returns, we won't end up with an
      // incorrect mTestIndex value observed when we get the response.
      err = DoTestStep(mTestIndex++);
      if (CHIP_NO_ERROR != err)
      {
          Exit(chip::ErrorStr(err));
      }
    }

  {{#if timeout}}
    chip::System::Clock::Timeout GetWaitDuration() const override { return chip::System::Clock::Seconds16(mTimeout.HasValue() ? mTimeout.Value() : {{timeout}}); }
  {{/if}}

  private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = {{totalTests}};

    {{#chip_tests_config}}
    chip::Optional<{{chipType}}> m{{asUpperCamelCase name}};
    {{/chip_tests_config}}

    {{>setupSaveAs}}

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint)
    {
        {{#if (chip_tests_config_has "endpoint")}}
        return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint;
        {{else}}
        return endpoint;
        {{/if}}
    }

    //
    // Tests methods
    //
    CHIP_ERROR DoTestStep(uint16_t testIndex)
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        {{#chip_tests_items}}
        case {{index}}: {
            {{>test_step}}
        }
        {{/chip_tests_items}}
        }
        return CHIP_NO_ERROR;
    }

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        using namespace chip::Protocols::InteractionModel;
        switch (mTestIndex - 1)
        {
        {{#chip_tests_items}}
        case {{index}}:
            {{>test_step_response}}
            break;
        {{/chip_tests_items}}
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

};

{{/chip_tests}}
