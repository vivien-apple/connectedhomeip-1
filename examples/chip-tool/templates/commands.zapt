{{> header}}

#pragma once

#include <cstdint>
#include <string>
#include <type_traits>

#include <app-common/zap-generated/cluster-objects.h>
#include <commands/clusters/ModelCommand.h>

{{> clusters_header}}

{{#chip_client_clusters}}
{{> cluster_header}}

{{#chip_cluster_commands}}
/*
 * Command {{asUpperCamelCase name}}
 */
class {{asUpperCamelCase clusterName}}{{asUpperCamelCase name}}: public ModelCommand
{
public:
    {{asUpperCamelCase clusterName}}{{asUpperCamelCase name}}(): ModelCommand("{{asDelimitedCommand name}}")
    {
        {{#chip_cluster_command_arguments}}
        {{~#*inline "field"}}mRequest.{{asLowerCamelCase label}}{{/inline~}}
        {{#if isArray}}
        // {{label}} Array parsing is not supported yet
        {{else if isStruct}}
        // {{label}} Struct parsing is not supported yet
        {{else if (isString type)}}
        AddArgument("{{asUpperCamelCase label}}", &{{>field}});
        {{else}}
        AddArgument("{{asUpperCamelCase label}}", {{asTypeMinValue type}}, {{asTypeMaxValue type}},
          {{~#if ./isEnum}}reinterpret_cast<std::underlying_type_t<decltype({{>field}})> *>(&{{>field}})
          {{else ./isBitmap}}reinterpret_cast<std::underlying_type_t<chip::app::Clusters::{{asUpperCamelCase parent.clusterName}}::{{asUpperCamelCase type}}> *>(&{{>field}})
          {{else}}&{{>field}}
          {{/if~}}
        );
        {{/if}}
        {{/chip_cluster_command_arguments}}
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster ({{asHex parent.code 8}}) command ({{asHex code 8}}) on endpoint %" PRIu16, endpointId);

        {{#chip_cluster_command_non_expanded_arguments}}
        {{#if isArray}}
        {{! TODO Implement complex types parsing in order to properly set the request parameters }}
        mRequest.{{asLowerCamelCase label}} = {{zapTypeToEncodableClusterObjectType type ns=parent.parent.name}}();
        {{/if}}
        {{/chip_cluster_command_non_expanded_arguments}}

        return RunCommand(device, endpointId, {{asHex parent.code 8}}, {{asHex code 8}}, mRequest);
    }

private:
    chip::app::Clusters::{{asUpperCamelCase parent.name}}::Commands::{{asUpperCamelCase name}}::Type mRequest;
};

{{/chip_cluster_commands}}

/*
 * Event Wildcard
 */
class ReadEvent{{asUpperCamelCase name}}Wildcard: public ModelCommand
{
public:
    ReadEvent{{asUpperCamelCase name}}Wildcard(): ModelCommand("read-event")
    {
        AddArgument("event-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEvent{{asUpperCamelCase name}}Wildcard()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, {{asHex code 8}}, chip::kInvalidEventId);
    }
};

class ReportEvent{{asUpperCamelCase name}}Wildcard: public ModelCommand
{
public:
    ReportEvent{{asUpperCamelCase name}}Wildcard(): ModelCommand("report-event")
    {
        AddArgument("event-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEvent{{asUpperCamelCase name}}Wildcard()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, {{asHex code 8}}, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

{{#chip_server_cluster_events}}
/*
 * Event {{asUpperCamelCase name}}
 */
class Read{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}: public ModelCommand
{
public:
    Read{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}(): ModelCommand("read-event")
    {
        AddArgument("event-name", "{{asDelimitedCommand (asUpperCamelCase name)}}");
        ModelCommand::AddArguments();
    }

    ~Read{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, {{asHex parent.code 8}}, {{asHex code 8}});
    }
};

class Report{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}: public ModelCommand
{
public:
    Report{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}(): ModelCommand("report-event")
    {
        AddArgument("event-name", "{{asDelimitedCommand (asUpperCamelCase name)}}");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~Report{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, {{asHex parent.code 8}}, {{asHex code 8}}, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
{{/chip_server_cluster_events}}

/*
 * Attribute wildcard
 */
class Read{{asUpperCamelCase name}}Wildcard: public ModelCommand
{
public:
    Read{{asUpperCamelCase name}}Wildcard(): ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~Read{{asUpperCamelCase name}}Wildcard()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, {{asHex code 8}}, chip::kInvalidAttributeId);
    }
};

class Report{{asUpperCamelCase name}}Wildcard: public ModelCommand
{
public:
    Report{{asUpperCamelCase name}}Wildcard(): ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~Report{{asUpperCamelCase name}}Wildcard()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, {{asHex code 8}}, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

{{#chip_server_cluster_attributes}}
{{! TODO: Various types (floats, structs) not supported here. }}
{{#unless (isStrEqual chipCallback.name "Unsupported")}}
/*
 * Attribute {{asUpperCamelCase name}}
 */
class Read{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}: public ModelCommand
{
public:
    Read{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}(): ModelCommand("read")
    {
        AddArgument("attr-name", "{{asDelimitedCommand (asUpperCamelCase name)}}");
        ModelCommand::AddArguments();
    }

    ~Read{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, {{asHex parent.code 8}}, {{asHex code 8}});
    }
};

{{#if isWritableAttribute}}
{{! No list support for writing yet.  Need to figure out how to represent the
    values. }}
{{#unless isList}}
class Write{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}: public ModelCommand
{
public:
    Write{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}(): ModelCommand("write")
    {
        AddArgument("attr-name", "{{asDelimitedCommand (asUpperCamelCase name)}}");
        {{#if isArray}}
        // {{label}} Array parsing is not supported yet
        {{else if isStruct}}
        // {{label}} Struct parsing is not supported yet
        {{else if (isString type)}}
        AddArgument("attr-value", &mValue);
        {{else}}
        AddArgument("attr-value", {{asTypeMinValue type}}, {{asTypeMaxValue type}}, &mValue);
        {{/if}}
        ModelCommand::AddArguments();
    }

    ~Write{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return WriteAttribute(device, endpointId, {{asHex parent.code 8}}, {{asHex code 8}}, mValue);
    }

private:
    {{zapTypeToEncodableClusterObjectType type ns=parent.name}} mValue;
};

{{/unless}}
{{/if}}
{{#if isReportableAttribute}}
class Report{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}: public ModelCommand
{
public:
    Report{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}(): ModelCommand("report")
    {
        AddArgument("attr-name", "{{asDelimitedCommand (asUpperCamelCase name)}}");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~Report{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, {{asHex parent.code 8}}, {{asHex code 8}}, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

{{/if}}
{{/unless}}
{{/chip_server_cluster_attributes}}
{{/chip_client_clusters}}

/*
 * Event Wildcard
 */
class ReadEventWildcard: public ModelCommand
{
public:
    ReadEventWildcard(): ModelCommand("read-event")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadEventWildcard()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadEvent(device, endpointId, chip::kInvalidClusterId, chip::kInvalidEventId);
    }
};

class ReportEventWildcard: public ModelCommand
{
public:
    ReportEventWildcard(): ModelCommand("report-event")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEventWildcard()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeEvent(device, endpointId, chip::kInvalidClusterId, chip::kInvalidEventId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    void OnEventSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

class ReadWildcard: public ModelCommand
{
public:
    ReadWildcard(): ModelCommand("read")
    {
        AddArgument("attr-name", "0xffffffff");
        ModelCommand::AddArguments();
    }

    ~ReadWildcard()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return ReadAttribute(device, endpointId, chip::kInvalidClusterId, chip::kInvalidAttributeId);
    }
};

class ReportWildcard: public ModelCommand
{
public:
    ReportWildcard(): ModelCommand("report")
    {
        AddArgument("attr-name", "0xffffffff");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWildcard()
    {
    }

    CHIP_ERROR SendCommand(ChipDevice * device, chip::EndpointId endpointId) override
    {
        return SubscribeAttribute(device, endpointId, chip::kInvalidClusterId, chip::kInvalidAttributeId, mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

    void OnAttributeSubscription() override
    {
        if (!mWait)
        {
            SetCommandExitStatus(CHIP_NO_ERROR);
        }
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Register all Clusters commands                                               |
\*----------------------------------------------------------------------------*/
{{#chip_client_clusters}}
void registerCluster{{asUpperCamelCase name}}(Commands & commands)
{
    const char * clusterName = "{{asUpperCamelCase name}}";

    commands_list clusterCommands = {
        {{#chip_cluster_commands}}
        make_unique<{{asUpperCamelCase clusterName}}{{asUpperCamelCase name}}>(), //
        {{/chip_cluster_commands}}
        make_unique<Read{{asUpperCamelCase name}}Wildcard>(), //
        make_unique<Report{{asUpperCamelCase name}}Wildcard>(), //
        {{#chip_server_cluster_attributes}}
        {{! TODO: Various types (floats, structs) not supported here. }}
        {{#unless (isStrEqual chipCallback.name "Unsupported")}}
        make_unique<Read{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}>(), //
        {{#if isWritableAttribute}}
        {{! No list support for writing yet.  Need to figure out how to
            represent the values. }}
        {{#unless isList}}
        make_unique<Write{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}>(), //
        {{/unless}}
        {{/if}}
        {{#if isReportableAttribute}}
        {{#unless isList}}
        make_unique<Report{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}>(), //
        {{/unless}}
        {{/if}}
        {{/unless}}
        {{/chip_server_cluster_attributes}}
        make_unique<ReadEvent{{asUpperCamelCase name}}Wildcard>(), //
        make_unique<ReportEvent{{asUpperCamelCase name}}Wildcard>(), //
        {{#chip_server_cluster_events}}
        make_unique<Read{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}>(), //
        make_unique<Report{{asUpperCamelCase parent.name}}{{asUpperCamelCase name}}>(), //
        {{/chip_server_cluster_events}}
    };

    commands.Register(clusterName, clusterCommands);
}
{{/chip_client_clusters}}

void registerClusterWildcard(Commands & commands)
{
    const char * clusterName = "0xffffffff";

    commands_list clusterCommands = {
        make_unique<ReadWildcard>(), //
        make_unique<ReportWildcard>(), //
        make_unique<ReadEventWildcard>(), //
        make_unique<ReportEventWildcard>(), //
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusters(Commands & commands)
{
    registerClusterWildcard(commands);
{{#chip_client_clusters}}
    registerCluster{{asUpperCamelCase name}}(commands);
{{/chip_client_clusters}}
}
