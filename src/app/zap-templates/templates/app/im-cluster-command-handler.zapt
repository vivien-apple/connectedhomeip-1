{{> header}}

#include <cstdint>
#include <cinttypes>

#include <app-common/zap-generated/af-structs.h>
#include <app-common/zap-generated/callback.h>
#include <app-common/zap-generated/cluster-objects.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app/util/util.h>
#include <app/CommandHandler.h>
#include <app/InteractionModelEngine.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/support/TypeTraits.h>

// Currently we need some work to keep compatible with ember lib.
#include <app/util/ember-compatibility-functions.h>

namespace chip {
namespace app {

namespace {
void MaybeDispatchServerError(CommandHandler * handler, const ConcreteCommandPath & path, CHIP_ERROR error)
{
    VerifyOrReturn(CHIP_NO_ERROR != error);

    if (error == CHIP_IM_GLOBAL_STATUS(UnsupportedCluster))
    {
        ChipLogError(Zcl, "Unknown cluster " ChipLogFormatMEI, ChipLogValueMEI(path.mClusterId));
    }
    else if (error == CHIP_IM_GLOBAL_STATUS(UnsupportedCommand))
    {
        // Unrecognized command ID, error status will apply.
        ChipLogError(Zcl, "Unknown command " ChipLogFormatMEI " for cluster " ChipLogFormatMEI,
                     ChipLogValueMEI(path.mCommandId), ChipLogValueMEI(path.mClusterId));
    }
    else
    {
        ChipLogProgress(Zcl, "Failed to dispatch command, Error=%" CHIP_ERROR_FORMAT, error.Format());
    }

    auto status = error.IsIMStatus() ? StatusIB(error).mStatus : Protocols::InteractionModel::Status::InvalidCommand;
    handler->AddStatus(path, status);
}
} // namespace

// Cluster specific command parsing

namespace Clusters {

{{#all_user_clusters_with_incoming_commands}}
{{#if (isServer clusterSide)}}
namespace {{asUpperCamelCase clusterName}} {

CHIP_ERROR DispatchServerCommand(CommandHandler * handler, const ConcreteCommandPath & path, TLV::TLVReader & tlvData)
{
    {{#all_incoming_commands_for_cluster clusterName clusterSide}}
    {{#first}}
    switch (path.mCommandId)
    {
    {{/first}}
        case Commands::{{asUpperCamelCase commandName}}::Id: {
            Commands::{{asUpperCamelCase commandName}}::DecodableType data;
            ReturnErrorOnFailure(DataModel::Decode(tlvData, data));
            VerifyOrReturnError(emberAf{{asUpperCamelCase parent.clusterName}}Cluster{{asUpperCamelCase commandName}}Callback(handler, path, data), CHIP_ERROR_INTERNAL);
            break;
        }
    {{#last}}
    default: {
        return CHIP_IM_GLOBAL_STATUS(UnsupportedCommand);
    }
    }
    {{/last}}
    {{/all_incoming_commands_for_cluster}}
    return CHIP_NO_ERROR;
}

}

{{/if}}
{{/all_user_clusters_with_incoming_commands}}

} // namespace Clusters

void DispatchSingleClusterCommand(const ConcreteCommandPath & aCommandPath, TLV::TLVReader & aReader, CommandHandler * apCommandObj)
{
    Compatibility::SetupEmberAfCommandHandler(apCommandObj, aCommandPath);

    CHIP_ERROR err = CHIP_NO_ERROR;
    switch (aCommandPath.mClusterId)
    {
    {{#all_user_clusters_with_incoming_commands}}
    {{#if (isServer clusterSide)}}
    case Clusters::{{asUpperCamelCase clusterName}}::Id:
        err = Clusters::{{asUpperCamelCase clusterName}}::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
        break;
    {{/if}}
    {{/all_user_clusters_with_incoming_commands}}
    default:
        err = CHIP_IM_GLOBAL_STATUS(UnsupportedCluster);
        break;
    }
    MaybeDispatchServerError(apCommandObj, aCommandPath, err);

    Compatibility::ResetEmberAfObjects();
}

} // namespace app
} // namespace chip
